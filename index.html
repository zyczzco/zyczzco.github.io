<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="zyc study blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LAYCHOUblog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="LAYCHOUblog">
<meta property="og:description" content="zyc study blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="LAYCHOU">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LAYCHOUblog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="LAYCHOUblog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LAYCHOUblog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LAYCHOU"
      src="/images/mypic.jpg">
  <p class="site-author-name" itemprop="name">LAYCHOU</p>
  <div class="site-description" itemprop="description">zyc study blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zyczzco" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zyczzco" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1007611579@qq.com" title="E-Mail → 1007611579@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-12 09:22:04" itemprop="dateCreated datePublished" datetime="2022-08-12T09:22:04+08:00">2022-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 20:28:31" itemprop="dateModified" datetime="2022-09-23T20:28:31+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a><strong>什么是设计模式？</strong></h3><p>参考来源于 鱼皮 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/11HvyNLC4_GPICVG0BufDA">https://mp.weixin.qq.com/s/11HvyNLC4_GPICVG0BufDA</a></p>
<p>设计模式是我们开发软件时针对常见问题的 <strong>通用</strong> 解决方案，也是前辈们在写代码时不断摸索总结出来的好方法。</p>
<p>可以理解为打游戏的攻略，就是我们遇到同一类的对手时，怎么走位、怎么放技能之类的。</p>
<h3 id="设计模式有什么用？"><a href="#设计模式有什么用？" class="headerlink" title="设计模式有什么用？"></a><strong>设计模式有什么用？</strong></h3><p>设计模式最直接的作用就是 <strong>减少烂代码、让项目代码更好维护</strong> 。</p>
<p>举个栗子，如果没学过设计模式，可能随着产品不断加需求、改需求，你的代码会充满大量的 if else，新同事来了呢，也不敢动前人代码，只能再去补充 if else，于是屎山越堆越高。</p>
<p>而使用设计模式后，你可以把每段逻辑单独封装和维护，大家协作开发也会更高效。</p>
<h3 id="为什么要学设计模式？"><a href="#为什么要学设计模式？" class="headerlink" title="为什么要学设计模式？"></a><strong>为什么要学设计模式？</strong></h3><p>学好设计模式，不仅能让我们写出更好维护、性能更高的代码，还能开拓我们的思维，在遇到问题时能想到更多的解决方案。</p>
<p>因此设计模式也是软件开发岗面试的重点，想进大厂的同学一定要学习它。</p>
<p>此外，很多知名项目都用到了大量的设计模式，比如 Spring、MyBatis 等。如果不学习它，可能你天天写代码都是 CRUD、读别人的源码会非常吃力。</p>
<p>所以建议开发岗的朋友们都要认真学习设计模式。</p>
<h3 id="什么时候学？"><a href="#什么时候学？" class="headerlink" title="什么时候学？"></a><strong>什么时候学？</strong></h3><p>我建议大家在学过一门编程语言、并且能够使用开发框架去完成项目之后，再去学设计模式。如果你写代码的熟练度还不够的话，直接去学设计模式会比较吃力，可能也无法理解用设计模式的好处。</p>
<p>那如果你学前端的话，我建议你先把界面开发、JS 语法、组件库和 Vue / React 之类的框架运用熟练，有空了再把设计模式作为进阶知识来学习就好。</p>
<h3 id="要学什么？"><a href="#要学什么？" class="headerlink" title="要学什么？"></a><strong>要学什么？</strong></h3><p>设计模式的学习主要分为两部分：</p>
<h4 id="1-软件开发原则"><a href="#1-软件开发原则" class="headerlink" title="1. 软件开发原则"></a>1. 软件开发原则</h4><p>所有的设计模式基本都是建立以下几个软件开发原则的基础上。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUGiaj4F3X65ibqWtvvr8ewltMWCHhOY4UaWONzsRmCMXclP2Z4ibSU29OA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>比如开闭原则，就是建议我们把模块设计的好扩展一些，每次新增功能只需要加代码、而不用改老代码。</p>
<h4 id="2-学习主流设计模式"><a href="#2-学习主流设计模式" class="headerlink" title="2. 学习主流设计模式"></a>2. 学习主流设计模式</h4><p>主流的设计模式共有以下 23 种：</p>
<blockquote>
<p>注意，不是说设计模式只有 23 种！</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUGD8HznaJGEEHPPnYINalq6ZCnkvGJu5JbhmyhicmYu3LMibJzvaibjBMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">设计模式学习路线 by 程序员鱼皮</p>
<p>其中单例、工厂方法、建造者、适配器、装饰器、代理、策略、责任链、观察者、迭代器模式是重点，我自己工作中经常用到这些、也总能在框架源码中见到它们。这些设计模式的特色也比较鲜明、相对比较好理解。</p>
<p>尤其是单例模式，是重点中的重点！它有很多种不同的实现方式，都要了解。我用的最多的应该是饿汉式还有双检锁模式。</p>
<h2 id="设计模式学习路线"><a href="#设计模式学习路线" class="headerlink" title="设计模式学习路线"></a>设计模式学习路线</h2><p>建议大家按照以下 3 个阶段来学习：</p>
<h3 id="一、基础学习"><a href="#一、基础学习" class="headerlink" title="一、基础学习"></a><strong>一、基础学习</strong></h3><p>目标：从上面提到的重点开始依次了解每一种设计模式的概念、作用、应用场景、特点、类和对象的关系，能够对设计模式有个基础的印象。</p>
<p>学习方式有很多种：</p>
<ul>
<li>喜欢看视频的同学挑个高播放量的、讲师口音能接受的教程看就好了；</li>
<li>喜欢读书的同学可以看《图解设计模式》、《大话设计模式》，个人感觉这两本书都还不错，我自己是看前者入门的。</li>
<li>想快速上手的同学可以直接看菜鸟教程的文档，每个设计模式都有讲解和代码示例，还是比较推荐的。像我有的时候忘了某个冷门的设计模式，也是靠这个文档快速补回来。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUoEghice0Xw5JK6pzgtSGeDMia37vWTawESNLBTibAbQp5sjAEHBxF3rGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里建议大家在学设计模式的时候多和实际生活结合，会更好理解一些。</p>
<p>比如适配器模式可以理解为用一个转接头连接两根线；代理模式理解为你找了个代购帮你去买东西；责任链模式理解为公司出了问题，员工依次甩锅。</p>
<h3 id="二、编码实现"><a href="#二、编码实现" class="headerlink" title="二、编码实现"></a><strong>二、编码实现</strong></h3><p>这个阶段的目标是：用你熟悉的编程语言来写代码实现每个设计模式，要能够独立（不借助任何资料）从 0 写出完整代码，这样才算是学会了。</p>
<p>如果刚开始大家不知道设计模式怎么应用的话，我建议去看一些示例代码。</p>
<p>可以直接在 GitHub 搜索关键词 <code>Design Pattern</code> 或 <code>设计模式</code> ，就能搜出来一大堆不同语言的代码了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUx4hOjIG7YuicA90Qf3EfAfuwOdicw4hZ9LibxavC8tgfmK4aCcLSiayqTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那我建议大家把自己写过的代码保存好，可以打造一个自己的设计模式代码库，写在简历上也是能加分的。</p>
<h3 id="三、项目实战"><a href="#三、项目实战" class="headerlink" title="三、项目实战"></a><strong>三、项目实战</strong></h3><p>本阶段的目标：能够根据某个场景主动选出合适的设计模式来优化代码，而不是说别人告诉你这里能用设计模式，你才想起来去用。这就是架构师和拧螺丝的区别。</p>
<p>这里给大家两个学习方法吧：</p>
<h4 id="1-搜索式"><a href="#1-搜索式" class="headerlink" title="1. 搜索式"></a>1. 搜索式</h4><p>花时间到网上搜设计模式在知名框架中的应用，比如 Spring：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUUAtlj0D4CfxNo6iavbExxzkAJefNFLiaJBlQfPRKUMtybcNwr1eRGYBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>网上的文章很多，我就不一一列举了。比较建议大家在面试前这么干，可以快速积累。</p>
<h4 id="2-探索式"><a href="#2-探索式" class="headerlink" title="2. 探索式"></a>2. 探索式</h4><p>就是在你写代码的过程中，一旦遇到重复代码，就问一下自己：我能不能用上某个设计模式呢？合适的话就使用设计模式。次数多了，你就有经验了。</p>
<p>此外，我自己在写代码时，特别喜欢点进源码看一看，一般是能够通过文件命名来快速判断出它是否使用了设计模式的，然后你就可以进一步读源码来学习，帮助我积累了很多知识。</p>
<p>但我们也要注意，设计模式虽然好用，但它不是银弹，不要为了用而用。</p>
<p>比如非要把一句简单的 if else 搞成策略模式，过分使用设计模式只会徒增系统的复杂度。</p>
<h3 id="面试考点"><a href="#面试考点" class="headerlink" title="面试考点"></a><strong>面试考点</strong></h3><p>面试时对设计模式的考察可能比较多元，主要有理论、实践、源码等考法：</p>
<p>理论就是问你不同设计模式的概念、优缺点、应用场景，设计模式之间的区别等等。</p>
<p>实践就是让你手写某个设计模式。最常考的就是单例模式，我就被考过，当时还让我写出几种不同的单例模式实现。</p>
<p>源码就是说问你某个框架用了哪些设计模式，或者某个设计模式在哪些框架中应用过。如果我是面试官，大概率会这么考，因为能看出候选人的知识储备。</p>
<p>所以要想在设计模式这块不吃瘪，除了背八股文外，还是要保证能手写出常考的设计模式，并且多去了解一下它在知名项目中的应用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A6%81%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A6%81%E7%82%B9/" class="post-title-link" itemprop="url">设计模式学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-11 11:22:04" itemprop="dateCreated datePublished" datetime="2022-08-11T11:22:04+08:00">2022-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 20:29:20" itemprop="dateModified" datetime="2022-09-23T20:29:20+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>41k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>37 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>整理来源于 </p>
<p><strong>【作者：刘伟</strong> <a target="_blank" rel="noopener" href="http://blog.csdn.net/lovelion"><strong>http://blog.csdn.net/lovelion</strong></a><strong>】</strong></p>
<p>单例√、工厂方法√、建造者√、适配器√、装饰器√、代理√、策略、责任链、观察者、迭代器模式</p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>*<em>单一职责原则*</em>(Single Responsibility Principle, SRP)*<em>：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</em>*</p>
<p>Sunny软件公司开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：</p>
<p>图1  初始设计方案结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336147233_3529.jpg" alt="1336147233_3529"></p>
<p>在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p>
<p>现使用单一职责原则对其进行重构。</p>
<pre><code>  在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：

  (1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；

  (2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；

  (3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。

  使用单一职责原则重构后的结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336147240_4896.jpg" alt="1336147240_4896"></p>
<h3 id="开闭封闭原则"><a href="#开闭封闭原则" class="headerlink" title="开闭封闭原则"></a>开闭封闭原则</h3><p>*<em>开闭原则*</em>(Open-Closed Principle, OCP)*<em>：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</em>*</p>
<p> 在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p>
<p><strong>抽象化是开闭原则的关键</strong>。</p>
<p>Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336201566_1496.jpg" alt="1336201566_1496"></p>
<p>  在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p>
<pre><code>  现对该系统进行重构，使之符合开闭原则。

   在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：

  (1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；

  (2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。

  重构后结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336201573_6059.jpg" alt="1336201573_6059"></p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<pre><code>  里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
</code></pre>
<p>   里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<pre><code>  在使用里氏代换原则时需要注意如下几个问题：

  (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。

  (2)  我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。

  (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。
</code></pre>
<p> 在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图1所示：</p>
<p>图1原始结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336312710_1412.jpg" alt="1336312710_1412"></p>
<pre><code>  在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。

  在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图2所示：
</code></pre>
<p>图2  重构后的结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336312720_2300.jpg" alt="1336312720_2300"></p>
<pre><code>  里氏代换原则是实现开闭原则的重要方式之一。在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。
</code></pre>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p><em><strong>*依赖倒转原则**(Dependency Inversion Principle, DIP)**：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。*</strong></em></p>
<p>​         依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p>
<p>​        在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入(DependencyInjection, DI)<strong>的方式注入到其他对象中，</strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</strong>常用的注入方式有三种，分别是：<strong>构造注入，设值注入（Setter注入）和接口注入</strong>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p>
<p> 下面通过一个简单实例来加深对依赖倒转原则的理解：</p>
<pre><code>  Sunny软件公司开发人员在开发某CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图1所示：
</code></pre>
<p>图1 初始设计方案结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336909329_9009.jpg" alt="1336909329_9009"></p>
<pre><code>  在编码实现图1所示结构时，Sunny软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。

  在本实例中，由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图2所示：
</code></pre>
<p>图2重构后的结构图</p>
<p>​     <img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336909334_4352.jpg" alt="1336909334_4352"></p>
<p>  在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，<strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，</strong>它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>**接口隔离原则(Interface Segregation Principle, ISP)**：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong></p>
<p>一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“<strong>角色隔离原则</strong>”。</p>
<p><strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</strong>。</p>
<p>Sunny软件公司开发人员针对某CRM系统的客户数据显示模块设计了如图1所示接口，其中方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/11.jpg" alt="11"></p>
<p>图1 初始设计方案结构图</p>
<pre><code>  在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。

  现使用接口隔离原则对其进行重构。
</code></pre>
<p>  在图1中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。</p>
<pre><code>  通过使用接口隔离原则，本实例重构后的结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/111.jpg" alt="111"></p>
<p>图2 重构后的结构图</p>
<p>  <strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>**合成复用原则(Composite Reuse Principle, CRP)**：尽量使用对象组合，而不是继承来达到复用的目的。</p>
<p>*<em>复用时要尽量使用组合*</em>/**聚合关系（关联关系），少用继承**。</p>
<p>即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，<strong>组合/聚合可以使系统更加灵活，降低类与类之间的耦合度</strong>，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，<strong>而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</strong></p>
<p>  Sunny软件公司开发人员在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图1所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/22.jpg" alt="22"></p>
<p>图1  初始设计方案结构图</p>
<p>  随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。【当然也可以修改DBUtil类的源代码，同样会违反开闭原则。】</p>
<p>  现使用合成复用原则对其进行重构。</p>
<p>  根据合成复用原则，我们在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如图2所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/222.jpg" alt="222"></p>
<p> 在图2中，<strong>CustomerDAO和DBUtil之间的关系由继承关系变为关联关系</strong>，<strong>采用依赖注入的方式将DBUtil对象注入到CustomerDAO中</strong>，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>迪米特法则(Law of Demeter, LoD)：</strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
<p>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>
<p>迪米特法则中，对于一个对象，其朋友包括以下几类：</p>
<pre><code>  (1) 当前对象本身(this)；

  (2) 以参数形式传入到当前对象方法中的对象；

  (3) 当前对象的成员对象；

  (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；

  (5) 当前对象所创建的对象。
</code></pre>
<p>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</strong></p>
<p>  在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</strong></p>
<p>下面通过一个简单实例来加深对迪米特法则的理解：</p>
<p>  Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图1所示结构：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/333.jpg" alt="333"></p>
<p>图1 初始设计方案结构图</p>
<p>  在图1中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p>
<p>  现使用迪米特对其进行重构。</p>
<p>  在本实例中，<strong>可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码</strong>，重构后结构如图2所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/33.jpg" alt="33"></p>
<p>图2  重构后的结构图</p>
<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h2 id="一、创建模式"><a href="#一、创建模式" class="headerlink" title="一、创建模式"></a>一、创建模式</h2><h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><h4 id="1-1简单工厂模式"><a href="#1-1简单工厂模式" class="headerlink" title="1.1简单工厂模式"></a>1.1简单工厂模式</h4><p><strong>具体产品类</strong>实现<strong>抽象产品类</strong>，<strong>工厂类</strong>进行类型判断执行<strong>具体产品类</strong>的方法</p>
<p>简单工厂模式(Simple Factory Pattern)：<strong>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</strong>因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<p><strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/123.jpg" alt="123"></p>
<p>为了将Chart类的职责分离，同时将Chart对象的创建和使用分离，Sunny软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图2所示：</p>
<p><img src="https://img-blog.csdn.net/20130711144554265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>图2图表库结构图</p>
<p>总结<br>      简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<pre><code>     1. 主要优点

   简单工厂模式的主要优点如下：

   (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

   (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

   (3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。













     2. 主要缺点

   简单工厂模式的主要缺点如下：

   (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

   (2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。

   (3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

   (4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。













    3. 适用场景

   在以下情况下可以考虑使用简单工厂模式：

   (1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。

   (2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。
</code></pre>
<h4 id="1-2工厂方法模式"><a href="#1-2工厂方法模式" class="headerlink" title="1.2工厂方法模式"></a>1.2工厂方法模式</h4><p><strong>具体产品类</strong>实现<strong>抽象产品类</strong>，<strong>具体工厂类</strong>实现<strong>抽象产品类</strong></p>
<p>通过<strong>具体工厂类</strong>来调用构造<strong>具体产品类</strong></p>
<p>当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？</p>
<p>在工厂方法模式中，我们<strong>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</strong>。工厂方法模式定义如下：</p>
<pre><code>   工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。
</code></pre>
<p>   工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图2所示：<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.2.jpg" alt="1.1.2"></p>
<pre><code>   在工厂方法模式结构图中包含如下几个角色：

   ● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。

   ● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。

   ● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。

   ● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。
</code></pre>
<p>完整解决方案</p>
<p>​     Sunny公司开发人员决定使用工厂方法模式来设计日志记录器，其基本结构如图3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.2.1.jpg" alt="1.1.2.1"></p>
<p>工厂方法模式总结<br>      工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p>
<pre><code>1. 主要优点
</code></pre>
<p>   工厂方法模式的主要优点如下：</p>
<p>   (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>   (2) 基于工厂角色和产品角色的<strong>多态性设计</strong>是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有<strong>同一抽象父类</strong>。</p>
<p>   (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，<strong>无须修改抽象工厂和抽象产品提供的接口</strong>，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，<strong>完全符合“开闭原则</strong>”。</p>
<ol start="2">
<li>主要缺点</li>
</ol>
<p> 工厂方法模式的主要缺点如下：</p>
<p>  (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，<strong>在一定程度上增加了系统的复杂度</strong>，<strong>有更多的类需要编译和运行，会给系统带来一些额外的开销。</strong></p>
<p>  (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<ol start="3">
<li>适用场景</li>
</ol>
<p>   在以下情况下可以考虑使用工厂方法模式：</p>
<p>   (1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p>   (2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
<h4 id="1-3抽象工厂模式"><a href="#1-3抽象工厂模式" class="headerlink" title="1.3抽象工厂模式"></a>1.3抽象工厂模式</h4><p>​    <strong>具体产品类</strong>实现<strong>抽象产品</strong>接口，<strong>具体工厂类</strong>实现<strong>抽象工厂接口</strong></p>
<p>​    具体工厂类构造一系列产品族，每个具体工厂对应一个产品等级。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.3.jpg" alt="1.1.3.3"></p>
<h5 id="1-为什么引入抽象工厂模式"><a href="#1-为什么引入抽象工厂模式" class="headerlink" title="1.为什么引入抽象工厂模式"></a>1.为什么引入抽象工厂模式</h5><pre><code> 界面皮肤库的初始设计
   Sunny软件公司欲开发一套界面皮肤库，可以对Java桌面软件进行界面美化。为了保护版权，该皮肤库源代码不打算公开，而只向用户提供已打包为jar文件的class字节码文件。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，其结构示意图如图1所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.jpg" alt="1.1.3"></p>
<p>图1 界面皮肤库结构示意图</p>
<pre><code>   该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。

   Sunny软件公司的开发人员针对上述要求，决定使用工厂方法模式进行系统的设计，为了保证系统的灵活性和可扩展性，提供一系列具体工厂来创建按钮、文本框、组合框等界面元素，客户端针对抽象工厂编程，初始结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.1.jpg" alt="1.1.3.1"></p>
<p>图2 基于工厂方法模式的界面皮肤库初始结构图</p>
<p>   在图2中，提供了大量工厂来创建具体的界面组件，可以通过配置文件更换具体界面组件从而改变界面风格。但是，此设计方案存在如下问题：</p>
<p>   (1) 当需要增加新的皮肤时，虽然不要修改现有代码，但是需要增加大量类，针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加，这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销；</p>
<p>   (2) 由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。</p>
<p>   如何减少系统中类的个数并保证客户端每次始终只使用某一种风格的具体界面组件？这是Sunny公司开发人员所面临的两个问题，显然，工厂方法模式无法解决这两个问题，别着急，本文所介绍的抽象工厂模式可以让这些问题迎刃而</p>
<h5 id="2-产品等级结构与产品族"><a href="#2-产品等级结构与产品族" class="headerlink" title="2 产品等级结构与产品族"></a>2 产品等级结构与产品族</h5><p>​       在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解抽象工厂模式，我们先引入两个概念：</p>
<pre><code>   (1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

   (2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。
</code></pre>
<p> 产品等级结构与产品族示意图如图3所示：<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.2.jpg" alt="1.1.3.2"></p>
<p>当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.3.jpg" alt="1.1.3.3"></p>
<p>图4 抽象工厂模式示意图</p>
<pre><code>   在图4中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图4所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数。
</code></pre>
<h5 id="3-抽象工厂模式概述"><a href="#3-抽象工厂模式概述" class="headerlink" title="3 抽象工厂模式概述"></a>3 抽象工厂模式概述</h5><p>​       抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。抽象工厂模式定义如下：</p>
<p>   <strong>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</strong></p>
<p>   在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图5所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.4.jpg" alt="1.1.3.4"></p>
<p>图5  抽象工厂模式结构图</p>
<pre><code>   在抽象工厂模式结构图中包含如下几个角色：

   ● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。

   ● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。

   ● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。

   ● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

   在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：
</code></pre>
<h5 id="4-完整解决方案"><a href="#4-完整解决方案" class="headerlink" title="4 完整解决方案"></a>4 完整解决方案</h5><p>​    Sunny公司开发人员使用抽象工厂模式来重构界面皮肤库的设计，其基本结构如图6所示：</p>
<p><img src="https://img-blog.csdn.net/20130713164620203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>图6界面皮肤库结构图</p>
<h5 id="5-“开闭原则”的倾斜性"><a href="#5-“开闭原则”的倾斜性" class="headerlink" title="5 “开闭原则”的倾斜性"></a>5 “开闭原则”的倾斜性</h5><p>​       Sunny公司使用抽象工厂模式设计了界面皮肤库，该皮肤库可以较为方便地增加新的皮肤，但是现在遇到一个非常严重的问题：由于设计时考虑不全面，忘记为单选按钮(RadioButton)提供不同皮肤的风格化显示，导致无论选择哪种皮肤，单选按钮都显得那么“格格不入”。Sunny公司的设计人员决定向系统中增加单选按钮，但是发现原有系统居然不能够在符合“开闭原则”的前提下增加新的组件，原因是抽象工厂SkinFactory中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先需要修改抽象工厂接口SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。</p>
<p>   怎么办？答案是抽象工厂模式无法解决该问题，这也是抽象工厂模式最大的缺点。<strong>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。</strong>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<p>   <strong>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</strong></p>
<p>   <strong>(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</strong></p>
<p>   正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p>
<h5 id="6-抽象工厂模式总结"><a href="#6-抽象工厂模式总结" class="headerlink" title="6 抽象工厂模式总结"></a>6 抽象工厂模式总结</h5><p>​       抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p>
<pre><code>   1. 主要优点

   抽象工厂模式的主要优点如下：

   (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。

   (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。

   (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。



   2. 主要缺点

   抽象工厂模式的主要缺点如下：

   增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。













   3. 适用场景

   在以下情况下可以考虑使用抽象工厂模式：

   (1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。

   (2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。

   (3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。

   (4) 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。
</code></pre>
<h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p><strong>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</strong></p>
<p> 单例模式有三个要点：</p>
<p><strong>一是某个类只能有一个实例</strong></p>
<p><strong>二是它必须自行创建这个实例</strong></p>
<p><strong>三是它必须自行向整个系统提供这个实例。</strong></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.2.jpg" alt="1.2"></p>
<h4 id="2-1饿汉式单例类"><a href="#2-1饿汉式单例类" class="headerlink" title="2.1饿汉式单例类"></a>2.1饿汉式单例类</h4><pre><code>  饿汉式单例类是实现起来最简单的单例类，饿汉式单例类结构图如图3-4所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.2.1.jpg" alt="1.2.1"></p>
<pre><code>    从图3-4中可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象，代码如下所示：
</code></pre>
<p>class EagerSingleton {<br>    private static final EagerSingleton instance = new EagerSingleton();<br>    private EagerSingleton() { } </p>
<pre><code>public static EagerSingleton getInstance() &#123;
    return instance; 
&#125;   
</code></pre>
<p>}<br>      <strong>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</strong></p>
<h4 id="2-2懒汉式单例类与线程锁定"><a href="#2-2懒汉式单例类与线程锁定" class="headerlink" title="2.2懒汉式单例类与线程锁定"></a>2.2懒汉式单例类与线程锁定</h4><pre><code>  除了饿汉式单例，还有一种经典的懒汉式单例，也就是前面的负载均衡器LoadBalancer类的实现方式。懒汉式单例类结构图如图3-5所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.2.2.jpg" alt="1.2.2"></p>
<p>  从图3-5中可以看出，懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LazySingleton &#123; </span><br><span class="line">    private static LazySingleton instance = null;]() </span><br><span class="line"></span><br><span class="line">private LazySingleton() &#123; &#125; </span><br><span class="line"></span><br><span class="line">synchronized public static LazySingleton getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        instance = new LazySingleton(); </span><br><span class="line">    &#125;</span><br><span class="line">    return instance; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​      但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码“instance = new LazySingleton();”进行锁定即可。<strong>即通过synchronized代码块来实现同步</strong>，因此getInstance()方法可以进行如下改进：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static LazySingleton getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        synchronized (LazySingleton.class) &#123;</span><br><span class="line">            instance = new LazySingleton(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​       问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一。原因如下：<br>​      </p>
<p>​         假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。</p>
<p>​        <strong>但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象</strong>，违背单例模式的设计思想，因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，</p>
<p>​        这种方式称为**双重检查锁定(Double-Check Locking)**。使用双重检查锁定实现的懒汉式单例类完整代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class LazySingleton &#123; </span><br><span class="line">    private volatile static LazySingleton instance = null; </span><br><span class="line"></span><br><span class="line">private LazySingleton() &#123; &#125; </span><br><span class="line"></span><br><span class="line">public static LazySingleton getInstance() &#123; </span><br><span class="line">    //第一重判断</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        //锁定代码块</span><br><span class="line">        synchronized (LazySingleton.class) &#123;</span><br><span class="line">            //第二重判断</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new LazySingleton(); //创建单例实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​       需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p>
<h5 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h5><p>双检锁：单例模式中用volatile和synchronized来满足双重检查锁机制；<br>在实现单例模式的时候往往会忽略掉多线程的情况而volatile（java5）：可以保证多线程下的可见性;<br>双重检查锁：</p>
<p>双重锁进行了两次判空：第一层判断为了避免不必要的同步，第二层判断则是为了在null的情况下创建实例代码会检查两次单例类是否有已存在的实例，一次加锁一次不加锁，一次确保不会有多个实例被创建。单例模式中用volatile和synchronized来满足双重检查锁机制</p>
<p>读volatile：每当子线程某一语句要用到volatile变量时，都会从主线程重新拷贝一份，这样就保证子线程的会跟主线程的一致。<br>写volatile: 每当子线程某一语句要写volatile变量时，都会在读完后同步到主线程去，这样就保证主线程的变量及时更新。<br>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。<br>1：使用 volatile定义的变量，将会保证对所有线程的可见性。2：禁止指令重排序优化。<br>由于 volatile禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。<br>对象的创建可能发生指令的重排序，使用 volatile可以禁止指令的重排序，保证多线程环境内的系统安全。</p>
<h4 id="2-3单例模式总结"><a href="#2-3单例模式总结" class="headerlink" title="2.3单例模式总结"></a>2.3单例模式总结</h4><p>​       单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p>
<p>1.主要优点</p>
<p>   单例模式的主要优点如下：</p>
<p>   (1) 单例模式提供了对<strong>唯一实例的受控访问</strong>。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</p>
<p>   (2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，<strong>对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</strong></p>
<p>   (3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。 </p>
<p>2.主要缺点</p>
<p>   单例模式的主要缺点如下：</p>
<p>   (1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</p>
<p>   (2) <strong>单例类的职责过重，在一定程度上违背了“单一职责原则”。</strong>因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</p>
<p>   (3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，<strong>因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</strong></p>
<p>3.适用场景</p>
<p>   在以下情况下可以考虑使用单例模式：</p>
<p>   (1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>
<p>   (2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>
<h3 id="3、建造者模式"><a href="#3、建造者模式" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h3><p><strong>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</strong></p>
<p> 建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图8-2所示：<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.jpg" alt="1.3"></p>
<p>图8-2 建造者模式结构图</p>
<p>  在建造者模式结构图中包含如下几个角色：</p>
<p>● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p>
<p>●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p>
<p>●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p>
<p>● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p>
<h4 id="案例–解决方案"><a href="#案例–解决方案" class="headerlink" title="案例–解决方案"></a>案例–解决方案</h4><p>   Sunny公司开发人员决定使用建造者模式来实现游戏角色的创建，其基本结构如图8-3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.1.jpg" alt="1.3.1"></p>
<p><strong>图*<em>8-3*</em> 游戏角色创建结构图</strong></p>
<p>在建造者模式中，<strong>客户端只需实例化指挥者类，指挥者类针对抽象建造者编程</strong>，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品（逐步调用具体建造者的buildX()方法），相同的构造过程可以创建完全不同的产品。在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。</p>
<p>在建造者模式中，客户端只需实例化指挥者类，指挥者类针对抽象建造者编程，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品（逐步调用具体建造者的buildX()方法），相同的构造过程可以创建完全不同的产品。在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。</p>
<p> **<em>*1.*<em>省略*<em>Director*</em></em></em></p>
<p>   在有些情况下，为了简化系统结构，可以将Director和抽象建造者Builder进行合并，在Builder中提供逐步构建复杂产品对象的construct()方法。由于Builder类通常为抽象类，因此可以将construct()方法定义为静态(static)方法</p>
<p>**<em>*2.*<em>钩子方法的引入</em></em></p>
<p>​    建造者模式除了逐步构建一个复杂产品对象外，还可以通过Director类来更加精细地控制产品的创建过程，例如增加一类称之为钩子方法(HookMethod)的特殊方法来控制是否对某个buildPartX()的调用。</p>
<h4 id="建造者模式总结"><a href="#建造者模式总结" class="headerlink" title="建造者模式总结"></a>建造者模式总结</h4><p>​      建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。</p>
<p>1.主要优点</p>
<p>  建造者模式的主要优点如下：</p>
<p>(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，<strong>使得相同的创建过程可以创建不同的产品对象。</strong></p>
<p>(2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很<strong>方便地替换具体建造者或增加新的具体建造者</strong>，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，<strong>系统扩展方便</strong>，<strong>符合“开闭原则”</strong></p>
<p>(3) <strong>可以更加精细地控制产品的创建过程。</strong>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p>2.主要缺点</p>
<p>  建造者模式的主要缺点如下：</p>
<p>(1) <strong>建造者模式所创建的产品一般具有较多的共同点</strong>，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其<strong>使用范围受到一定的限制</strong>。</p>
<p>(2) <strong>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</strong></p>
<p>3.适用场景</p>
<pre><code>  在以下情况下可以考虑使用建造者模式：
</code></pre>
<p>(1) 需要生成的产品对象有<strong>复杂的内部结构，这些产品对象通常包含多个成员属性。</strong></p>
<p>(2) 需要<strong>生成的产品对象的属性相互依赖</strong>，需要<strong>指定其生成顺序</strong>。</p>
<p>(3) 对象的创建过程<strong>独立于</strong>创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</p>
<p>(4) <strong>隔离复杂对象的创建和使用</strong>，并使得相同的创建过程可以创建不同的产品。</p>
<h3 id="1-4原型模式"><a href="#1-4原型模式" class="headerlink" title="1.4原型模式"></a>1.4原型模式</h3><p><strong>原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</strong></p>
<p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p>
<p>  需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.2.jpg" alt="1.3.2"></p>
<p>7-2 原型模式结构图</p>
<pre><code>  在原型模式结构图中包含如下几个角色：

  ●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。

  ● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

  ● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。
</code></pre>
<p>1.浅克隆</p>
<pre><code>  在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，如图7-4所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.3.jpg" alt="1.3.3"></p>
<p>图7-4 浅克隆示意图</p>
<pre><code>  在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。为了让大家更好地理解浅克隆和深克隆的区别，我们首先使用浅克隆来实现工作周报和附件类的复制，其结构如图7-5所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.4.jpg" alt="1.3.4"></p>
<p>2.深克隆</p>
<pre><code>  在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制，如图7-6所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.6.jpg" alt="1.3.6"></p>
<p>图7-6 深克隆示意图</p>
<pre><code>  在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。下面我们使用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写入流中，因此两个类均需要实现Serializable接口，其结构如图7-7所示：
</code></pre>
<p>图7-7 带附件的周报结构图（深克隆）<br><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.5.jpg" alt="1.3.5"></p>
<h2 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h2><h3 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h3><p>​    <strong>抽象接口定义请求方法，适配器实现具体请求调用创建过程，适配者实现请求具体方法</strong></p>
<p>​    <strong>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</strong></p>
<p><strong>【注：在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。】</strong></p>
<p>   在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，<strong>适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</strong>在实际开发中，对象适配器的使用频率更高，对象适配器模式结构如图9-3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.1.jpg" alt="2.1"></p>
<p>图 9-3 对象适配器模式结构图</p>
<p>   在对象适配器模式结构图中包含如下几个角色：</p>
<p>   ● Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
<p>   ● Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p>
<p>   ● Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p>
<h4 id="对象适配器案例"><a href="#对象适配器案例" class="headerlink" title="对象适配器案例"></a>对象适配器案例</h4><p>Sunny软件公司开发人员决定使用适配器模式来重用算法库中的算法，其基本结构如图9-4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.1.1.jpg" alt="2.1.1"></p>
<p>图9-4  算法库重用结构图</p>
<p>   在图9-4中，ScoreOperation接口充当抽象目标，QuickSort和BinarySearch类充当适配者，OperationAdapter充当适配器。完整代码如下所示：</p>
<p>//抽象成绩操作类：目标接口</p>
<p>interface ScoreOperation {</p>
<p>​    public int[] sort(int array[]); //成绩排序</p>
<p>​    public int search(int array[],int key); //成绩查找</p>
<p>}</p>
<p>//快速排序类：适配者</p>
<p>class QuickSort {</p>
<p>​    public int[] quickSort(int array[]) {</p>
<p>​        sort(array,0,array.length-1);</p>
<p>​        return array;</p>
<p>​    }</p>
<p>​    public void sort(int array[],int p, int r) {</p>
<p>​        int q=0;</p>
<p>​        if(p&lt;r) {</p>
<p>​            q=partition(array,p,r);</p>
<p>​            sort(array,p,q-1);</p>
<p>​            sort(array,q+1,r);</p>
<p>​        }</p>
<p>​    }</p>
<p>​    public int partition(int[] a, int p, int r) {</p>
<p>​        int x=a[r];</p>
<p>​        int j=p-1;</p>
<p>​        for (int i=p;i&lt;=r-1;i++) {</p>
<p>​            if (a[i]&lt;=x) {</p>
<p>​                j++;</p>
<p>​                swap(a,j,i);</p>
<p>​            }</p>
<p>​        }</p>
<p>​        swap(a,j+1,r);</p>
<p>​        return j+1;<br>​    }</p>
<p>​    public void swap(int[] a, int i, int j) {   </p>
<p>​        int t = a[i];   </p>
<p>​        a[i] = a[j];   </p>
<p>​        a[j] = t;   </p>
<p>​    }</p>
<p>}</p>
<p>//二分查找类：适配者</p>
<p>class BinarySearch {</p>
<p>​    public int binarySearch(int array[],int key) {</p>
<p>​        int low = 0;</p>
<p>​        int high = array.length -1;</p>
<p>​        while(low &lt;= high) {</p>
<p>​            int mid = (low + high) / 2;</p>
<p>​            int midVal = array[mid];</p>
<p>​            if(midVal &lt; key) {  </p>
<p>low = mid +1;  </p>
<p>}</p>
<p>​            else if (midVal &gt; key) {  </p>
<p>high = mid -1;  </p>
<p>}</p>
<p>​            else {  </p>
<p>return 1; //找到元素返回1  </p>
<p>}</p>
<p>​        }</p>
<p>​        return -1;  //未找到元素返回-1</p>
<p>​    }</p>
<p>}</p>
<p>//操作适配器：适配器</p>
<p>class OperationAdapter implements ScoreOperation {</p>
<p>​    private QuickSort sortObj; //定义适配者QuickSort对象</p>
<p>​    private BinarySearch searchObj; //定义适配者BinarySearch对象</p>
<p>​    public OperationAdapter() {</p>
<p>​        sortObj = new QuickSort();</p>
<p>​        searchObj = new BinarySearch();</p>
<p>​    }</p>
<p>​    public int[] sort(int array[]) {  </p>
<p>return sortObj.quickSort(array); //调用适配者类QuickSort的排序方法</p>
<p>}</p>
<p>​    public int search(int array[],int key) {  </p>
<p>return searchObj.binarySearch(array,key); //调用适配者类BinarySearch的查找方法</p>
<p>}</p>
<p>}</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>，****类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系****，类适配器模式结构如图9-5所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.1.2.jpg" alt="2.1.2"></p>
<p>图 9-5 类适配器模式结构图</p>
<p>   根据类适配器模式结构图，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，实现了适配。</p>
<p>   典型的类适配器代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Adapter extends Adaptee implements Target &#123;</span><br><span class="line">	public void request() &#123;</span><br><span class="line">		specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Java、C#等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器；此外，如果适配者Adaptee为最终(Final)类，也无法使用类适配器。在Java等面向对象编程语言中，大部分情况下我们使用的是对象适配器，类适配器较少使用。</p>
<h4 id="缺省适配器"><a href="#缺省适配器" class="headerlink" title="缺省适配器"></a>缺省适配器</h4><p>  缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。缺省适配器模式的定义如下：<br><strong>缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</strong></p>
<p>   缺省适配器模式结构如图9-7所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.7.jpg" alt="1.3.7"></p>
<p>● ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。</p>
<p>  ● AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。</p>
<p>  ● ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。</p>
<h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><p>​      适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p>
<ol>
<li>主要优点</li>
</ol>
<p>   无论是对象适配器模式还是类适配器模式都具有如下优点：</p>
<p>   (1) <strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p>
<p>   (2) <strong>增加了类的透明性和复用性</strong>，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p>
<p>   (3) <strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p>
<p>  具体来说，类适配器模式还有如下优点：</p>
<p>  由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p>
<p>  对象适配器模式还有如下优点：</p>
<p>  (1) <strong>一个对象适配器可以把多个不同的适配者适配到同一个目标</strong>；</p>
<p>  (2) <strong>可以适配一个适配者的子类</strong>，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</p>
<p>2.主要缺点</p>
<p> 类适配器模式的缺点如下：</p>
<p>  (1) 对于Java、C#等不支持多重类继承的语言，<strong>一次最多只能适配一个适配者类，不能同时适配多个适配者；</strong></p>
<p>  (2) 适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</p>
<p>  (3) 在Java、C#等语言中，<strong>类适配器模式中的目标抽象类只能为接口</strong>，不能为类，其使用有一定的局限性。</p>
<p>  对象适配器模式的缺点如下：</p>
<p>  与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<p>3.适用场景</p>
<p>  在以下情况下可以考虑使用适配器模式：</p>
<p>   (1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p>
<p>   (2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>
<h3 id="2、桥接模式"><a href="#2、桥接模式" class="headerlink" title="2、桥接模式"></a>2、桥接模式</h3><p> Bridge Pattern</p>
<p>​    <strong>抽象类</strong>定义<strong>实现类接口</strong>，<strong>具体实现类</strong>实现<strong>实现类接口</strong>的方法</p>
<p>​    <strong>扩充抽象类</strong>继承<strong>抽象类</strong>，实现抽象类的方法</p>
<p>​    毛笔和蜡笔。假如我们需要大中小3种型号的画笔，能够绘制12种不同的颜色，如果使用蜡笔，需要准备3×12 = 36支，但如果使用毛笔的话，只需要提供3种型号的毛笔，外加12个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与36支蜡笔同样的功能。</p>
<p>​    桥接模式是一种很实用的结构型设计模式，如果软件系统中<strong>某个类存在两个独立变化的维度</strong>，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。</p>
<p>*<em>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体*</em>(Handle and Body)模式或接口(Interface)*<em>模式。</em>*</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.jpg" alt="2.2"></p>
<p>●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</p>
<p>●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</p>
<p>●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</p>
<p>●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</p>
<p>​    桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。</p>
<p><strong>型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分</strong>，结构示意图如图10-4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.1.jpg" alt="2.2.1"></p>
<h4 id="跨平台图像浏览系统"><a href="#跨平台图像浏览系统" class="headerlink" title="跨平台图像浏览系统"></a>跨平台图像浏览系统</h4><p>跨平台图像浏览系统的桥接模式解决方案</p>
<p> 为了减少所需生成的子类数目，实现将操作系统和图像文件格式两个维度分离，使它们可以独立改变，Sunny公司开发人员使用桥接模式来重构跨平台图像浏览系统的设计，其基本结构如图10-5所示：</p>
<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.2.jpg" alt="2.2.2" style="zoom:150%;" />

<p>​     在图10-5中，Image充当抽象类，其子类JPGImage、PNGImage、BMPImage和GIFImage充当扩充抽象类；ImageImp充当实现类接口，其子类WindowsImp、LinuxImp和UnixImp充当具体实现类。</p>
<p>​    若需要更换图像文件格式或者更换操作系统，只需修改配置文件即可，在实际使用时，<strong>可以通过分析图像文件格式后缀名来确定具体的文件格式，在程序运行时获取操作系统信息来确定操作系统类型</strong>，无须使用配置文件。<strong>系统具有较好的可扩展性，完全符合“开闭原则”。</strong></p>
<h4 id="适配器与桥接的联用"><a href="#适配器与桥接的联用" class="headerlink" title="适配器与桥接的联用"></a>适配器与桥接的联用</h4><p>​        适配器模式可以解决两个已有接口间不兼容问题，在这种情况下被适配的类往往是一个黑盒子，有时候我们不想也不能改变这个被适配的类，也不能控制其扩展。。桥接模式则不同，用户可以通过接口继承或类继承的方式来对系统进行扩展。</p>
<p>​    <strong>桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色</strong>，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式。</strong></p>
<p>​        在设计过程中，由于存在报表显示和数据采集两个独立变化的维度，因此可以使用桥接模式进行初步设计；为了使用Excel相关的API来进行数据采集则需要使用适配器模式。系统的完整设计中需要将两个模式联用，如图10-6所示</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.3.jpg" alt="2.2.3"></p>
<h4 id="桥接模式总结"><a href="#桥接模式总结" class="headerlink" title="桥接模式总结"></a>桥接模式总结</h4><p>​        桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛。<strong>在软件开发中如果一个类或一个系统有多个变化维度时</strong>，都可以尝试使用<strong>桥接模式</strong>对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。</p>
<p>1.主要优点</p>
<p>​    桥接模式的主要优点如下：</p>
<p>​    (1)<strong>分离抽象接口及其实现部分</strong>。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</p>
<p>​    (2)<strong>在很多情况下，桥接模式可以取代多层继承方案</strong>，<strong>多层继承方案违背了“单一职责原则”</strong>，<strong>复用性较差</strong>，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p>
<p>​    (3)<strong>桥接模式提高了系统的可扩展性</strong>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</p>
<p>2.主要缺点</p>
<p>​    桥接模式的主要缺点如下：</p>
<p>​    (1)<strong>桥接模式的使用会增加系统的理解与设计难度</strong>，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p>
<p>​    (2)<strong>桥接模式要求正确识别出系统中两个独立变化的维度</strong>，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</p>
<p>3.适用场景</p>
<p>​    在以下情况下可以考虑使用桥接模式：</p>
<p>​    (1)如果一个系统需要在<strong>抽象化和具体化之间增加更多的灵活性</strong>，<strong>避免在两个层次之间建立静态的继承关系</strong>，通过桥接模式可以使它们在抽象层建立一个关联关系。</p>
<p>​    (2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</p>
<p>​    (3)<strong>一个类存在两个（或多个）独立变化的维度</strong>，且这两个（或多个）维度都需要独立进行扩展。</p>
<p>​    (4)对于那些<strong>不希望使用继承或因为多层继承</strong>导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p>
<h3 id="3、装饰模式"><a href="#3、装饰模式" class="headerlink" title="3、装饰模式"></a>3、装饰模式</h3><p>​       装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p>
<p>  装饰模式定义如下：</p>
<p><strong>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</strong></p>
<p>  在装饰模式中，为了让系统具有更好的灵活性和可扩展性，我们通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类，装饰模式结构如图12-3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.jpg" alt="2.3"></p>
<p>● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，<strong>声明了在具体构件中实现的业务方法</strong>，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p>
<p>● Decorator（抽象装饰类）：它也是抽象构件类的子类，<strong>用于给具体构件增加职责</strong>，<strong>但是具体职责在其子类中实现</strong>。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，<strong>负责向构件添加新的职责</strong>。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p>
<h4 id="装饰模式案例"><a href="#装饰模式案例" class="headerlink" title="装饰模式案例"></a>装饰模式案例</h4><p> 如何提高图形界面构件库性的可扩展性并降低其维护成本是Sunny公司开发人员必须面对的一个问题。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.2.jpg" alt="2.3.2"></p>
<p>   为了让系统具有更好的灵活性和可扩展性，克服继承复用所带来的问题，Sunny公司开发人员使用装饰模式来重构图形界面构件库的设计，其中部分类的基本结构如图12-4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.1.jpg" alt="2.3.1"></p>
<p>图12-4 图形界面构件库结构图</p>
<pre><code>  在图12-4中，Component充当抽象构件类，其子类Window、TextBox、ListBox充当具体构件类，Component类的另一个子类ComponentDecorator充当抽象装饰类，ComponentDecorator的子类ScrollBarDecorator和BlackBorderDecorator充当具体装饰类。
</code></pre>
<h4 id="装饰模式注意事项"><a href="#装饰模式注意事项" class="headerlink" title="装饰模式注意事项"></a>装饰模式注意事项</h4><p>​      在使用装饰模式时，通常我们需要注意以下几个问题：</p>
<p>(1) 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。</p>
<p>(2) 尽量保持具体构件类ConcreteComponent是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。</p>
<p>(3) 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。如图12-6所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.3.jpg" alt="2.3.3"></p>
<p>图12-6 没有抽象构件类的装饰模式</p>
<h4 id="装饰模式总结"><a href="#装饰模式总结" class="headerlink" title="装饰模式总结"></a>装饰模式总结</h4><p>​      装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在JavaIO中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p>
<p>1.主要优点</p>
<p>  装饰模式的主要优点如下：</p>
<p>(1) 对于扩展一个对象的功能，<strong>装饰模式比继承更加灵活性</strong>，不会导致类的个数急剧增加。</p>
<p>(2) 可以通过一种<strong>动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</p>
<p>(3) <strong>可以对一个对象进行多次装饰</strong>，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到<strong>功能更为强大的对象</strong>。</p>
<p>(4) <strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，<strong>符合“开闭原则”。</strong></p>
<p>2.主要缺点</p>
<p>  装饰模式的主要缺点如下：</p>
<p>(1) 使用装饰模式进行系统设计时将<strong>产生很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，<strong>大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</strong></p>
<p>(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，<strong>排错也很困难</strong>，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</p>
<p>3.适用场景</p>
<p>  在以下情况下可以考虑使用装饰模式：</p>
<p>(1) 在<strong>不影响其他对象</strong>的情况下，以<strong>动态、透明的方式给单个对象添加职责。</strong></p>
<p>(2) 当不能采用继承的方式对系统进行扩展或者<strong>采用继承不利于系统扩展和维护时可以使用装饰模式</strong>。不能采用继承的情况主要有两类：第一类是<strong>系统中存在大量独立的扩展</strong>，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是<strong>因为类已定义为不能被继承</strong>（如Java语言中的final类）。</p>
<h3 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h3><p>  在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p>
<p>**<em>*代理模式：*<em>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</em></em></p>
<h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p>   代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层，代理模式结构如图15-2所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.4.jpg" alt="2.4"></p>
<p>图15-2 代理模式结构图</p>
<p>   由图15-2可知，代理模式包含如下三个角色：</p>
<p>   (1) Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</p>
<p>   (2) Proxy（代理主题角色）：代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。</p>
<p>   (3) RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理有以下特点:</p>
<p>1.代理对象,不需要实现接口</p>
<p>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</p>
<p>代理类不用再实现接口了。但是，要求被代理对象必须有接口。</p>
<p>Java.lang.reflect.Proxy类可以直接生成一个代理对象</p>
<p>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)生成一个代理对象</p>
<p>参数1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器</p>
<p>参数2:Class&lt;?&gt;[] interfaces 代理对象的要实现的接口 一般使用的被代理对象实现的接口</p>
<p>参数3:InvocationHandler h (接口)执行处理类</p>
<p>InvocationHandler中的invoke(Object proxy, Method method, Object[] args)方法：调用代理类的任何方法，此方法都会执行</p>
<p>参数3.1:代理对象(慎用)</p>
<p>参数3.2:当前执行的方法</p>
<p>参数3.3:当前执行的方法运行时传递过来的参数</p>
<p>在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p>
<p>   (1) <strong>远程代理</strong>(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。</p>
<p>   (2) <strong>虚拟代理</strong>(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
<p>   (3) <strong>保护代理</strong>(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
<p>   (4) <strong>缓冲代理</strong>(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</p>
<p>   (5) <strong>智能引用代理</strong>(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</p>
<h5 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h5><p> 远程代理(Remote Proxy)是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，<strong>远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。</strong>远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而<strong>远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。</strong></p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>​    **<em>*虚拟代理**(****Virtual Proxy)**</em>***也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</p>
<h5 id="缓冲代理"><a href="#缓冲代理" class="headerlink" title="缓冲代理"></a>缓冲代理</h5><p>​    **<em>*缓冲代理**(Cache Proxy)**</em>***也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。</p>
<p>15.7.1 模式优点<br>       代理模式的共同优点如下：</p>
<p>   (1) 能够协调调用者和被调用者，在一定程度上<strong>降低了系统的耦合度</strong>。</p>
<p>   (2) 客户端可以<strong>针对抽象主题角色进行编程，增加和更换代理类无须修改源代码</strong>，符合<strong>开闭原则</strong>，系统具有较好的<strong>灵活性和可扩展性。</strong></p>
<p>   此外，不同类型的代理模式也具有独特的优点，例如：</p>
<p>   (1) <strong>远程代理</strong>为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</p>
<p>   (2) 虚拟代理通过<strong>一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</strong></p>
<p>   (3) 缓冲代理为某一个操作的结果<strong>提供临时的缓存存储空间，</strong>以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</p>
<p>   (4) 保护代理可以<strong>控制对一个对象的访问权限</strong>，为不同用户提供不同级别的使用权限。</p>
<p>15.7.2 模式缺点<br>       代理模式的主要缺点如下：</p>
<p>   (1) 由于在客户端和真实主题之间增加了代理对象，<strong>因此有些类型的代理模式可能会造成请求的处理速度变慢</strong>，例如保护代理。</p>
<p>   (2) 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</p>
<p>15.7.3 模式适用场景<br>       代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：</p>
<p>   (1) 当客户端对象需要<strong>访问远程主机</strong>中的对象时可以使用远程代理。</p>
<p>   (2) 当需要<strong>用一个消耗资源较少的对象来代表一个消耗资源较多的对象</strong>，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</p>
<p>   (3) 当<strong>需要为某一个被频繁访问的操作结果提供一个临时存储空间</strong>，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</p>
<p>   (4) 当需要<strong>控制对一个对象的访</strong>问，为不同用户提供不同级别的访问权限时可以使用保护代理。</p>
<p>   (5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</p>
<h2 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h2><p><strong>类或对象之间如何交互、如何划分职责，从而更好地完成任务</strong></p>
<h4 id="1、迭代器模式"><a href="#1、迭代器模式" class="headerlink" title="1、迭代器模式"></a>1、迭代器模式</h4><p><strong>迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</strong></p>
<p>   在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.1.jpg" alt="3.1"></p>
<pre><code> ● Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。

   ● ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。

   ● Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。

   ● ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。
</code></pre>
<p><strong>使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现</strong>。**<em>*如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反“开闭原则”，因此在设计时要考虑全面，避免之后修改接口*<em>。</em></em></p>
<h5 id="迭代器案例"><a href="#迭代器案例" class="headerlink" title="迭代器案例"></a>迭代器案例</h5><p>  为了简化AbstractObjectList类的结构，并给不同的具体数据集合类提供不同的遍历方式，Sunny软件公司开发人员使用迭代器模式来重构AbstractObjectList类的设计，重构之后的销售管理系统数据遍历结构如图4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.1.2.jpg" alt="3.1.2"></p>
<p>，AbstractObjectList充当抽象聚合类，ProductList充当具体聚合类，AbstractIterator充当抽象迭代器，ProductIterator充当具体迭代器。</p>
<h5 id="迭代器模式总结"><a href="#迭代器模式总结" class="headerlink" title="迭代器模式总结"></a>迭代器模式总结</h5><p>​       迭代器模式是一种使用频率非常高的设计模式，<strong>通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来</strong>，<strong>聚合对象只负责存储数据，而遍历数据由迭代器来完成。</strong>由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。</p>
<p>1.主要优点</p>
<p>   迭代器模式的主要优点如下：</p>
<p>   (1) 它<strong>支持以不同的方式遍历一个聚合对</strong>象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</p>
<p>   (2) <strong>迭代器简化了聚合类</strong>。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</p>
<p>   (3) 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，<strong>满足“开闭原则”的要求。</strong></p>
<p>2.主要缺点</p>
<p>   迭代器模式的主要缺点如下：</p>
<p>   (1) 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上<strong>增加了系统的复杂性。</strong></p>
<p>   (2) 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</p>
<p>3.适用场景</p>
<p>   在以下情况下可以考虑使用迭代器模式：</p>
<p>   (1) 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</p>
<p>   (2) 需要为一个聚合对象提供多种遍历方式。</p>
<p>   (3) 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</p>
<h4 id="2、策略模式"><a href="#2、策略模式" class="headerlink" title="2、策略模式"></a>2、策略模式</h4><p> 在软件开发中，我们也常常会遇到类似的情况，<strong>实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径</strong>。</p>
<h5 id="策略模式概述"><a href="#策略模式概述" class="headerlink" title="策略模式概述"></a>策略模式概述</h5><p>  策略模式的主要目的是<strong>将算法的定义与使用分开</strong>，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。策略模式定义如下：</p>
<p><em><strong>*策略模式**(Strategy Pattern)**：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式**(Policy)**。策略模式是一种对象行为型模式。*</strong></em></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.2.1.jpg" alt="3.2.1"></p>
<p>  ● Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</p>
<p>  ● Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</p>
<p>  ● ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</p>
<h5 id="策略案例"><a href="#策略案例" class="headerlink" title="策略案例"></a>策略案例</h5><p> 为了实现打折算法的复用，并能够灵活地向系统中增加新的打折方式，Sunny软件公司开发人员使用策略模式对电影院打折方案进行重构，重构后基本结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.2.2.jpg" alt="3.2.2"></p>
<p>MovieTicket充当环境类角色，Discount充当抽象策略角色，StudentDiscount、 ChildrenDiscount 和VIPDiscount充当具体策略角色。</p>
<h5 id="策略模式总结"><a href="#策略模式总结" class="headerlink" title="策略模式总结"></a>策略模式总结</h5><p>​      策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式。</p>
<p>1.主要优点</p>
<p>  策略模式的主要优点如下：</p>
<p>  (1) 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p>
<p>  (2) 策略模式提供了管理相关的算法族的办法。<strong>策略类的等级结构定义了一个算法或行为族</strong>，<strong>恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</strong></p>
<p>  (3) 策略模式提供了一种可以<strong>替换继承关系</strong>的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</p>
<p>  (4) 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</p>
<p>  (5) 策略模式提供了一种<strong>算法的复用机制</strong>，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p>
<p>3.主要缺点</p>
<p>  策略模式的主要缺点如下：</p>
<p>  (1) 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，<strong>策略模式只适用于客户端知道所有的算法或行为的情况。</strong></p>
<p>  (2) 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p>
<p>  (3) <strong>无法同时在客户端使用多个策略类</strong>，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</p>
<p>3.适用场景</p>
<p>  在以下情况下可以考虑使用策略模式：</p>
<p>  (1) 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</p>
<p>  (2) 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</p>
<p>  (3) 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</p>
<h4 id="3、责任链模式"><a href="#3、责任链模式" class="headerlink" title="3、责任链模式"></a>3、责任链模式</h4><p><em><strong>*职责链模式**(Chain of Responsibility Pattern)**：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。*</strong></em></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.3.1.jpg" alt="3.3.1"></p>
<p>● Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。</p>
<p>  ● <strong>ConcreteHandler（具体处理者）</strong>：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p>
<p>  在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在<strong>不影响客户端的情况下动态地重新组织链和分配责任。</strong></p>
<p> 具体处理者是抽象处理者的子类，它具有两大作用：<strong>第一是处理请求</strong>，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；<strong>第二是转发请求</strong>，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</p>
<p>****职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链****。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 </p>
<p> 为了让采购单的审批流程更加灵活，并实现采购单的链式传递和处理，Sunny公司开发人员使用职责链模式来实现采购单的分级审批，其基本结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.3.2.jpg" alt="3.3.2"></p>
<p> 抽象类Approver充当抽象处理者（抽象传递者），Director、VicePresident、President和Congress充当具体处理者（具体传递者），PurchaseRequest充当请求类。</p>
<h5 id="纯与不纯的职责链模式"><a href="#纯与不纯的职责链模式" class="headerlink" title="纯与不纯的职责链模式"></a>纯与不纯的职责链模式</h5><p>   职责链模式可分为纯的职责链模式和不纯的职责链模式两种</p>
<p> (1)纯的职责链模式</p>
<p> 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：<strong>要么承担全部责任，要么将责任推给下家</strong>，要求一个请求必须被某一个处理者对象所接收</p>
<p> (2)不纯的职责链模式</p>
<p>   在一个不纯的职责链模式中****允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收****。</p>
<h5 id="职责链模式总结"><a href="#职责链模式总结" class="headerlink" title="职责链模式总结"></a>职责链模式总结</h5><p>​      职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。</p>
<p>在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用职责链模式可以较好地解决此类问题。</p>
<p>   1.主要优点</p>
<p>  职责链模式的主要优点如下：</p>
<p>   (1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，<strong>降低了系统的耦合度</strong>。</p>
<p>   (2) 请求处理对象<strong>仅需维持一个指向其后继者的引用</strong>，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</p>
<p>   (3) 在给<strong>对象分派职责时，职责链可以给我们更多的灵活性</strong>，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</p>
<p>   (4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是<strong>符合“开闭原则”的。</strong></p>
<p>​      </p>
<p>   2.主要缺点</p>
<p>  职责链模式的主要缺点如下：</p>
<p>   (1) 由于一个请求<strong>没有明确的接收者</strong>，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；<strong>一个请求也可能因职责链没有被正确配置而得不到处理</strong>。</p>
<p>   (2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，<strong>系统性能将受到一定影响</strong>，而且在进行代码调试时不太方便。</p>
<p>   (3) <strong>如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</strong></p>
<p>   3.适用场景</p>
<p>  在以下情况下可以考虑使用职责链模式：</p>
<p>   (1) 有<strong>多个对象可以处理同一个请求</strong>，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</p>
<p>   (2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p>
<p>​    (3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </p>
<h4 id="4、观察者模式"><a href="#4、观察者模式" class="headerlink" title="4、观察者模式"></a>4、观察者模式</h4><p>观察者模式是使用频率最高的设计模式之一，它用于<strong>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。</strong>在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<p><strong>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</strong></p>
<p> 观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.1.jpg" alt="4.1"></p>
<p>● Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中<strong>定义了一个观察者集合</strong>，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p>
<p>  ● ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p>
<p>  ● Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</p>
<p>  ● ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</p>
<p>  观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。</p>
<h5 id="观察者方案"><a href="#观察者方案" class="headerlink" title="观察者方案"></a>观察者方案</h5><p>   为了实现对象之间的联动，Sunny软件公司开发人员决定使用观察者模式来进行多人联机对战游戏的设计，其基本结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.4.2.jpg" alt="4.4.2"></p>
<p>AllyControlCenter充当目标类，ConcreteAllyControlCenter充当具体目标类，Observer充当抽象观察者，Player充当具体观察者。</p>
<h5 id="观察者模式与MVC"><a href="#观察者模式与MVC" class="headerlink" title="观察者模式与MVC"></a>观察者模式与MVC</h5><p>​      在当前流行的MVC(Model-View-Controller)架构中也应用了观察者模式，MVC是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。其中<strong>模型可对应于观察者模式中的观察目标</strong>，而<strong>视图对应于观察者</strong>，<strong>控制器可充当两者之间的中介者</strong>。当模型层的数据发生改变时，视图层将自动改变其显示内容。如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.4.3.jpg" alt="4.4.3"></p>
<p>​                                        MVC结构示意图</p>
<pre><code>     模型层提供的数据是视图层所观察的对象，在视图层中包含两个用于显示数据的图表对象，一个是柱状图，一个是饼状图，相同的数据拥有不同的图表显示方式，如果模型层的数据发生改变，两个图表对象将随之发生变化，这意味着图表对象依赖模型层提供的数据对象，因此数据对象的任何状态改变都应立即通知它们。同时，这两个图表之间相互独立，不存在任何联系，而且图表对象的个数没有任何限制，用户可以根据需要再增加新的图表对象，如折线图。在增加新的图表对象时，无须修改原有类库，满足“开闭原则”。
</code></pre>
<h5 id="观察者模式总结"><a href="#观察者模式总结" class="headerlink" title="观察者模式总结"></a>观察者模式总结</h5><p>​      观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p>
<p>  1.主要优点</p>
<p>  观察者模式的主要优点如下：</p>
<p>  (1) 观察者模式可以<strong>实现表示层和数据逻辑层的分离</strong>，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</p>
<p>  (2) 观察者模式在<strong>观察目标和观察者</strong>之间<strong>建立一个抽象的耦合</strong>。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</p>
<p>  (3) 观察者模式<strong>支持广播通信</strong>，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</p>
<p>  (4) 观察者模式<strong>满足“开闭原则”的要求</strong>，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</p>
<p>  2.主要缺点</p>
<p>  观察者模式的主要缺点如下：</p>
<p>  (1) 如果<strong>一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</strong></p>
<p>  (2) 如果在<strong>观察者和观察目标之间存在循环依赖</strong>，<strong>观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</strong></p>
<p>  (3) <strong>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</strong></p>
<p>  3.适用场景</p>
<p>  在以下情况下可以考虑使用观察者模式：</p>
<p>  (1) 一个抽象模型有两个方面，<strong>其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</strong></p>
<p>  (2) 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</p>
<p>  (3**) 需要在系统中创建一个触发链**，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/VUE%E8%AF%A6%E7%BB%86%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/20/VUE%E8%AF%A6%E7%BB%86%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">VUE详细基础语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-20 21:18:12" itemprop="dateCreated datePublished" datetime="2021-11-20T21:18:12+08:00">2021-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 19:56:52" itemprop="dateModified" datetime="2022-09-23T19:56:52+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/VUE/" itemprop="url" rel="index"><span itemprop="name">VUE</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="VUE详细基础语法"><a href="#VUE详细基础语法" class="headerlink" title="VUE详细基础语法"></a>VUE详细基础语法</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/11/20/VUE%E8%AF%A6%E7%BB%86%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/20/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/20/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">vue入门学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-20 21:18:12" itemprop="dateCreated datePublished" datetime="2021-11-20T21:18:12+08:00">2021-11-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 19:56:53" itemprop="dateModified" datetime="2022-09-23T19:56:53+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/VUE/" itemprop="url" rel="index"><span itemprop="name">VUE</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><input disabled="" type="checkbox"> <h1 id="vue入门学习"><a href="#vue入门学习" class="headerlink" title="vue入门学习"></a>vue入门学习</h1></li>
</ul>
<h2 id="1-MVVM-框架"><a href="#1-MVVM-框架" class="headerlink" title="1.MVVM 框架"></a>1.MVVM 框架</h2><ul>
<li><p>M:model</p>
<p>数据层（存储数据及对数据的处理如增删改查）</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/11/20/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/12/vue2%E4%B8%8Evue3%E5%85%B1%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/12/vue2%E4%B8%8Evue3%E5%85%B1%E5%AD%98/" class="post-title-link" itemprop="url">vue2与vue3共存</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-12 09:22:04" itemprop="dateCreated datePublished" datetime="2021-08-12T09:22:04+08:00">2021-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 20:02:28" itemprop="dateModified" datetime="2022-09-23T20:02:28+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/VUE/" itemprop="url" rel="index"><span itemprop="name">VUE</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、安装vue-cli脚手架"><a href="#一、安装vue-cli脚手架" class="headerlink" title="一、安装vue-cli脚手架"></a>一、安装vue-cli脚手架</h2>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/12/vue2%E4%B8%8Evue3%E5%85%B1%E5%AD%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/12/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/springcloud/" class="post-title-link" itemprop="url">springcloud微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-12 09:21:04" itemprop="dateCreated datePublished" datetime="2021-07-12T09:21:04+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 20:25:17" itemprop="dateModified" datetime="2022-09-23T20:25:17+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/12/springcloud/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/12/spring5%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/12/spring5%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Spring5基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-12 09:21:04" itemprop="dateCreated datePublished" datetime="2021-07-12T09:21:04+08:00">2021-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 19:56:55" itemprop="dateModified" datetime="2022-09-23T19:56:55+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="spring5基础"><a href="#spring5基础" class="headerlink" title="spring5基础"></a>spring5基础</h1><h2 id="Spring——IOC（控制反转）"><a href="#Spring——IOC（控制反转）" class="headerlink" title="Spring——IOC（控制反转）"></a>Spring——IOC（控制反转）</h2><h3 id="一、IOC容器"><a href="#一、IOC容器" class="headerlink" title="一、IOC容器"></a>一、IOC容器</h3><h3 id="1、什么是IOC（控制反转）"><a href="#1、什么是IOC（控制反转）" class="headerlink" title="1、什么是IOC（控制反转）"></a>1、什么是IOC（控制反转）</h3><p> a）把对象创建和对象之间的调用过程，交给Spring进行管理</p>
<p> b）使用IOC目的：为了降低耦合度<br>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/12/spring5%E5%9F%BA%E7%A1%80/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">数据库知识点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-12 11:20:20" itemprop="dateCreated datePublished" datetime="2021-06-12T11:20:20+08:00">2021-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 19:56:59" itemprop="dateModified" datetime="2022-09-23T19:56:59+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>事务的四大特性？</li>
<li>数据库的三大范式</li>
<li>事务隔离级别有哪些？</li>
<li>索引
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/12/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/12/Mybatis/" class="post-title-link" itemprop="url">MyBatis框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-12 10:13:32" itemprop="dateCreated datePublished" datetime="2021-06-12T10:13:32+08:00">2021-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 19:56:57" itemprop="dateModified" datetime="2022-09-23T19:56:57+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>53k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>48 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul>
<li>   MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li>
<li>   iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/12/Mybatis/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/12/java8learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/mypic.jpg">
      <meta itemprop="name" content="LAYCHOU">
      <meta itemprop="description" content="zyc study blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LAYCHOUblog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/12/java8learn/" class="post-title-link" itemprop="url">Java8概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-12 16:10:13" itemprop="dateCreated datePublished" datetime="2021-05-12T16:10:13+08:00">2021-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 19:56:59" itemprop="dateModified" datetime="2022-09-23T19:56:59+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JAVA8学习"><a href="#JAVA8学习" class="headerlink" title="JAVA8学习"></a>JAVA8学习</h1><h2 id="01、Java8概述"><a href="#01、Java8概述" class="headerlink" title="01、Java8概述"></a>01、Java8概述</h2><p>Java 8 (又称为jdk 1.8) 是Java 语言开发的一个主要版本。<br>Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/12/java8learn/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">




<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LAYCHOU</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">216k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:16</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





  <!-- ҳ����С���� -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
