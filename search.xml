<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
]]></content>
  </entry>
  <entry>
    <title>Post5</title>
    <url>/2022/06/12/Post5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/06/12/spring5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="spring5基础"><a href="#spring5基础" class="headerlink" title="spring5基础"></a>spring5基础</h1><h2 id="Spring——IOC（控制反转）"><a href="#Spring——IOC（控制反转）" class="headerlink" title="Spring——IOC（控制反转）"></a>Spring——IOC（控制反转）</h2><h3 id="一、IOC容器"><a href="#一、IOC容器" class="headerlink" title="一、IOC容器"></a>一、IOC容器</h3><h3 id="1、什么是IOC（控制反转）"><a href="#1、什么是IOC（控制反转）" class="headerlink" title="1、什么是IOC（控制反转）"></a>1、什么是IOC（控制反转）</h3><p> a）把对象创建和对象之间的调用过程，交给Spring进行管理</p>
<p> b）使用IOC目的：为了降低耦合度</p>
<h3 id="2、IOC底层"><a href="#2、IOC底层" class="headerlink" title="2、IOC底层"></a>2、IOC底层</h3><p> a）xml解析、工厂模式、反射</p>
<p> 3、Spring提供的IOC容器实现的两种方式（两个接口）</p>
<p> a）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。）</p>
<p> b）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！</p>
<p> 4、ApplicationContext接口的实现类（具体根据API文档查看☺）</p>
<h3 id="二、IOC容器-Bean管理"><a href="#二、IOC容器-Bean管理" class="headerlink" title="二、IOC容器-Bean管理"></a>二、IOC容器-Bean管理</h3><h3 id="1、IOC操作Bean管理"><a href="#1、IOC操作Bean管理" class="headerlink" title="1、IOC操作Bean管理"></a>1、IOC操作Bean管理</h3><p> a）Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性</p>
<h3 id="2、基于XML配置文件创建对象"><a href="#2、基于XML配置文件创建对象" class="headerlink" title="2、基于XML配置文件创建对象"></a>2、基于XML配置文件创建对象</h3><!--1 配置User对象创建-->

<p><bean id="user" class="com.atguigu.spring5.User"></bean></p>
<h3 id="3、基于XML方式注入属性（DI：依赖注入（注入属性））"><a href="#3、基于XML方式注入属性（DI：依赖注入（注入属性））" class="headerlink" title="3、基于XML方式注入属性（DI：依赖注入（注入属性））"></a>3、基于XML方式注入属性（DI：依赖注入（注入属性））</h3><h5 id="a）set方式注入"><a href="#a）set方式注入" class="headerlink" title="a）set方式注入"></a>a）set方式注入</h5><p>//（1）传统方式： 创建类，定义属性和对应的set方法<br>public class Book {<br>        //创建属性<br>        private String bname;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建属性对应的set方法</span><br><span class="line">public void setBname(String bname) &#123;</span><br><span class="line">    this.bname = bname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   }</p>
<!--（2）spring方式： set方法注入属性-->

<bean id="book" class="com.atguigu.spring5.Book">
    <!--使用property完成属性注入
        name：类里面属性名称
        value：向属性注入的值
    -->
    <property name="bname" value="Hello"></property>
    <property name="bauthor" value="World"></property>
</bean>

<h5 id="b）有参构造函数注入"><a href="#b）有参构造函数注入" class="headerlink" title="b）有参构造函数注入"></a>b）有参构造函数注入</h5><p>//（1）传统方式：创建类，构建有参函数<br>public class Orders {<br>    //属性<br>    private String oname;<br>    private String address;<br>    //有参数构造<br>    public Orders(String oname,String address) {<br>        this.oname = oname;<br>        this.address = address;<br>    }<br>  }</p>
<!--（2）spring方式：有参数构造注入属性-->

<bean id="orders" class="com.atguigu.spring5.Orders">
    <constructor-arg name="oname" value="Hello"></constructor-arg>
    <constructor-arg name="address" value="China！"></constructor-arg>
</bean>

<h5 id="c）p名称空间注入（了解即可）"><a href="#c）p名称空间注入（了解即可）" class="headerlink" title="c）p名称空间注入（了解即可）"></a>c）p名称空间注入（了解即可）</h5><!--1、添加p名称空间在配置文件头部-->

<?xml version="1.0" encoding="UTF-8"?>

<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a><br>       xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>       xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a>        <!--在这里添加一行p--></p>
<!--2、在bean标签进行属性注入（算是set方式注入的简化操作）-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;very&quot; p:bauthor=&quot;good&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4、注入空值和特殊符号"><a href="#4、注入空值和特殊符号" class="headerlink" title="4、注入空值和特殊符号"></a>4、注入空值和特殊符号</h4><bean id="book" class="com.atguigu.spring5.Book">
    <!--（1）null值-->
    <property name="address">
        <null/><!--属性里边添加一个null标签-->
    </property>
    

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--（2）特殊符号赋值--&gt;</span><br><span class="line"> &lt;!--属性值包含特殊符号</span><br><span class="line">   a 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span><br><span class="line">   b 把带特殊符号内容写到CDATA</span><br><span class="line">  --&gt;</span><br><span class="line">    &lt;property name=&quot;address&quot;&gt;</span><br><span class="line">        &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure>

</bean>

<h4 id="5、注入属性-外部bean"><a href="#5、注入属性-外部bean" class="headerlink" title="5、注入属性-外部bean"></a>5、注入属性-外部bean</h4><p> a）创建两个类service和dao类</p>
<p>public class UserService {//service类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建UserDao类型属性，生成set方法</span><br><span class="line">private UserDao userDao;</span><br><span class="line">public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">    this.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">    System.out.println(&quot;service add...............&quot;);</span><br><span class="line">    userDao.update();//调用dao方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>public class UserDaoImpl implements UserDao {//dao类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line">    System.out.println(&quot;dao update...........&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p> b）在spring配置文件中进行配置</p>
<!--1 service和dao对象创建-->

<bean id="userService" class="com.atguigu.spring5.service.UserService">
    <!--注入userDao对象
        name属性：类里面属性名称
        ref属性：创建userDao对象bean标签id值
    -->
    <property name="userDao" ref="userDaoImpl"></property>
</bean>
<bean id="userDaoImpl" class="com.atguigu.spring5.dao.UserDaoImpl"></bean>

<h4 id="6、基于XML方式注入内部bean和级联赋值"><a href="#6、基于XML方式注入内部bean和级联赋值" class="headerlink" title="6、基于XML方式注入内部bean和级联赋值"></a>6、基于XML方式注入内部bean和级联赋值</h4><p> a）注入属性-内部bean</p>
<p>（1）一对多关系：部门和员工<br>一个部门有多个员工，一个员工属于一个部门（部门是一，员工是多）<br>（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</p>
<p>//部门类<br>public class Dept {<br>    private String dname;<br>    public void setDname(String dname) {<br>        this.dname = dname;<br>    }<br>}</p>
<p>//员工类<br>public class Emp {<br>    private String ename;<br>    private String gender;<br>    //员工属于某一个部门，使用对象形式表示<br>    private Dept dept;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setDept(Dept dept) &#123;</span><br><span class="line">    this.dept = dept;</span><br><span class="line">&#125;</span><br><span class="line">public void setEname(String ename) &#123;</span><br><span class="line">    this.ename = ename;</span><br><span class="line">&#125;</span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>（3）在spring配置文件中配置</p>
<!--内部bean-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=&quot;ename&quot; value=&quot;Andy&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置对象类型属性--&gt;</span><br><span class="line">    &lt;property name=&quot;dept&quot;&gt;</span><br><span class="line">        &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;&lt;!--内部bean赋值--&gt;</span><br><span class="line">            &lt;property name=&quot;dname&quot; value=&quot;宣传部门&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p> b）注入属性-级联赋值</p>
<!--方式一：级联赋值-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=&quot;ename&quot; value=&quot;Andy&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dname&quot; value=&quot;公关部门&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p> //方式二：生成dept的get方法（get方法必须有！！）<br>    public Dept getDept() {<br>        return dept;<br>    }</p>
 <!--级联赋值-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=&quot;ename&quot; value=&quot;jams&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;dept.dname&quot; value=&quot;技术部门&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="7、IOC-操作-Bean-管理——xml-注入集合属性"><a href="#7、IOC-操作-Bean-管理——xml-注入集合属性" class="headerlink" title="7、IOC 操作 Bean 管理——xml 注入集合属性"></a>7、IOC 操作 Bean 管理——xml 注入集合属性</h4><p>1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性</p>
<p>//（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法<br>public class Stu {<br>    //1 数组类型属性<br>    private String[] courses;<br>    //2 list集合类型属性<br>    private List<String> list;<br>    //3 map集合类型属性<br>    private Map&lt;String,String&gt; maps;<br>    //4 set集合类型属性<br>    private Set<String> sets;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setSets(Set&lt;String&gt; sets) &#123;</span><br><span class="line">    this.sets = sets;</span><br><span class="line">&#125;</span><br><span class="line">public void setCourses(String[] courses) &#123;</span><br><span class="line">    this.courses = courses;</span><br><span class="line">&#125;</span><br><span class="line">public void setList(List&lt;String&gt; list) &#123;</span><br><span class="line">    this.list = list;</span><br><span class="line">&#125;</span><br><span class="line">public void setMaps(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">    this.maps = maps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--（2）在 spring 配置文件进行配置-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt;</span><br><span class="line">    &lt;!--数组类型属性注入--&gt;</span><br><span class="line">    &lt;property name=&quot;courses&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;java课程&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;数据库课程&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--list类型属性注入--&gt;</span><br><span class="line">    &lt;property name=&quot;list&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;小三&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--map类型属性注入--&gt;</span><br><span class="line">    &lt;property name=&quot;maps&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br></pre></td></tr></table></figure>

<p>​        </property><br>​        <!--set类型属性注入--><br>​        <property name="sets"><br>​            <set><br>​                <value>MySQL</value><br>​                <value>Redis</value><br>​            </set><br>​        </property><br></bean></p>
<h4 id="8、在集合里面设置对象类型值"><a href="#8、在集合里面设置对象类型值" class="headerlink" title="8、在集合里面设置对象类型值"></a>8、在集合里面设置对象类型值</h4><p>  //学生所学多门课程<br>    private List<Course> courseList;//创建集合<br>    public void setCourseList(List<Course> courseList) {<br>        this.courseList = courseList;<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--创建多个course对象--&gt;</span><br><span class="line">&lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注入list集合类型，值是对象--&gt;</span><br><span class="line">   &lt;property name=&quot;courseList&quot;&gt;</span><br><span class="line">       &lt;list&gt;</span><br><span class="line">           &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt;</span><br><span class="line">           &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt;</span><br><span class="line">       &lt;/list&gt;</span><br><span class="line">   &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<!--第一步：在 spring 配置文件中引入名称空间 util-->

<?xml version="1.0" encoding="UTF-8"?>

<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a><br>       xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>       xmlns:util=”<a href="http://www.springframework.org/schema/util&quot;">http://www.springframework.org/schema/util&quot;</a> <!--添加util名称空间--><br>    xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> </p>
<p><a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a><br>  <a href="http://www.springframework.org/schema/util">http://www.springframework.org/schema/util</a> <a href="http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;">http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</a>  <!--添加util名称空间--></p>
<!--第二步：使用 util 标签完成 list 集合注入提取-->

<!--把集合注入部分提取出来-->

 <!--1 提取list集合类型属性注入-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;util:list id=&quot;bookList&quot;&gt;</span><br><span class="line">    &lt;value&gt;易筋经&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;九阴真经&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;九阳神功&lt;/value&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure>

 <!--2 提取list集合类型属性注入使用-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-IOC容器-Bean管理——基于XML（续集）"><a href="#Spring-IOC容器-Bean管理——基于XML（续集）" class="headerlink" title="Spring IOC容器-Bean管理——基于XML（续集）"></a>Spring IOC容器-Bean管理——基于XML（续集）</h2><h3 id="1、IOC-操作-Bean-管理（FactoryBean）"><a href="#1、IOC-操作-Bean-管理（FactoryBean）" class="headerlink" title="1、IOC 操作 Bean 管理（FactoryBean）"></a>1、IOC 操作 Bean 管理（FactoryBean）</h3><p> 1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</p>
<p> 2、普通 bean：在配置文件中定义 bean 类型就是返回类型</p>
<p> 3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 </p>
<p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean </p>
<p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p>
<p>public class MyBean implements FactoryBean<Course> {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义返回bean</span><br><span class="line">@Override</span><br><span class="line">public Course getObject() throws Exception &#123;</span><br><span class="line">    Course course = new Course();</span><br><span class="line">    course.setCname(&quot;abc&quot;);</span><br><span class="line">    return course;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<bean id="myBean" class="com.atguigu.spring5.factorybean.MyBean">
</bean>

<p>@Test<br>public void test3() {<br> ApplicationContext context =<br> new ClassPathXmlApplicationContext(“bean3.xml”);<br> Course course = context.getBean(“myBean”, Course.class);//返回值类型可以不是定义的bean类型！<br> System.out.println(course);<br>}</p>
<h3 id="2、IOC-操作-Bean-管理（bean-作用域）"><a href="#2、IOC-操作-Bean-管理（bean-作用域）" class="headerlink" title="2、IOC 操作 Bean 管理（bean 作用域）"></a>2、IOC 操作 Bean 管理（bean 作用域）</h3><p> 在 Spring 里面，默认情况下，bean 是单实例对象，下面进行作用域设置：</p>
<p>（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p>
<p>（2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象</p>
<p><bean id="book" class="com.atguigu.spring5.collectiontype.Book" scope="prototype"><!--设置为多实例--><br>        <property name="list" ref="bookList"></property><br></bean></p>
<p>（3）singleton 和 prototype 区别</p>
<p> a）singleton 单实例，prototype 多实例</p>
<p> b）设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 ；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象</p>
<h3 id="3、IOC-操作-Bean-管理（bean-生命周期）"><a href="#3、IOC-操作-Bean-管理（bean-生命周期）" class="headerlink" title="3、IOC 操作 Bean 管理（bean 生命周期）"></a>3、IOC 操作 Bean 管理（bean 生命周期）</h3><p>1、生命周期 ：从对象创建到对象销毁的过程</p>
<p>2、bean 生命周期</p>
<p> （1）通过构造器创建 bean 实例（无参数构造）</p>
<p> （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p>
<p> （3）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p>
<p> （4）bean 可以使用了（对象获取到了）</p>
<p> （5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<p>3、演示 bean 生命周期 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Orders &#123;</span><br><span class="line"> //无参数构造</span><br><span class="line"> public Orders() &#123;</span><br><span class="line"> System.out.println(&quot;第一步 执行无参数构造创建 bean 实例&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> private String oname;</span><br><span class="line"> public void setOname(String oname) &#123;</span><br><span class="line"> this.oname = oname;</span><br><span class="line"> System.out.println(&quot;第二步 调用 set 方法设置属性值&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> //创建执行的初始化的方法</span><br><span class="line"> public void initMethod() &#123;</span><br><span class="line"> System.out.println(&quot;第三步 执行初始化的方法&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> //创建执行的销毁的方法</span><br><span class="line"> public void destroyMethod() &#123;</span><br><span class="line"> System.out.println(&quot;第五步 执行销毁的方法&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public class MyBeanPost implements BeanPostProcessor {//创建后置处理器实现类<br>    @Override<br>    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br>        System.out.println(“在初始化之前执行的方法”);<br>        return bean;<br>    }<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br>        System.out.println(“在初始化之后执行的方法”);<br>        return bean;<br>    }<br>}</p>
<!--配置文件的bean参数配置-->

<p><bean id="orders" class="com.atguigu.spring5.bean.Orders" init-method="initMethod" destroy-method="destroyMethod">    <!--配置初始化方法和销毁方法--><br>    <property name="oname" value="手机"></property><!--这里就是通过set方式（注入属性）赋值--><br></bean></p>
<!--配置后置处理器-->

<p><bean id="myBeanPost" class="com.atguigu.spring5.bean.MyBeanPost"></bean></p>
<p> @Test<br> public void testBean3() {<br>// ApplicationContext context =<br>// new ClassPathXmlApplicationContext(“bean4.xml”);<br> ClassPathXmlApplicationContext context =<br> new ClassPathXmlApplicationContext(“bean4.xml”);<br> Orders orders = context.getBean(“orders”, Orders.class);<br> System.out.println(“第四步 获取创建 bean 实例对象”);<br> System.out.println(orders);<br> //手动让 bean 实例销毁<br> context.close();<br> }</p>
<p>4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）</p>
<p> （1）通过构造器创建 bean 实例（无参数构造）</p>
<p> （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p>
<p> （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</p>
<p> （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p>
<p> （5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</p>
<p> （6）bean 可以使用了（对象获取到了）</p>
<p> （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<h3 id="4、IOC-操作-Bean-管理-外部属性文件"><a href="#4、IOC-操作-Bean-管理-外部属性文件" class="headerlink" title="4、IOC 操作 Bean 管理(外部属性文件)"></a>4、IOC 操作 Bean 管理(外部属性文件)</h3><p>方式一：直接配置数据库信息 ：（1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包</p>
<!--直接配置连接池-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/userDb&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>方式二：引入外部属性文件配置数据库连接池</p>
<p>（1）创建外部属性文件，properties 格式文件，写数据库信息（jdbc.properties）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">prop.url=jdbc:mysql://localhost:3306/userDb</span><br><span class="line">prop.userName=root</span><br><span class="line">prop.password=root</span><br></pre></td></tr></table></figure>

<p>（2）把外部 properties 属性文件引入到 spring 配置文件中 —— 引入 context 名称空间</p>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"><!--引入context名称空间--></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;!--引入外部属性文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

</beans>

<h2 id="IOC-操作-Bean-管理-基于注解方式"><a href="#IOC-操作-Bean-管理-基于注解方式" class="headerlink" title="IOC 操作 Bean 管理(基于注解方式)"></a>IOC 操作 Bean 管理(基于注解方式)</h2><h3 id="1、什么是注解"><a href="#1、什么是注解" class="headerlink" title="1、什么是注解"></a>1、什么是注解</h3><p> （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)</p>
<p> （2）使用注解，注解作用在类上面，方法上面，属性上面</p>
<p> （3）使用注解目的：简化 xml 配置</p>
<h3 id="2、Spring-针对-Bean-管理中创建对象提供注解"><a href="#2、Spring-针对-Bean-管理中创建对象提供注解" class="headerlink" title="2、Spring 针对 Bean 管理中创建对象提供注解"></a>2、Spring 针对 Bean 管理中创建对象提供注解</h3><p> 下面四个注解功能是一样的，都可以用来创建 bean 实例</p>
<p> （1）@Component</p>
<p> （2）@Service</p>
<p> （3）@Controller</p>
<p> （4）@Repository</p>
<h3 id="3、基于注解方式实现对象创建"><a href="#3、基于注解方式实现对象创建" class="headerlink" title="3、基于注解方式实现对象创建"></a>3、基于注解方式实现对象创建</h3><p> 第一步 引入依赖 （引入spring-aop jar包）</p>
<p> 第二步 开启组件扫描</p>
<!--开启组件扫描
 1 如果扫描多个包，多个包使用逗号隔开
 2 扫描包上层目录
-->

<p>&lt;context:component-scan base-package=”com.atguigu”&gt;</context:component-scan></p>
<p> 第三步 创建类，在类上面添加创建对象注解</p>
<p>//在注解里面 value 属性值可以省略不写，<br>//默认值是类名称，首字母小写<br>//UserService – userService<br>@Component(value = “userService”) //注解等同于XML配置文件：<bean id="userService" class=".."/><br>public class UserService {<br> public void add() {<br> System.out.println(“service add…….”);<br> }<br>}</p>
<h3 id="4、开启组件扫描细节配置"><a href="#4、开启组件扫描细节配置" class="headerlink" title="4、开启组件扫描细节配置"></a>4、开启组件扫描细节配置</h3><!--示例 1
 use-default-filters="false" 表示现在不使用默认 filter，自己配置 filter
 context:include-filter ，设置扫描哪些内容
-->

<p>&lt;context:component-scan base-package=”com.atguigu” use-defaultfilters=”false”&gt;<br> &lt;context:include-filter type=”annotation”</p>
<p>expression=”org.springframework.stereotype.Controller”/&gt;<!--代表只扫描Controller注解的类--><br></context:component-scan></p>
<!--示例 2
 下面配置扫描包所有内容
 context:exclude-filter： 设置哪些内容不进行扫描
-->

<p>&lt;context:component-scan base-package=”com.atguigu”&gt;<br> &lt;context:exclude-filter type=”annotation”</p>
<p>expression=”org.springframework.stereotype.Controller”/&gt;<!--表示Controller注解的类之外一切都进行扫描--><br></context:component-scan></p>
<h3 id="5、基于注解方式实现属性注入"><a href="#5、基于注解方式实现属性注入" class="headerlink" title="5、基于注解方式实现属性注入"></a>5、基于注解方式实现属性注入</h3><p> （1）@Autowired：根据属性类型进行自动装配</p>
<p> 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解</p>
<p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p>
<p>@Service<br>public class UserService {<br> //定义 dao 类型属性<br> //不需要添加 set 方法<br> //添加注入属性注解<br> @Autowired<br> private UserDao userDao;<br> public void add() {<br> System.out.println(“service add…….”);<br> userDao.add();<br> }<br>}</p>
<p>//Dao实现类<br>@Repository<br>//@Repository(value = “userDaoImpl1”)<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void add() {<br>        System.out.println(“dao add…..”);<br>    }<br>}</p>
<p> （2）@Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用</p>
<p>//定义 dao 类型属性<br>//不需要添加 set 方法<br>//添加注入属性注解<br>@Autowired //根据类型进行注入<br>//根据名称进行注入（目的在于区别同一接口下有多个实现类，根据类型就无法选择，从而出错！）<br>@Qualifier(value = “userDaoImpl1”)<br>private UserDao userDao;</p>
<p> （3）@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）</p>
<p>//@Resource //根据类型进行注入<br>@Resource(name = “userDaoImpl1”) //根据名称进行注入<br>private UserDao userDao;</p>
<p> （4）@Value：注入普通类型属性</p>
<p>@Value(value = “abc”)<br>private String name</p>
<h3 id="6、完全注解开发"><a href="#6、完全注解开发" class="headerlink" title="6、完全注解开发"></a>6、完全注解开发</h3><p> （1）创建配置类，替代 xml 配置文件</p>
<p>@Configuration //作为配置类，替代 xml 配置文件<br>@ComponentScan(basePackages = {“com.atguigu”})<br>public class SpringConfig {</p>
<p> （2）编写测试类</p>
<p>@Test<br>public void testService2() {<br> //加载配置类<br> ApplicationContext context<br> = new AnnotationConfigApplicationContext(SpringConfig.class);<br> UserService userService = context.getBean(“userService”,<br>UserService.class);<br> System.out.println(userService);<br> userService.add();<br>}</p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h2><h3 id="1、AOP-基本概念"><a href="#1、AOP-基本概念" class="headerlink" title="1、AOP 基本概念"></a>1、AOP 基本概念</h3><p> （1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p> （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</p>
<p> （3）使用登录例子说明 AOP</p>
<h3 id="2、AOP（底层原理）"><a href="#2、AOP（底层原理）" class="headerlink" title="2、AOP（底层原理）"></a>2、AOP（底层原理）</h3><p> a）AOP 底层使用动态代理 ，动态代理有两种情况：</p>
<p>第一种 有接口情况，使用 JDK 动态代理 ；创建接口实现类代理对象，增强类的方法</p>
<p>第二种 没有接口情况，使用 CGLIB 动态代理；创建子类的代理对象，增强类的方法</p>
<h3 id="3、AOP（JDK-动态代理）"><a href="#3、AOP（JDK-动态代理）" class="headerlink" title="3、AOP（JDK 动态代理）"></a>3、AOP（JDK 动态代理）</h3><p> 1）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p>
<p>调用 newProxyInstance 方法，方法有三个参数：</p>
<p>public static Object newProxyInstance(ClassLoader loader,<br>                                      Class&lt;?&gt;[] interfaces,<br>                                      InvocationHandler h)</p>
<p> 第一参数，类加载器</p>
<p> 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</p>
<p> 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
<p> 2）编写 JDK 动态代理代码</p>
<p>//（1）创建接口，定义方法<br>public interface UserDao {<br> public int add(int a,int b);<br> public String update(String id);<br>}</p>
<p>//（2）创建接口实现类，实现方法<br>public class UserDaoImpl implements UserDao {<br> @Override<br> public int add(int a, int b) {<br> return a+b;<br> }<br> @Override<br> public String update(String id) {<br> return id;<br> }<br>}</p>
<p>//（3）使用 Proxy 类创建接口代理对象<br>public class JDKProxy {<br> public static void main(String[] args) {<br> //创建接口实现类代理对象<br> Class[] interfaces = {UserDao.class};<br> UserDaoImpl userDao = new UserDaoImpl();<br>/** 第一参数，类加载器<br>    第二参数，增强方法所在的类，这个类实现的接口，(支持多个接口)<br>    第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分  */<br> UserDao dao =(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<br>                    new UserDaoProxy(userDao));<br> int result = dao.add(1, 2);<br> System.out.println(“result:”+result);<br> }<br>}</p>
<p>//创建代理对象代码<br>class UserDaoProxy implements InvocationHandler {<br> //1 把创建的是谁的代理对象，把谁传递过来<br> //有参数构造传递<br> private Object obj;<br> public UserDaoProxy(Object obj) {<br> this.obj = obj;<br> }<br> //增强的逻辑<br> @Override<br> public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br> //方法之前<br> System.out.println(“方法之前执行….”+method.getName()+” :传递的参数…”+ Arrays.toString(args));<br> //被增强的方法执行<br> Object res = method.invoke(obj, args);<br> //方法之后<br> System.out.println(“方法之后执行….”+obj);<br> return res;<br> }<br>}</p>
<h3 id="4、AOP（术语）"><a href="#4、AOP（术语）" class="headerlink" title="4、AOP（术语）"></a>4、AOP（术语）</h3><p> a）连接点：类里面哪些方法可以被增强，这些方法称为连接点</p>
<p> b）切入点：实际被真正增强的方法称为切入点</p>
<p> c）通知（增强）：实际增强的逻辑部分称为通知，且分为以下五种类型：</p>
<p> 1）前置通知 2）后置通知 3）环绕通知 4）异常通知 5）最终通知</p>
<p> d）切面：把通知应用到切入点过程</p>
<h3 id="5、AOP操作"><a href="#5、AOP操作" class="headerlink" title="5、AOP操作"></a>5、AOP操作</h3><p> a）Spring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作</p>
<p> b）基于 AspectJ 实现 AOP 操作：1）基于 xml 配置文件实现 （2）基于注解方式实现（使用）</p>
<p> c）引入相关jar包</p>
<p> d）切入点表达式，如下：</p>
<p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强<br>（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a> )<br>（3）例子如下：<br>    例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强<br>        execution(* com.atguigu.dao.BookDao.add(..))<br>     例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强<br>        execution(* com.atguigu.dao.BookDao.* (..))<br>    例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强<br>        execution(* com.atguigu.dao.<em>.</em> (..))</p>
<h3 id="6、AOP-操作（AspectJ-注解）"><a href="#6、AOP-操作（AspectJ-注解）" class="headerlink" title="6、AOP 操作（AspectJ 注解）"></a>6、AOP 操作（AspectJ 注解）</h3><p>//1、创建类，在类里面定义方法<br>public class User {<br> public void add() {<br> System.out.println(“add…….”);<br> }<br>}<br>//2、创建增强类（编写增强逻辑）<br>//（1）在增强类里面，创建方法，让不同方法代表不同通知类型<br>//增强的类<br>public class UserProxy {<br> public void before() {//前置通知<br> System.out.println(“before……”);<br> }<br>}</p>
<!--3、进行通知的配置-->

<?xml version="1.0" encoding="UTF-8"?>

<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"><br>    <!-- 开启注解扫描 --><br>    &lt;context:component-scan base-package=”com.atguigu.spring5.aopanno”&gt;</context:component-scan></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启Aspect生成代理对象--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure>

</beans>

<p>//增强的类<br>@Component<br>@Aspect  //生成代理对象<br>public class UserProxy {}</p>
<p>//被增强的类<br>@Component<br>public class User {}</p>
<p>//4、配置不同类型的通知<br>@Component<br>@Aspect  //生成代理对象<br>public class UserProxy {<br>      //相同切入点抽取<br>    @Pointcut(value = “execution(* com.atguigu.spring5.aopanno.User.add(..))”)<br>    public void pointdemo() {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//前置通知</span><br><span class="line">//@Before注解表示作为前置通知</span><br><span class="line">@Before(value = &quot;pointdemo()&quot;)//相同切入点抽取使用！</span><br><span class="line">public void before() &#123;</span><br><span class="line">    System.out.println(&quot;before.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置通知（返回通知）</span><br><span class="line">@AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void afterReturning() &#123;</span><br><span class="line">    System.out.println(&quot;afterReturning.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终通知</span><br><span class="line">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void after() &#123;</span><br><span class="line">    System.out.println(&quot;after.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异常通知</span><br><span class="line">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void afterThrowing() &#123;</span><br><span class="line">    System.out.println(&quot;afterThrowing.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//环绕通知</span><br><span class="line">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;环绕之前.........&quot;);</span><br><span class="line"></span><br><span class="line">    //被增强的方法执行</span><br><span class="line">    proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;环绕之后.........&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<h3 id="7、有多个增强类对同一个方法进行增强，设置增强类优先级"><a href="#7、有多个增强类对同一个方法进行增强，设置增强类优先级" class="headerlink" title="7、有多个增强类对同一个方法进行增强，设置增强类优先级"></a>7、有多个增强类对同一个方法进行增强，设置增强类优先级</h3><p>//（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高<br>@Component<br>@Aspect<br>@Order(1)<br>public class PersonProxy{ }</p>
<p>8、AOP 操作（AspectJ 配置文件）</p>
<!--1、创建两个类，增强类和被增强类，创建方法（同上一样）-->

<!--2、在 spring 配置文件中创建两个类对象-->

<!--创建对象-->

<p><bean id="book" class="com.atguigu.spring5.aopxml.Book"></bean><br><bean id="bookProxy" class="com.atguigu.spring5.aopxml.BookProxy"></bean></p>
<!--3、在 spring 配置文件中配置切入点-->

<!--配置 aop 增强-->

<p><a href="aop:config">aop:config</a><br> <!--切入点--><br> &lt;aop:pointcut id=”p” expression=”execution(* com.atguigu.spring5.aopxml.Book.buy(..))”/&gt;<br> <!--配置切面--><br> &lt;aop:aspect ref=”bookProxy”&gt;<br> <!--增强作用在具体的方法上--><br> &lt;aop:before method=”before” pointcut-ref=”p”/&gt;<br> </aop:aspect><br></aop:config></p>
<h2 id="在spring中使用JdbcTemplate进行数据库管理操作"><a href="#在spring中使用JdbcTemplate进行数据库管理操作" class="headerlink" title="在spring中使用JdbcTemplate进行数据库管理操作"></a>在spring中使用JdbcTemplate进行数据库管理操作</h2><p>JdbcTemplate</p>
<h3 id="1、JdbcTemplate概念及使用"><a href="#1、JdbcTemplate概念及使用" class="headerlink" title="1、JdbcTemplate概念及使用"></a>1、JdbcTemplate概念及使用</h3><p> a）Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<p> b）引入相关 jar 包</p>
<p> c）在 spring 配置文件配置数据库连接池</p>
<p><bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
 destroy-method="close"><br> <property name="url" value="jdbc:mysql:///test" /><br> <property name="username" value="root" /><br> <property name="password" value="root" /><br> <property name="driverClassName" value="com.mysql.jdbc.Driver" /><br></bean></p>
<p> d）配置 JdbcTemplate 对象，注入 DataSource</p>
<!-- JdbcTemplate 对象 -->

<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
 <!--注入 dataSource-->
 <property name="dataSource" ref="dataSource"></property><!--set方式注入-->
</bean>

<p> e）创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象</p>
<!-- 组件扫描 -->

<p>&lt;context:component-scan base-package=”com.atguigu”&gt;</context:component-scan><br>@Service<br>public class BookService {<br> //注入 dao<br> @Autowired<br> private BookDao bookDao;<br>}</p>
<p>@Repository<br>public class BookDaoImpl implements BookDao {<br> //注入 JdbcTemplate<br> @Autowired<br> private JdbcTemplate jdbcTemplate;<br>}</p>
<h3 id="2、JdbcTemplate-操作数据库（添加）"><a href="#2、JdbcTemplate-操作数据库（添加）" class="headerlink" title="2、JdbcTemplate 操作数据库（添加）"></a>2、JdbcTemplate 操作数据库（添加）</h3><p> a）对应数据库创建实体类</p>
<p> b）创建service和dao</p>
<p> （1）在 dao 进行数据库添加操作</p>
<p> （2）调用 JdbcTemplate 对象里面 update 方法实现添加操作</p>
<p>@Repository<br>public class BookDaoImpl implements BookDao {<br> //注入 JdbcTemplate<br> @Autowired<br> private JdbcTemplate jdbcTemplate;<br> //添加的方法<br> @Override<br> public void add(Book book) {<br> //1 创建 sql 语句<br> String sql = “insert into t_book values(?,?,?)”;<br> //2 调用方法实现<br> Object[] args = {book.getUserId(), book.getUsername(),book.getUstatus()};<br> int update = jdbcTemplate.update(sql,args);<br> System.out.println(update);<br> }<br>}</p>
<h3 id="3、JdbcTemplate-操作数据库（修改和删除）"><a href="#3、JdbcTemplate-操作数据库（修改和删除）" class="headerlink" title="3、JdbcTemplate 操作数据库（修改和删除）"></a>3、JdbcTemplate 操作数据库（修改和删除）</h3><p>//1、修改<br>@Override<br>public void updateBook(Book book) {<br> String sql = “update t_book set username=?,ustatus=? where user_id=?”;<br> Object[] args = {book.getUsername(), book.getUstatus(),book.getUserId()};<br> int update = jdbcTemplate.update(sql, args);<br> System.out.println(update);<br>}<br>//2、删除<br>@Override<br>public void delete(String id) {<br> String sql = “delete from t_book where user_id=?”;<br> int update = jdbcTemplate.update(sql, id);<br> System.out.println(update);<br>}<br>//使用JdbcTemplate 模板所实现的 “增删改” 都是调用了同一个 “update” 方法</p>
<h3 id="4、JdbcTemplate-操作数据库（查询返回某个值）"><a href="#4、JdbcTemplate-操作数据库（查询返回某个值）" class="headerlink" title="4、JdbcTemplate 操作数据库（查询返回某个值）"></a>4、JdbcTemplate 操作数据库（查询返回某个值）</h3><p>//查询表记录数<br>@Override<br>public int selectCount() {<br> String sql = “select count(*) from t_book”;<br>//queryForObject方法中：第一个参数代表–sql语句；第二个参数代表–返回类型class<br> Integer count = jdbcTemplate.queryForObject(sql, Integer.class);<br> return count;<br>}<br>JdbcTemplate 操作数据库（</p>
<h3 id="5、JdbcTemplate-操作数据库（查询返回对象）"><a href="#5、JdbcTemplate-操作数据库（查询返回对象）" class="headerlink" title="5、JdbcTemplate 操作数据库（查询返回对象）"></a>5、JdbcTemplate 操作数据库（查询返回对象）</h3><p>//查询返回对象<br>@Override<br>public Book findBookInfo(String id) {<br> String sql = “select * from t_book where user_id=?”;<br> //调用方法<br>/*<br>    queryForObject方法中：<br>        第一个参数：sql语句<br>        第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面 实现类 完成数据封装<br>        第三个参数：sql 语句值<br>*/<br> Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);<br> return book;<br>}</p>
<h3 id="6、JdbcTemplate-操作数据库（查询返回集合）"><a href="#6、JdbcTemplate-操作数据库（查询返回集合）" class="headerlink" title="6、JdbcTemplate 操作数据库（查询返回集合）"></a>6、JdbcTemplate 操作数据库（查询返回集合）</h3><p>//所用场景：查询图书列表分页、、<br>//查询返回集合<br>@Override<br>public List<Book> findAllBook() {<br> String sql = “select * from t_book”;<br> //调用方法<br> List<Book> bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));<br> return bookList;<br>}</p>
<h3 id="7、JdbcTemplate-操作数据库（批量操作）"><a href="#7、JdbcTemplate-操作数据库（批量操作）" class="headerlink" title="7、JdbcTemplate 操作数据库（批量操作）"></a>7、JdbcTemplate 操作数据库（批量操作）</h3><p>//批量添加<br>@Override<br>public void batchAddBook(List&lt;Object[]&gt; batchArgs) {<br> String sql = “insert into t_book values(?,?,?)”;<br>//batchUpdate方法 第一个参数：sql语句        第二个参数：List集合，添加多条记录数据<br> int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);<br> System.out.println(Arrays.toString(ints));<br>}</p>
<p>//批量添加测试<br>List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();<br>Object[] o1 = {“3”,”java”,”a”};<br>Object[] o2 = {“4”,”c++”,”b”};<br>Object[] o3 = {“5”,”MySQL”,”c”};<br>batchArgs.add(o1);<br>batchArgs.add(o2);<br>batchArgs.add(o3);<br>//调用批量添加<br>bookService.batchAdd(batchArgs);</p>
<h3 id="8、JdbcTemplate-实现批量修改操作"><a href="#8、JdbcTemplate-实现批量修改操作" class="headerlink" title="8、JdbcTemplate 实现批量修改操作"></a>8、JdbcTemplate 实现批量修改操作</h3><p>//批量修改(同批量添加一样，调用同一个方法)<br>@Override<br>public void batchUpdateBook(List&lt;Object[]&gt; batchArgs) {<br> String sql = “update t_book set username=?,ustatus=? where user_id=?”;<br> int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);<br> System.out.println(Arrays.toString(ints));<br>}</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li>事务的四大特性？</li>
<li>数据库的三大范式</li>
<li>事务隔离级别有哪些？</li>
<li>索引<ul>
<li>什么是索引？</li>
<li>索引的优缺点？</li>
<li>索引的作用？</li>
<li>什么情况下需要建索引？</li>
<li>什么情况下不建索引？</li>
<li>索引的数据结构</li>
<li>Hash索引和B+树索引的区别？</li>
<li>为什么B+树比B树更适合实现数据库索引？</li>
<li>索引有什么分类？</li>
<li>什么是最左匹配原则？</li>
<li>什么是聚集索引？</li>
<li>什么是覆盖索引？</li>
<li>索引的设计原则？</li>
<li>索引什么时候会失效？</li>
<li>什么是前缀索引？</li>
</ul>
</li>
<li>常见的存储引擎有哪些？</li>
<li>MyISAM和InnoDB的区别？</li>
<li>MVCC 实现原理？</li>
<li>快照读和当前读</li>
<li>共享锁和排他锁</li>
<li>大表怎么优化？</li>
<li>MySQL 执行计划了解吗？</li>
<li>bin log/redo log/undo log</li>
<li>bin log和redo log有什么区别？</li>
<li>讲一下MySQL架构？</li>
<li>分库分表</li>
<li>什么是分区表？</li>
<li>分区表类型</li>
<li>分区的问题？</li>
<li>查询语句执行流程？</li>
<li>更新语句执行过程？</li>
<li>exist和in的区别？</li>
<li>MySQL中int(10)和char(10)的区别？　</li>
<li>truncate、delete与drop区别？</li>
<li>having和where区别？</li>
<li>什么是MySQL主从同步？</li>
<li>为什么要做主从同步？</li>
<li>乐观锁和悲观锁是什么？</li>
<li>用过processlist吗？</li>
</ul>
<h2 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h2><p><strong>事务特性ACID</strong>：<strong>原子性</strong>（<code>Atomicity</code>）、<strong>一致性</strong>（<code>Consistency</code>）、<strong>隔离性</strong>（<code>Isolation</code>）、<strong>持久性</strong>（<code>Durability</code>）。</p>
<ul>
<li><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。</li>
<li><strong>隔离性</strong>。跟隔离级别相关，如<code>read committed</code>，一个事务只能读到已经提交的修改。</li>
<li><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><p><strong>第一范式1NF</strong></p>
<p>确保数据库表字段的原子性。</p>
<p>比如字段 <code>userInfo</code>: <code>广东省 10086&#39;</code> ，依照第一范式必须拆分成 <code>userInfo</code>: <code>广东省</code> <code>userTel</code>:<code>10086</code>两个字段。</p>
<p><strong>第二范式2NF</strong></p>
<p>首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。</p>
<p>举个例子。假定选课关系表为<code>student_course</code>(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。</p>
<p>可以拆分成三个表：学生：<code>student</code>(stuent_no, student_name, 年龄)；课程：<code>course</code>(course_name, credit)；选课关系：<code>student_course_relation</code>(student_no, course_name, grade)。</p>
<p><strong>第三范式3NF</strong></p>
<p>首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p>
<p>假定学生关系表为Student(student_no, student_name, age, academy_id, academy_telephone)，主键为”学号”，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。</p>
<p>可以把学生关系表分为如下两个表：学生：(student_no, student_name, age, academy_id)；学院：(academy_id, academy_telephone)。</p>
<p><strong>2NF和3NF的区别？</strong></p>
<ul>
<li>2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。</li>
<li>3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。</li>
</ul>
<h2 id="事务隔离级别有哪些？"><a href="#事务隔离级别有哪些？" class="headerlink" title="事务隔离级别有哪些？"></a>事务隔离级别有哪些？</h2><p>先了解下几个概念：脏读、不可重复读、幻读。</p>
<ul>
<li><strong>脏读</strong>是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li>
<li><strong>不可重复读</strong>是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。</li>
<li><strong>幻读</strong>是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。</li>
</ul>
<p><strong>不可重复读和脏读的区别</strong>是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。</p>
<p>MySQL数据库为我们提供的四种隔离级别：</p>
<ul>
<li><strong>Serializable</strong> (串行化)：通过强制事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>，使之不可能相互冲突，从而解决幻读问题。</li>
<li><strong>Repeatable read</strong> (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。</li>
<li><strong>Read committed</strong> (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。</li>
<li><strong>Read uncommitted</strong> (读未提交)：所有事务都可以看到其他未提交事务的执行结果。</li>
</ul>
<p>查看隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `@@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p>设置隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set` `session ``transaction` `isolation` `level` `read` `uncommitted``;</span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>。</p>
<h3 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h3><p>优点：</p>
<ul>
<li><strong>加快数据查找的速度</strong></li>
<li>为用来<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>或者是分组的字段添加索引，可以加快分组和<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>的速度</li>
<li>加快表与表之间的连接</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立索引需要<strong>占用物理空间</strong></li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li>
</ul>
<h3 id="索引的作用？"><a href="#索引的作用？" class="headerlink" title="索引的作用？"></a>索引的作用？</h3><p>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</p>
<h3 id="什么情况下需要建索引？"><a href="#什么情况下需要建索引？" class="headerlink" title="什么情况下需要建索引？"></a>什么情况下需要建索引？</h3><ol>
<li>经常用于查询的字段</li>
<li>经常用于连接的字段建立索引，可以加快连接的速度</li>
<li>经常需要<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>的字段建立索引，因为索引已经排好序，可以加快<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>查询速度</li>
</ol>
<h3 id="什么情况下不建索引？"><a href="#什么情况下不建索引？" class="headerlink" title="什么情况下不建索引？"></a>什么情况下不建索引？</h3><ol>
<li><code>where</code>条件中用不到的字段不适合建立索引</li>
<li>表记录较少</li>
<li>需要经常增删改</li>
<li><strong>参与列计算</strong>的列不适合建索引</li>
<li><strong>区分度不高</strong>的字段不适合建立索引，如性别等</li>
</ol>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构主要有B+树和<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。</p>
<p><strong>B+树索引</strong></p>
<p>B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ 树中，节点中的 <code>key</code> 从左到右递增排列，如果某个指针的左右相邻 <code>key</code> 分别是 keyi 和 keyi+1，则该指针指向节点的所有 <code>key</code> 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507955/B%E6%A0%91%E7%B4%A2%E5%BC%950.png" alt="img"></p>
<p>进行查找操作时，首先在根节点进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>，找到<code>key</code>所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>，找出<code>key</code>所对应的数据项。</p>
<p>MySQL 数据库使用最多的索引类型是<code>BTREE</code>索引，底层基于B+树数据结构来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show ``index` `from` `blog\G;``*************************** 1. row ***************************``    ``Table``: blog``  ``Non_unique: 0``   ``Key_name: ``PRIMARY`` ``Seq_in_index: 1`` ``Column_name: blog_id``  ``Collation: A`` ``Cardinality: 4``   ``Sub_part: ``NULL``    ``Packed: ``NULL``     ``Null``:``  ``Index_type: BTREE``   ``Comment:``Index_comment:``   ``Visible: YES``  ``Expression: ``NULL</span><br></pre></td></tr></table></figure>

<p><strong>哈希索引</strong></p>
<p>哈希索引是基于<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>的key值，将指向数据行的指针作为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</p>
<h3 id="Hash索引和B-树索引的区别？"><a href="#Hash索引和B-树索引的区别？" class="headerlink" title="Hash索引和B+树索引的区别？"></a>Hash索引和B+树索引的区别？</h3><ul>
<li>哈希索引**不支持<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>**，因为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>是无序的。</li>
<li>哈希索引<strong>不支持范围查找</strong>。</li>
<li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li>
<li>因为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li>
</ul>
<h3 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h3><ul>
<li>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</li>
<li>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</li>
<li>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h3 id="索引有什么分类？"><a href="#索引有什么分类？" class="headerlink" title="索引有什么分类？"></a>索引有什么分类？</h3><p>1、<strong>主键索引</strong>：名为primary的唯一非空索引，不允许有空值。</p>
<p>2、<strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一约束的列可以为<code>null</code>且可以存在多个<code>null</code>值。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。创建唯一索引的SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER` `TABLE` `table_name``ADD` `CONSTRAINT` `constraint_name ``UNIQUE` `KEY``(column_1,column_2,...);</span><br></pre></td></tr></table></figure>

<p>3、<strong>组合索引</strong>：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时需遵循最左前缀原则。</p>
<p>4、<strong>全文索引</strong>：只有在<code>MyISAM</code>引擎上才能使用，只能在<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>类型字段上使用全文索引。</p>
<h3 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a>什么是最左匹配原则？</h3><p>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就会停止匹配，后面的字段不会用到索引。</p>
<p>对<code>(a,b,c)</code>建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。</p>
<p>对<code>(a,b,c,d)</code>建立索引，查询条件为<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。</p>
<p>如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>）。直接执行<code>b = 2</code>这种查询条件无法使用索引。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507953/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80.png" alt="最左前缀"></p>
<p>当a的值确定的时候，b是有序的。例如<code>a = 1</code>时，b值为1，2是有序的状态。当<code>a = 2</code>时候，b的值为1，4也是有序状态。 当执行<code>a = 1 and b = 2</code>时a和b字段能用到索引。而执行<code>a &gt; 1 and b = 2</code>时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段无法使用索引。</p>
<h3 id="什么是聚集索引？"><a href="#什么是聚集索引？" class="headerlink" title="什么是聚集索引？"></a>什么是聚集索引？</h3><p>InnoDB使用表的主键构造主键索引树，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>连接，叶子节点按照主键的顺序<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>，因此对于主键的<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>查找和范围查找速度比较快。</p>
<p>聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</p>
<p>对于<code>InnoDB</code>来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为<code>NULL</code>的唯一索引。如果没有主键也没有合适的唯一索引，那么<code>InnoDB</code>内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。</p>
<h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p><code>select</code>的数据列只用从索引中就能够取得，不需要<strong>回表</strong>进行二次查询，也就是说查询列要被所使用的索引覆盖。对于<code>innodb</code>表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</p>
<p>不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</p>
<p>对于使用了覆盖索引的查询，在查询前面使用<code>explain</code>，输出的extra列会显示为<code>using index</code>。</p>
<p>比如<code>user_like</code> 用户点赞表，组合索引为<code>(user_id, blog_id)</code>，<code>user_id</code>和<code>blog_id</code>都不为<code>null</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain ``select` `blog_id ``from` `user_like ``where` `user_id = 13;</span><br></pre></td></tr></table></figure>

<p><code>explain</code>结果的<code>Extra</code>列为<code>Using index</code>，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过<strong>索引查找</strong>就能直接找到符合条件的数据，不需要回表查询数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain ``select` `user_id ``from` `user_like ``where` `blog_id = 1;</span><br></pre></td></tr></table></figure>

<p><code>explain</code>结果的<code>Extra</code>列为<code>Using where; Using index</code>， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过<strong>索引扫描</strong>找到符合条件的数据，也不需要回表查询数据。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507903/cover-index.png" alt="img"></p>
<h3 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h3><ul>
<li>索引列的<strong>区分度越高</strong>，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。</li>
<li>尽量使用<strong>短索引</strong>，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。</li>
<li>索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。</li>
<li>利用<strong>最左前缀原则</strong>。</li>
</ul>
<h3 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h3><p>导致索引失效的情况：</p>
<ul>
<li>对于组合索引，不是使用组合索引最左边的字段，则不会使用索引</li>
<li>以%开头的like查询如<code>%abc</code>，无法使用索引；非%开头的like查询如<code>abc%</code>，相当于范围查询，会使用索引</li>
<li>查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效</li>
<li>判断索引列是否不等于某个值时</li>
<li>对索引列进行运算</li>
<li>查询条件使用<code>or</code>连接，也会导致索引失效</li>
</ul>
<h3 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h3><p>有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。</p>
<p>前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。</p>
<p>创建前缀索引的关键在于选择足够长的前缀以<strong>保证较高的索引选择性</strong>。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。</p>
<p>建立前缀索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// email列创建前缀索引``ALTER` `TABLE` `table_name ``ADD` `KEY``(column_name(prefix_length));</span><br></pre></td></tr></table></figure>

<h2 id="常见的存储引擎有哪些？"><a href="#常见的存储引擎有哪些？" class="headerlink" title="常见的存储引擎有哪些？"></a>常见的存储引擎有哪些？</h2><p>MySQL中常用的四种存储引擎分别是： <strong>MyISAM</strong>、<strong>InnoDB</strong>、<strong>MEMORY</strong>、<strong>ARCHIVE</strong>。MySQL 5.5版本后默认的存储引擎为<code>InnoDB</code>。</p>
<p><strong>InnoDB存储引擎</strong></p>
<p>InnoDB是MySQL<strong>默认的事务型存储引擎</strong>，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</p>
<p><strong>优点</strong>：支持事务和崩溃修复能力；引入了行级锁和外键约束。</p>
<p><strong>缺点</strong>：占用的数据空间相对较大。</p>
<p><strong>适用场景</strong>：需要事务支持，并且有较高的并发读写频率。</p>
<p><strong>MyISAM存储引擎</strong></p>
<p>数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件<code>.MYD</code>和索引文件<code>.MYI</code>。</p>
<p><strong>优点</strong>：访问速度快。</p>
<p><strong>缺点</strong>：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</p>
<p><strong>适用场景</strong>：对事务完整性没有要求；表的数据都会只读的。</p>
<p><strong>MEMORY存储引擎</strong></p>
<p>MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。</p>
<p>MEMORY引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。</p>
<p><strong>优点</strong>：访问速度较快。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>哈希索引数据不是按照索引值顺序存储，无法用于<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>。</li>
<li>不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。</li>
<li>只支持等值比较，不支持范围查询。</li>
<li>当出现哈希冲突时，存储引擎需要遍历<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中所有的行指针，逐行进行比较，直到找到符合条件的行。</li>
</ol>
<p><strong>ARCHIVE存储引擎</strong></p>
<p>ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。</p>
<h2 id="MyISAM和InnoDB的区别？"><a href="#MyISAM和InnoDB的区别？" class="headerlink" title="MyISAM和InnoDB的区别？"></a>MyISAM和InnoDB的区别？</h2><ol>
<li><strong>是否支持行级锁</strong> : <code>MyISAM</code> 只有表级锁，而<code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复</strong>： <code>MyISAM</code> 不提供事务支持。而<code>InnoDB</code>提供事务支持，具有事务、回滚和崩溃修复能力。</li>
<li><strong>是否支持外键：</strong> <code>MyISAM</code>不支持，而<code>InnoDB</code>支持。</li>
<li><strong>是否支持MVCC</strong> ：<code>MyISAM</code>不支持，<code>InnoDB</code>支持。应对高并发事务，MVCC比单纯的加锁更高效。</li>
<li><code>MyISAM</code>不支持聚集索引，<code>InnoDB</code>支持聚集索引。</li>
</ol>
<h2 id="MVCC-实现原理？"><a href="#MVCC-实现原理？" class="headerlink" title="MVCC 实现原理？"></a>MVCC 实现原理？</h2><p>MVCC(<code>Multiversion concurrency control</code>) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过<code>read view</code>和版本链找到对应版本的数据。</p>
<p>作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。</p>
<p><strong>MVCC 实现原理如下：</strong></p>
<p>MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。</p>
<ul>
<li><code>DB_TRX_ID</code>：当前事务id，通过事务id的大小判断事务的时间顺序。</li>
<li><code>DB_ROLL_PRT</code>：回滚指针，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成<code>undo log</code>版本链。</li>
<li><code>DB_ROLL_ID</code>：主键，如果数据表没有主键，InnoDB会自动生成主键。</li>
</ul>
<p>每条表记录大概是这样的：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507911/mvcc9.png" alt="img"></p>
<p>使用事务更新行记录的时候，就会生成版本链，执行过程如下：</p>
<ol>
<li>用排他锁锁住该行；</li>
<li>将该行原本的值拷贝到<code>undo log</code>，作为旧版本用于回滚；</li>
<li>修改当前行的值，生成一个新版本，更新事务id，使回滚指针指向旧版本的记录，这样就形成一条版本链。</li>
</ol>
<p>下面举个例子方便大家理解。</p>
<p>1、初始数据如下，其中<code>DB_ROW_ID</code>和<code>DB_ROLL_PTR</code>为空。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507923/mvcc2.png" alt="img"></p>
<p>2、事务A对该行数据做了修改，将<code>age</code>修改为12，效果如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507957/mvcc7.png" alt="img"></p>
<p>3、之后事务B也对该行记录做了修改，将<code>age</code>修改为8，效果如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941509427/mvcc11.png" alt="img"></p>
<p>4、此时undo log有两行记录，并且通过回滚指针连在一起。</p>
<p><strong>接下来了解下read view的概念。</strong></p>
<p><code>read view</code>可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取某时刻t的数据时，到t时间点拍的“照片”上取数据。</p>
<p>在<code>read view</code>内部维护一个活跃事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>，表示生成<code>read view</code>的时候还在活跃的事务。这个<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>包含在创建<code>read view</code>之前还未提交的事务，不包含创建<code>read view</code>之后提交的事务。</p>
<p>不同隔离级别创建read view的时机不同。</p>
<ul>
<li>read committed：每次执行select都会创建新的read_view，保证能读取到其他事务已经提交的修改。</li>
<li>repeatable read：在一个事务范围内，第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用之前的read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。</li>
</ul>
<p><strong>read view的记录筛选方式</strong></p>
<p><strong>前提</strong>：<code>DATA_TRX_ID</code> 表示每个数据行的最新的事务ID；<code>up_limit_id</code>表示当前快照中的最先开始的事务；<code>low_limit_id</code>表示当前快照中的最慢开始的事务，即最后一个事务。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507929/read_view10.png" alt="img"></p>
<ul>
<li><p>如果<code>DATA_TRX_ID</code> &lt; <code>up_limit_id</code>：说明在创建<code>read view</code>时，修改该数据行的事务已提交，该版本的记录可被当前事务读取到。</p>
</li>
<li><p>如果<code>DATA_TRX_ID</code> &gt;= <code>low_limit_id</code>：说明当前版本的记录的事务是在创建<code>read view</code>之后生成的，该版本的数据行不可以被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本的记录对当前事务的可见性。</p>
</li>
<li><p>如果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up_limit_id</span><br></pre></td></tr></table></figure>

<p>&lt;=</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA_TRX_ID</span><br></pre></td></tr></table></figure>

<p>&lt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">low_limit_i</span><br></pre></td></tr></table></figure>

<p>：</p>
<ol>
<li>需要在活跃事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中查找是否存在ID为<code>DATA_TRX_ID</code>的值的事务。</li>
<li>如果存在，因为在活跃事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中的事务是未提交的，所以该记录是不可见的。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。</li>
<li>如果不存在，说明事务trx_id 已经提交了，这行记录是可见的。</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：InnoDB 的<code>MVCC</code>是通过 <code>read view</code> 和版本链实现的，版本链保存有历史版本记录，通过<code>read view</code> 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。</p>
<h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><p>表记录有两种读取方式。</p>
<ul>
<li>快照读：读取的是快照版本。普通的<code>SELECT</code>就是快照读。通过mvcc来进行并发控制的，不用加锁。</li>
<li>当前读：读取的是最新版本。<code>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE</code>是当前读。</li>
</ul>
<p>快照读情况下，InnoDB通过<code>mvcc</code>机制避免了幻读现象。而<code>mvcc</code>机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。</p>
<p>下面举个例子说明下：</p>
<p>1、首先，user表只有两条记录，具体如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507925/image-20210922232259664.png" alt="img"></p>
<p>2、事务a和事务b同时开启事务<code>start transaction</code>；</p>
<p>3、事务a插入数据然后提交；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert` `into` `user``(user_name, user_password, user_mail, user_state) ``values``(``&#x27;tyson&#x27;``, ``&#x27;a&#x27;``, ``&#x27;a&#x27;``, 0);</span><br></pre></td></tr></table></figure>

<p>4、事务b执行全表的update；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update` `user` `set` `user_name = ``&#x27;a&#x27;``;</span><br></pre></td></tr></table></figure>

<p>5、事务b然后执行查询，查到了事务a中插入的数据。（下图左边是事务b，右边是事务a。事务开始之前只有两条记录，事务a插入一条数据之后，事务b查询出来是三条数据）</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507965/%E5%B9%BB%E8%AF%BB1.png" alt="img"></p>
<p>以上就是当前读出现的幻读现象。</p>
<p><strong>那么MySQL是如何避免幻读？</strong></p>
<ul>
<li>在快照读情况下，MySQL通过<code>mvcc</code>来避免幻读。</li>
<li>在当前读情况下，MySQL通过<code>next-key</code>来避免幻读（加行锁和间隙锁来实现的）。</li>
</ul>
<p>next-key包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。</p>
<p><code>Serializable</code>隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。</p>
<h2 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h2><p>SELECT 的读取锁定主要分为两种方式：共享锁和排他锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `* ``from` `table` `where` `id&lt;6 lock ``in` `share mode;``--共享锁``select` `* ``from` `table` `where` `id&lt;6 ``for` `update``;``--排他锁</span><br></pre></td></tr></table></figure>

<p>这两种方式主要的不同在于<code>LOCK IN SHARE MODE</code>多个事务同时更新同一个表单时很容易造成死锁。</p>
<p>申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被<code>commit</code>语句或<code>rollback</code>语句结束为止。</p>
<p><code>SELECT... FOR UPDATE</code> 使用注意事项：</p>
<ol>
<li><code>for update</code> 仅适用于innodb，且必须在事务范围内才能生效。</li>
<li>根据主键进行查询，查询条件为<code>like</code>或者不等于，主键字段产生<strong>表锁</strong>。</li>
<li>根据非索引字段进行查询，会产生<strong>表锁</strong>。</li>
</ol>
<h2 id="大表怎么优化？"><a href="#大表怎么优化？" class="headerlink" title="大表怎么优化？"></a>大表怎么优化？</h2><p>某个表有近千万数据，查询比较慢，如何优化？</p>
<p>当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下：</p>
<ul>
<li>限定数据的范围。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内；</li>
<li>读写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li>通过分库分表的方式进行优化，主要有垂直拆分和水平拆分。</li>
</ul>
<h2 id="bin-log-redo-log-undo-log"><a href="#bin-log-redo-log-undo-log" class="headerlink" title="bin log/redo log/undo log"></a>bin log/redo log/undo log</h2><p>MySQL日志主要包括查询日志、慢查询日志、事务日志、错误日志、二进制日志等。其中比较重要的是 <code>bin log</code>（二进制日志）和 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<p><strong>bin log</strong></p>
<p><code>bin log</code>是MySQL数据库级别的文件，记录对MySQL数据库执行修改的所有操作，不会记录select和show语句，主要用于恢复数据库和同步数据库。</p>
<p><strong>redo log</strong></p>
<p><code>redo log</code>是innodb引擎级别，用来记录innodb存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障，innoDB存储引擎会使用<code>redo log</code>恢复到发生故障前的时刻，以此来保证数据的完整性。将参数<code>innodb_flush_log_at_tx_commit</code>设置为1，那么在执行commit时会将<code>redo log</code>同步写到磁盘。</p>
<p><strong>undo log</strong></p>
<p>除了记录<code>redo log</code>外，当进行数据修改时还会记录<code>undo log</code>，<code>undo log</code>用于数据的撤回操作，它保留了记录修改前的内容。通过<code>undo log</code>可以实现事务回滚，并且可以根据<code>undo log</code>回溯到某个特定的版本的数据，<strong>实现MVCC</strong>。</p>
<h2 id="bin-log和redo-log有什么区别？"><a href="#bin-log和redo-log有什么区别？" class="headerlink" title="bin log和redo log有什么区别？"></a>bin log和redo log有什么区别？</h2><ol>
<li><code>bin log</code>会记录所有日志记录，包括InnoDB、MyISAM等存储引擎的日志；<code>redo log</code>只记录innoDB自身的事务日志。</li>
<li><code>bin log</code>只在事务提交前写入到磁盘，一个事务只写一次；而在事务进行过程，会有<code>redo log</code>不断写入磁盘。</li>
<li><code>bin log</code>是逻辑日志，记录的是SQL语句的原始逻辑；<code>redo log</code>是物理日志，记录的是在某个数据页上做了什么修改。</li>
</ol>
<h2 id="讲一下MySQL架构？"><a href="#讲一下MySQL架构？" class="headerlink" title="讲一下MySQL架构？"></a>讲一下MySQL架构？</h2><p>MySQL主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。</li>
</ul>
<p><strong>Server 层基本组件</strong></p>
<ul>
<li><strong>连接器：</strong> 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。</li>
<li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。</li>
<li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。</li>
<li><strong>执行器：</strong> 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。</p>
<p>数据切分可以分为两种方式：垂直划分和水平划分。</p>
<p><strong>垂直划分</strong></p>
<p>垂直划分数据库是根据业务进行划分，例如购物场景，可以将库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，可以将商品基本信息和商品描述拆分成两张表。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941508067/%E5%9E%82%E7%9B%B4%E5%88%92%E5%88%86.png" alt="img"></p>
<p><strong>优点</strong>：行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>主键出现冗余，需要管理冗余列；</li>
<li>会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力；</li>
<li>依然存在单表数据量过大的问题。</li>
</ul>
<p><strong>水平划分</strong></p>
<p>水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941508121/%E6%B0%B4%E5%B9%B3%E5%88%92%E5%88%86.png" alt="img"></p>
<p><strong>优点</strong>：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>分片事务一致性难以解决</li>
<li>跨节点<code>join</code>性能差，逻辑复杂</li>
<li>数据分片在扩容时需要迁移</li>
</ul>
<h2 id="什么是分区表？"><a href="#什么是分区表？" class="headerlink" title="什么是分区表？"></a>什么是分区表？</h2><p>分区表是一个独立的逻辑表，但是底层由多个物理子表组成。</p>
<p>当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可。</p>
<h2 id="分区表类型"><a href="#分区表类型" class="headerlink" title="分区表类型"></a>分区表类型</h2><p><strong>按照范围分区。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_range_partition(``    ``id INT auto_increment,``    ``createdate DATETIME,``    ``primary key (id,createdate)``  ``)``  ``PARTITION BY RANGE (TO_DAYS(createdate) ) (``   ``PARTITION p201801 VALUES LESS THAN ( TO_DAYS(``&#x27;20180201&#x27;``) ),``   ``PARTITION p201802 VALUES LESS THAN ( TO_DAYS(``&#x27;20180301&#x27;``) ),``   ``PARTITION p201803 VALUES LESS THAN ( TO_DAYS(``&#x27;20180401&#x27;``) ),``   ``PARTITION p201804 VALUES LESS THAN ( TO_DAYS(``&#x27;20180501&#x27;``) ),``   ``PARTITION p201805 VALUES LESS THAN ( TO_DAYS(``&#x27;20180601&#x27;``) ),``   ``PARTITION p201806 VALUES LESS THAN ( TO_DAYS(``&#x27;20180701&#x27;``) ),``   ``PARTITION p201807 VALUES LESS THAN ( TO_DAYS(``&#x27;20180801&#x27;``) ),``   ``PARTITION p201808 VALUES LESS THAN ( TO_DAYS(``&#x27;20180901&#x27;``) ),``   ``PARTITION p201809 VALUES LESS THAN ( TO_DAYS(``&#x27;20181001&#x27;``) ),``   ``PARTITION p201810 VALUES LESS THAN ( TO_DAYS(``&#x27;20181101&#x27;``) ),``   ``PARTITION p201811 VALUES LESS THAN ( TO_DAYS(``&#x27;20181201&#x27;``) ),``   ``PARTITION p201812 VALUES LESS THAN ( TO_DAYS(``&#x27;20190101&#x27;``) )``  ``);</span><br></pre></td></tr></table></figure>

<p>在<code>/var/lib/mysql/data/</code>可以找到对应的数据文件，每个分区表都有一个使用#分隔命名的表文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``-rw-r----- ``1` `MySQL MySQL  ``65` `Mar ``14` `21``:``47` `db.opt``  ``-rw-r----- ``1` `MySQL MySQL ``8598` `Mar ``14` `21``:``50` `test_range_partition.frm``  ``-rw-r----- ``1` `MySQL MySQL ``98304` `Mar ``14` `21``:``50` `test_range_partition#P#p201801.ibd``  ``-rw-r----- ``1` `MySQL MySQL ``98304` `Mar ``14` `21``:``50` `test_range_partition#P#p201802.ibd``  ``-rw-r----- ``1` `MySQL MySQL ``98304` `Mar ``14` `21``:``50` `test_range_partition#P#p201803.ibd``...</span><br></pre></td></tr></table></figure>

<p><strong>list分区</strong></p>
<p>对于<code>List</code>分区，分区字段必须是已知的，如果插入的字段不在分区时枚举值中，将无法插入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test_list_partiotion``  ``(``    ``id ``int` `auto_increment,``    ``data_type tinyint,``    ``primary key(id,data_type)``  ``)partition by list(data_type)``  ``(``    ``partition p0 values in (``0``,``1``,``2``,``3``,``4``,``5``,``6``),``    ``partition p1 values in (``7``,``8``,``9``,``10``,``11``,``12``),``    ``partition p2 values in (``13``,``14``,``15``,``16``,``17``)``  ``);</span><br></pre></td></tr></table></figure>

<p><strong>hash分区</strong></p>
<p>可以将数据均匀地分布到预先定义的分区中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test_hash_partiotion``  ``(``    ``id ``int` `auto_increment,``    ``create_date datetime,``    ``primary key(id,create_date)``  ``)partition by hash(year(create_date)) partitions ``10``;</span><br></pre></td></tr></table></figure>

<h2 id="分区的问题？"><a href="#分区的问题？" class="headerlink" title="分区的问题？"></a>分区的问题？</h2><ol>
<li>打开和锁住所有底层表的成本可能很高。当查询访问分区表时，MySQL 需要打开并锁住所有的底层表，这个操作在分区过滤之前发生，所以无法通过分区过滤来降低此开销，会影响到查询速度。可以通过批量操作来降低此类开销，比如批量插入、<code>LOAD DATA INFILE</code>和一次删除多行数据。</li>
<li>维护分区的成本可能很高。例如重组分区，会先创建一个临时分区，然后将数据复制到其中，最后再删除原分区。</li>
<li>所有分区必须使用相同的存储引擎。</li>
</ol>
<h2 id="查询语句执行流程？"><a href="#查询语句执行流程？" class="headerlink" title="查询语句执行流程？"></a>查询语句执行流程？</h2><p>查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。</p>
<p>举个例子，查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `* ``from` `user` `where` `id &gt; 1 ``and` `name` `= ``&#x27;大彬&#x27;``;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先检查权限，没有权限则返回错误；</li>
<li>MySQL8.0以前会查询缓存，缓存命中则直接返回，没有则执行下一步；</li>
<li>词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；</li>
<li>两种执行方案，先查 <code>id &gt; 1</code> 还是 <code>name = &#39;大彬&#39;</code>，优化器根据自己的优化<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>选择执行效率最好的方案；</li>
<li>校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。</li>
</ol>
<h2 id="更新语句执行过程？"><a href="#更新语句执行过程？" class="headerlink" title="更新语句执行过程？"></a>更新语句执行过程？</h2><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、<code>redo log</code>（<code>prepare</code>状态）、<code>binlog</code>、<code>redo log</code>（<code>commit</code>状态）</p>
<p>举个例子，更新语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update` `user` `set` `name` `= ``&#x27;大彬&#x27;` `where` `id = 1;</span><br></pre></td></tr></table></figure>

<ol>
<li>先查询到 id 为1的记录，有缓存会使用缓存。</li>
<li>拿到查询结果，将 name 更新为大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录<code>redo log</code>，此时<code>redo log</code>进入 <code>prepare</code>状态。</li>
<li>执行器收到通知后记录<code>binlog</code>，然后调用引擎接口，提交<code>redo log</code>为<code>commit</code>状态。</li>
<li>更新完成。</li>
</ol>
<p>为什么记录完<code>redo log</code>，不直接提交，而是先进入<code>prepare</code>状态？</p>
<p>假设先写<code>redo log</code>直接提交，然后写<code>binlog</code>，写完<code>redo log</code>后，机器挂了，<code>binlog</code>日志没有被写入，那么机器重启后，这台机器会通过<code>redo log</code>恢复数据，但是这个时候<code>binlog</code>并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>
<h2 id="exist和in的区别？"><a href="#exist和in的区别？" class="headerlink" title="exist和in的区别？"></a>exist和in的区别？</h2><p><code>exists</code>用于对外表记录做筛选。<code>exists</code>会遍历外表，将外查询表的每一行，代入内查询进行判断。当<code>exists</code>里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。反之如果<code>exists</code>里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `a.* ``from` `A awhere exists(``select` `1 ``from` `B b ``where` `a.id=b.id)</span><br></pre></td></tr></table></figure>

<p><code>in</code>是先把后边的语句查出来放到临时表中，然后遍历临时表，将临时表的每一行，代入外查询去查找。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `* ``from` `Awhere id ``in``(``select` `id ``from` `B)</span><br></pre></td></tr></table></figure>

<p><strong>子查询的表比较大的时候</strong>，使用<code>exists</code>可以有效减少总的循环次数来提升速度；<strong>当外查询的表比较大的时候</strong>，使用<code>in</code>可以有效减少对外查询表循环遍历来提升速度。</p>
<h2 id="MySQL中int-10-和char-10-的区别？"><a href="#MySQL中int-10-和char-10-的区别？" class="headerlink" title="MySQL中int(10)和char(10)的区别？"></a>MySQL中int(10)和char(10)的区别？</h2><p>int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。</p>
<h2 id="truncate、delete与drop区别？"><a href="#truncate、delete与drop区别？" class="headerlink" title="truncate、delete与drop区别？"></a>truncate、delete与drop区别？</h2><p><strong>相同点：</strong></p>
<ol>
<li><code>truncate</code>和不带<code>where</code>子句的<code>delete</code>、以及<code>drop</code>都会删除表内的数据。</li>
<li><code>drop</code>、<code>truncate</code>都是<code>DDL</code>语句（数据定义语言），执行后会自动提交。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引；</li>
<li>一般来说，执行速度: drop &gt; truncate &gt; delete。</li>
</ol>
<h2 id="having和where区别？"><a href="#having和where区别？" class="headerlink" title="having和where区别？"></a>having和where区别？</h2><ul>
<li>二者作用的对象不同，<code>where</code>子句作用于表和视图，<code>having</code>作用于组。</li>
<li><code>where</code>在数据分组前进行过滤，<code>having</code>在数据分组后进行过滤。</li>
</ul>
<h2 id="什么是MySQL主从同步？"><a href="#什么是MySQL主从同步？" class="headerlink" title="什么是MySQL主从同步？"></a>什么是MySQL主从同步？</h2><p>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（<code>master</code>），其余的服务器充当从服务器（<code>slave</code>）。</p>
<p>因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。</p>
<h2 id="为什么要做主从同步？"><a href="#为什么要做主从同步？" class="headerlink" title="为什么要做主从同步？"></a>为什么要做主从同步？</h2><ol>
<li>读写分离，使数据库能支撑更大的并发。</li>
<li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li>
<li>数据备份，保证数据的安全。</li>
</ol>
<h2 id="乐观锁和悲观锁是什么？"><a href="#乐观锁和悲观锁是什么？" class="headerlink" title="乐观锁和悲观锁是什么？"></a>乐观锁和悲观锁是什么？</h2><p>数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观锁和悲观锁是并发控制主要采用的技术手段。</p>
<ul>
<li>悲观锁：假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加<code>version</code>字段，在修改提交之前检查<code>version</code>与原来取到的<code>version</code>值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用版本号机制或<code>CAS</code><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>实现。</li>
</ul>
<h2 id="用过processlist吗？"><a href="#用过processlist吗？" class="headerlink" title="用过processlist吗？"></a>用过processlist吗？</h2><p><code>show processlist</code> 或 <code>show full processlist</code> 可以查看当前 MySQL 是否有压力，正在运行的<code>SQL</code>，有没有慢<code>SQL</code>正在执行。返回参数如下：</p>
<ol>
<li><p><strong>id</strong>：线程ID，可以用<code>kill id</code>杀死某个线程</p>
</li>
<li><p><strong>db</strong>：数据库名称</p>
</li>
<li><p><strong>user</strong>：数据库用户</p>
</li>
<li><p><strong>host</strong>：数据库实例的IP</p>
</li>
<li><p><strong>command</strong>：当前执行的命令，比如<code>Sleep</code>，<code>Query</code>，<code>Connect</code>等</p>
</li>
<li><p><strong>time</strong>：消耗时间，单位秒</p>
</li>
<li><p>state</p>
<p>：执行状态，主要有以下状态：</p>
<ul>
<li>Sleep，线程正在等待客户端发送新的请求</li>
<li>Locked，线程正在等待锁</li>
<li>Sending data，正在处理<code>SELECT</code>查询的记录，同时把结果发送给客户端</li>
<li>Kill，正在执行<code>kill</code>语句，杀死指定线程</li>
<li>Connect，一个从节点连上了主节点</li>
<li>Quit，线程正在退出</li>
<li>Sorting for group，正在为<code>GROUP BY</code>做<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a></li>
<li>Sorting for order，正在为<code>ORDER BY</code>做<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a></li>
</ul>
</li>
<li><p><strong>info</strong>：正在执行的<code>SQL</code>语句</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/09/java8learn/</url>
    <content><![CDATA[<h1 id="JAVA8学习"><a href="#JAVA8学习" class="headerlink" title="JAVA8学习"></a>JAVA8学习</h1><h2 id="01、Java8概述"><a href="#01、Java8概述" class="headerlink" title="01、Java8概述"></a>01、Java8概述</h2><p>Java 8 (又称为jdk 1.8) 是Java 语言开发的一个主要版本。<br>Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
<h2 id="02、Java8新特性的好处"><a href="#02、Java8新特性的好处" class="headerlink" title="02、Java8新特性的好处"></a>02、Java8新特性的好处</h2><p>速度更快<br>代码更少(增加了新的语法：Lambda 表达式)<br>强大的Stream API<br>便于并行<br>最大化减少空指针异常：Optional<br>Nashorn引擎，允许在JVM上运行JS应用</p>
<h2 id="03、并行流与串行流"><a href="#03、并行流与串行流" class="headerlink" title="03、并行流与串行流"></a>03、并行流与串行流</h2><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过parallel() 与sequential() 在并行流与顺序流之间进行切换。</p>
<h2 id="04、Lambda表达式"><a href="#04、Lambda表达式" class="headerlink" title="04、Lambda表达式"></a>04、Lambda表达式</h2><p>Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<p>4.1、Lambda表达式使用举例<br>import org.junit.Test;</p>
<p>import java.util.Comparator;</p>
<p>/**</p>
<ul>
<li>Lambda表达式的使用举例</li>
<li>/</li>
<li>public class LambdaTest {<br>@Test<br>public void test(){<pre><code> Runnable r1 = new Runnable() &#123;
     @Override
     public void run() &#123;
         System.out.println(&quot;长安欢迎您&quot;);
     &#125;
 &#125;;
 r1.run();

 System.out.println(&quot;+++++++++++++++++++++++++|&quot;);
  
 Runnable r2 = () -&gt; System.out.println(&quot;长安欢迎您&quot;);
  
 r2.run();
</code></pre>
 } @Test<br> public void test2(){<pre><code> Comparator&lt;Integer&gt; c1 = new Comparator&lt;Integer&gt;() &#123;
     @Override
     public int compare(Integer o1, Integer o2) &#123;
         return Integer.compare(o1,o2);
     &#125;
 &#125;;
 int compare1 = c1.compare(8,16);
 System.out.println(compare1);

 System.out.println(&quot;+++++++++++++++++++++++&quot;);
  
 //Lambda表达式的写法
 Comparator&lt;Integer&gt; c2 = (o1,o2) -&gt; Integer.compare(o1,o2);
  
 int compare2 = c2.compare(28,35);
 System.out.println(compare2);
  
 System.out.println(&quot;+++++++++++++++++++++++++++&quot;);
 //方法引用
 Comparator&lt;Integer&gt; c3 = Integer :: compare;
  
 int compare3 = c3.compare(28,35);
 System.out.println(compare3);
</code></pre>
 }<br>   }</li>
</ul>
<p> 4.2、Lambda表达式语法的使用1<br> import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.function.Consumer;</p>
<p>/**</p>
<ul>
<li><p>Lambda表达式的使用</p>
</li>
<li></li>
<li><p>1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p>
</li>
<li><p>2.格式：</p>
</li>
<li><pre><code> -&gt; :lambda操作符 或 箭头操作符
</code></pre>
</li>
<li><pre><code> -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）
</code></pre>
</li>
<li><pre><code> -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）
</code></pre>
</li>
<li></li>
<li><p>3.Lambda表达式的使用：（分为6种情况介绍）</p>
</li>
<li><p>/<br>  public class LambdaTest1 {</p>
<p>  //语法格式一：无参，无返回值<br>  @Test<br>  public void test(){</p>
<pre><code>  Runnable r1 = new Runnable() &#123;
      @Override
      public void run() &#123;
          System.out.println(&quot;长安欢迎您&quot;);
      &#125;
  &#125;;
  r1.run();

  System.out.println(&quot;+++++++++++++++++++++++++|&quot;);
   
  Runnable r2 = () -&gt; System.out.println(&quot;长安欢迎您&quot;);
   
  r2.run();
</code></pre>
<p>  }</p>
<p>  //语法格式二：Lambda 需要一个参数，但是没有返回值。<br>  @Test<br>  public void test2(){</p>
<pre><code>  Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() &#123;
      @Override
      public void accept(String s) &#123;
          System.out.println(s);
      &#125;
  &#125;;
  con.accept(&quot;善与恶的区别是什么？&quot;);

  System.out.println(&quot;+++++++++++++++++++&quot;);
   
  Consumer&lt;String&gt; c1 = (String s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);
</code></pre>
<p>  }</p>
<p>  //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”<br>  @Test<br>  public void test3(){</p>
<pre><code>  Consumer&lt;String&gt; c1 = (String s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);

  System.out.println(&quot;---------------------&quot;);
   
  Consumer&lt;String&gt; c2 = (s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c2.accept(&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;);
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test4(){</p>
<pre><code>  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//类型推断

  int[] arr = &#123;1,2,3&#125;;//类型推断
</code></pre>
<p>  }<br>  }</p>
</li>
</ul>
<p> 4.3、Lambda表达式语法的使用2<br> import org.junit.Test;</p>
<p>import java.util.Comparator;<br>import java.util.function.Consumer;</p>
<p>/**</p>
<ul>
<li><p>Lambda表达式的使用</p>
</li>
<li></li>
<li><p>1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p>
</li>
<li><p>2.格式：</p>
</li>
<li><p>-&gt; :lambda操作符 或 箭头操作符</p>
</li>
<li><p>-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</p>
</li>
<li><p>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）<br>  *</p>
</li>
<li><p>3.Lambda表达式的使用：（分为6种情况介绍）</p>
</li>
<li></li>
<li><p>总结：</p>
</li>
<li><p>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略</p>
</li>
<li><p>   -&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p>
</li>
<li><p>/<br>public class LambdaTest1 {</p>
<p>  //语法格式四：Lambda若只需要一个参数时，参数的小括号可以省略<br>  @Test<br>  public void test5(){</p>
<pre><code>  Consumer&lt;String&gt; c1 = (s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);

  System.out.println(&quot;---------------------&quot;);
  
  Consumer&lt;String&gt; c2 = s -&gt; &#123;
      System.out.println(s);
  &#125;;
  c2.accept(&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;);
</code></pre>
<p>  }</p>
<p>  //语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值<br>  @Test<br>  public void test6(){</p>
<pre><code>  Comparator&lt;Integer&gt; c1 = new Comparator&lt;Integer&gt;() &#123;
      @Override
      public int compare(Integer o1, Integer o2) &#123;
          System.out.println(o1);
          System.out.println(o2);
          return o1.compareTo(o2);
      &#125;
  &#125;;
  System.out.println(c1.compare(15,23));

  System.out.println(&quot;\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;);
  
  Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;
      System.out.println(o1);
      System.out.println(o2);
      return o1.compareTo(o2);
  &#125;;
  System.out.println(com2.compare(16,8));
</code></pre>
<p>  }</p>
<p>  //语法格式六：当Lambda体只有一条语句时，return与大括号若有，都可以省略<br>  @Test<br>  public void test7(){</p>
<pre><code>  Comparator&lt;Integer&gt; c1 = (o1,o2) -&gt; &#123;
      return o1.compareTo(o2);
  &#125;;

  System.out.println(c1.compare(16,8));
  
  System.out.println(&quot;\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;);
  
  Comparator&lt;Integer&gt; c2 = (o1,o2) -&gt; o1.compareTo(o2);
  
  System.out.println(c2.compare(17,24));
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test8(){</p>
<pre><code>  Consumer&lt;String&gt; c1 = s -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);

  System.out.println(&quot;---------------------&quot;);
  
  Consumer&lt;String&gt; c2 = s -&gt; System.out.println(s);
  
  c2.accept(&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<h2 id="05、函数式-Functional-接口"><a href="#05、函数式-Functional-接口" class="headerlink" title="05、函数式(Functional)接口"></a>05、函数式(Functional)接口</h2><p>5.1、函数式接口的介绍<br>/*</p>
<ul>
<li><p>4.Lambda表达式的本质：作为函数式接口的实例</p>
</li>
<li></li>
<li><ol start="5">
<li>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，</li>
</ol>
</li>
<li><p>  这样做可以检查它是否是一个函数式接口。</p>
</li>
<li></li>
<li><p>/</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>自定义函数式接口</p>
</li>
<li><p>/<br>  public interface MyInterFace {</p>
<p>  void method();</p>
</li>
</ul>
<p>//    void method2();</p>
<p>}</p>
<p>在java.util.function包下定义了Java 8 的丰富的函数式接口<br>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程）<br>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。<br>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。<br>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。<br>5.2、Java内置的函数式接口介绍及使用举例<br>函数式接口    参数类型    返回类型    用途<br>Consumer 消费型接口    T    void    对类型为T的对象应用操作，包含方法：void accept(T t)<br>Supplier 供给型接口    无    T    返回类型为T的对象，包含方法：T get()<br>Function&lt;T, R&gt;函数型接口    T    R    对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)<br>Predicate断定型接口    T    boolean    确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t)<br>BiFunction&lt;T,U,R&gt;    T, U    R    对类型为T,U参数应用操作，返回R类型的结果。包含方法为：Rapply(T t,U u);<br>UnaryOperator(Function子接口)    T    T    对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：Tapply(T t);<br>BinaryOperator(BiFunction子接口)    T,T    T    对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为：Tapply(T t1,T t2);<br>BiConsumer&lt;T,U&gt;    T,U    void    对类型为T,U参数应用操作。包含方法为：voidaccept(Tt,Uu)<br>BiPredicate&lt;T,U&gt;    T,U    boolean    包含方法为：booleantest(Tt,Uu)<br>ToIntFunction    T    int    计算int值的函数<br>ToLongFunction    T    long    计算long值的函数<br>ToDoubleFunction    T    double    计算double值的函数<br>IntFunction    int    R    参数为int类型的函数<br>LongFunction    long    R    参数为long类型的函数<br>DoubleFunction    double    R    参数为double类型的函数<br>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br>import java.util.function.Consumer;<br>import java.util.function.Predicate;</p>
<p>/**</p>
<ul>
<li><p>java内置的4大核心函数式接口</p>
</li>
<li></li>
<li><p>消费型接口 Consumer<T>     void accept(T t)</p>
</li>
<li><p>供给型接口 Supplier<T>     T get()</p>
</li>
<li><p>函数型接口 Function&lt;T,R&gt;   R apply(T t)</p>
</li>
<li><p>断定型接口 Predicate<T>    boolean test(T t)</p>
</li>
<li><p>/<br>  public class LambdaTest2 {</p>
<p>  public void happyTime(double money, Consumer<Double> con) {</p>
<pre><code>  con.accept(money);
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test(){</p>
<pre><code>  happyTime(30, new Consumer&lt;Double&gt;() &#123;
      @Override
      public void accept(Double aDouble) &#123;
          System.out.println(&quot;熬夜太累了，点个外卖，价格为：&quot; + aDouble);
      &#125;
  &#125;);
  System.out.println(&quot;+++++++++++++++++++++++++&quot;);

  //Lambda表达式写法
  happyTime(20,money -&gt; System.out.println(&quot;熬夜太累了，吃口麻辣烫，价格为：&quot; + money));
</code></pre>
<p>  }</p>
<p>  //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定<br>  public List<String> filterString(List<String> list, Predicate<String> pre){</p>
<pre><code>  ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();
  for(String s : list)&#123;
      if(pre.test(s))&#123;
          filterList.add(s);
      &#125;
  &#125;
  return filterList;
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test2(){</p>
<pre><code>  List&lt;String&gt; list = Arrays.asList(&quot;长安&quot;,&quot;上京&quot;,&quot;江南&quot;,&quot;渝州&quot;,&quot;凉州&quot;,&quot;兖州&quot;);

  List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() &#123;
      @Override
      public boolean test(String s) &#123;
          return s.contains(&quot;州&quot;);
      &#125;
  &#125;);
   
  System.out.println(filterStrs);
   
  List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;州&quot;));
  System.out.println(filterStrs1);
</code></pre>
<p>  }<br>  }</p>
</li>
</ul>
<h1 id="06、方法引用与构造器引用"><a href="#06、方法引用与构造器引用" class="headerlink" title="06、方法引用与构造器引用"></a>06、方法引用与构造器引用</h1><p> 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br> 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。<br> 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！<br> 格式：使用操作符“::” 将类(或对象) 与方法名分隔开来。<br> 如下三种主要使用情况：<br> 对象::实例方法名<br> 类::静态方法名<br> 类::实例方法名<br> 6.1、方法引用的使用情况1<br> 1、Employee类</p>
<p>public class Employee {</p>
<pre><code>private int id;
private String name;
private int age;
private double salary;

public int getId() &#123;
    return id;
&#125;

public void setId(int id) &#123;
    this.id = id;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public int getAge() &#123;
    return age;
&#125;

public void setAge(int age) &#123;
    this.age = age;
&#125;

public double getSalary() &#123;
    return salary;
&#125;

public void setSalary(double salary) &#123;
    this.salary = salary;
&#125;

public Employee() &#123;
    System.out.println(&quot;Employee().....&quot;);
&#125;

public Employee(int id) &#123;
    this.id = id;
    System.out.println(&quot;Employee(int id).....&quot;);
&#125;

public Employee(int id, String name) &#123;
    this.id = id;
    this.name = name;
&#125;

public Employee(int id, String name, int age, double salary) &#123;

    this.id = id;
    this.name = name;
    this.age = age;
    this.salary = salary;
&#125;

@Override
public String toString() &#123;
    return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#39;&#125;&#39;;
&#125;

@Override
public boolean equals(Object o) &#123;
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;

    Employee employee = (Employee) o;

    if (id != employee.id)
        return false;
    if (age != employee.age)
        return false;
    if (Double.compare(employee.salary, salary) != 0)
        return false;
    return name != null ? name.equals(employee.name) : employee.name == null;
&#125;

@Override
public int hashCode() &#123;
    int result;
    long temp;
    result = id;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + age;
    temp = Double.doubleToLongBits(salary);
    result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
    return result;
&#125;
</code></pre>
<p>}</p>
<p>2、测试类</p>
<p>import org.junit.Test;</p>
<p>import java.io.PrintStream;<br>import java.util.Comparator;<br>import java.util.function.BiPredicate;<br>import java.util.function.Consumer;<br>import java.util.function.Function;<br>import java.util.function.Supplier;</p>
<p>/**</p>
<ul>
<li><p>方法引用的使用</p>
</li>
<li></li>
<li><p>1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
</li>
<li></li>
<li><p>2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</p>
</li>
<li><p>方法引用，也是函数式接口的实例。<br>*</p>
</li>
<li><ol start="3">
<li>使用格式：  类(或对象) :: 方法名</li>
</ol>
<p>*</p>
</li>
<li><ol start="4">
<li>具体分为如下的三种情况：</li>
</ol>
</li>
<li><p>情况1     对象 :: 非静态方法</p>
</li>
<li><p>情况2     类 :: 静态方法<br>*</p>
</li>
<li><p>情况3     类 :: 非静态方法<br>*</p>
</li>
<li><ol start="5">
<li>方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的</li>
</ol>
</li>
<li><p>   形参列表和返回值类型相同！（针对于情况1和情况2）</p>
</li>
<li><p>/<br>public class MethodRefTest {</p>
<p>  // 情况一：对象 :: 实例方法<br>  //Consumer中的void accept(T t)<br>  //PrintStream中的void println(T t)<br>  @Test<br>  public void test() {</p>
<pre><code>  Consumer&lt;String&gt; c1 = str -&gt; System.out.println(str);
  c1.accept(&quot;兖州&quot;);

  System.out.println(&quot;+++++++++++++&quot;);
  PrintStream ps = System.out;
  Consumer&lt;String&gt; c2 = ps::println;
  c2.accept(&quot;xian&quot;);
</code></pre>
<p>  }</p>
<p>  //Supplier中的T get()<br>  //Employee中的String getName()<br>  @Test<br>  public void test2() {</p>
<pre><code>  Employee emp = new Employee(004,&quot;Nice&quot;,19,4200);

  Supplier&lt;String&gt; sk1 = () -&gt; emp.getName();
  System.out.println(sk1.get());
  
  System.out.println(&quot;*******************&quot;);
  Supplier&lt;String&gt; sk2 = emp::getName;
  System.out.println(sk2.get());
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>6.2、方法引用的使用情况2<br>1、Employee类——同上</p>
<p>2、测试类</p>
<p>import org.junit.Test;<br>import java.util.Comparator;<br>import java.util.function.Function;</p>
<p>public class MethodRefTest {</p>
<pre><code>// 情况二：类 :: 静态方法
//Comparator中的int compare(T t1,T t2)
//Integer中的int compare(T t1,T t2)
@Test
public void test3() &#123;
    Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1,t2);
    System.out.println(com1.compare(21,20));

    System.out.println(&quot;+++++++++++++++&quot;);

    Comparator&lt;Integer&gt; com2 = Integer::compare;
    System.out.println(com2.compare(15,7));
&#125;

//Function中的R apply(T t)
//Math中的Long round(Double d)
@Test
public void test4() &#123;
    Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() &#123;
        @Override
        public Long apply(Double d) &#123;
            return Math.round(d);
        &#125;
    &#125;;

    System.out.println(&quot;++++++++++++++++++&quot;);

    Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);
    System.out.println(func1.apply(14.1));

    System.out.println(&quot;++++++++++++++++++&quot;);

    Function&lt;Double,Long&gt; func2 = Math::round;
    System.out.println(func2.apply(17.4));
&#125;
</code></pre>
<p>}</p>
<p>6.2、方法引用的使用情况3<br>1、Employee类——同上</p>
<p>2、测试类</p>
<p>import org.junit.Test;</p>
<p>import java.util.Comparator;<br>import java.util.function.BiPredicate;<br>import java.util.function.Function;</p>
<p>public class MethodRefTest {</p>
<pre><code>// 情况三：类 :: 实例方法  (有难度)
// Comparator中的int comapre(T t1,T t2)
// String中的int t1.compareTo(t2)
@Test
public void test5() &#123;
    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);
    System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));

    System.out.println(&quot;++++++++++++++++&quot;);

    Comparator&lt;String&gt; com2 = String :: compareTo;
    System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));
&#125;

//BiPredicate中的boolean test(T t1, T t2);
//String中的boolean t1.equals(t2)
@Test
public void test6() &#123;
    BiPredicate&lt;String,String&gt; pre1 = (s1, s2) -&gt; s1.equals(s2);
    System.out.println(pre1.test(&quot;MON&quot;,&quot;MON&quot;));

    System.out.println(&quot;++++++++++++++++++++&quot;);
    
    BiPredicate&lt;String,String&gt; pre2 = String :: equals;
    System.out.println(pre2.test(&quot;MON&quot;,&quot;MON&quot;));
&#125;

// Function中的R apply(T t)
// Employee中的String getName();
@Test
public void test7() &#123;
    Employee employee = new Employee(007, &quot;Ton&quot;, 21, 8000);

    Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();
    System.out.println(func1.apply(employee));

    System.out.println(&quot;++++++++++++++++++++++++&quot;);

    Function&lt;Employee,String&gt; f2 = Employee::getName;
    System.out.println(f2.apply(employee));
&#125;
</code></pre>
<p>}</p>
<p>6.4、构造器引用与数组引用的使用<br>格式：ClassName::new</p>
<p>与函数式接口相结合，自动与函数式接口中方法兼容。</p>
<p>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>
<p>1、Employee类——同上</p>
<p>2、测试类</p>
<p>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.function.BiFunction;<br>import java.util.function.Function;<br>import java.util.function.Supplier;</p>
<p>/**</p>
<ul>
<li><p>一、构造器引用</p>
</li>
<li><pre><code> 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。
</code></pre>
</li>
<li><pre><code> 抽象方法的返回值类型即为构造器所属的类的类型
</code></pre>
</li>
<li></li>
<li><p>二、数组引用</p>
</li>
<li><pre><code>可以把数组看做是一个特殊的类，则写法与构造器引用一致。 
</code></pre>
</li>
<li><p>/<br>public class MethodRefTest {</p>
<p>  //构造器引用<br>  //Supplier中的T get()<br>  //Employee的空参构造器：Employee()<br>  @Test<br>  public void test() {</p>
<pre><code>  Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() &#123;
      @Override
      public Employee get() &#123;
          return new Employee();
      &#125;
  &#125;;
  System.out.println(&quot;+++++++++++++++++++&quot;);

  Supplier&lt;Employee&gt; sk1 = () -&gt; new Employee();
  System.out.println(sk1.get());
  
  System.out.println(&quot;+++++++++++++++++++&quot;);
  
  Supplier&lt;Employee&gt; sk2 = Employee::new;
  System.out.println(sk2.get());
</code></pre>
<p>  }</p>
<p>  //Function中的R apply(T t)<br>  @Test<br>  public void test2() {</p>
<pre><code>  Function&lt;Integer, Employee&gt; f1 = id -&gt; new Employee(id);
  Employee employee = f1.apply(7793);
  System.out.println(employee);

  System.out.println(&quot;+++++++++++++++++++&quot;);
  
  Function&lt;Integer, Employee&gt; f2 = Employee::new;
  Employee employee1 = f2.apply(4545);
  System.out.println(employee1);
</code></pre>
<p>  }</p>
<p>  //BiFunction中的R apply(T t,U u)<br>  @Test<br>  public void test3() {</p>
<pre><code>  BiFunction&lt;Integer, String, Employee&gt; f1 = (id, name) -&gt; new Employee(id, name);
  System.out.println(f1.apply(2513, &quot;Fruk&quot;));

  System.out.println(&quot;*******************&quot;);
  
  BiFunction&lt;Integer, String, Employee&gt; f2 = Employee::new;
  System.out.println(f2.apply(9526, &quot;Bon&quot;));
</code></pre>
<p>  }</p>
<p>  //数组引用<br>  //Function中的R apply(T t)<br>  @Test<br>  public void test4() {</p>
<pre><code>  Function&lt;Integer, String[]&gt; f1 = length -&gt; new String[length];
  String[] arr1 = f1.apply(7);
  System.out.println(Arrays.toString(arr1));

  System.out.println(&quot;+++++++++++++++++++&quot;);
  
  Function&lt;Integer, String[]&gt; f2 = String[]::new;
  String[] arr2 = f2.apply(9);
  System.out.println(Arrays.toString(arr2));
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<h2 id="07、强大的Stream-API"><a href="#07、强大的Stream-API" class="headerlink" title="07、强大的Stream API"></a>07、强大的Stream API</h2><p>7.1、Stream API的概述<br>Java8中有两大最为重要的改变。第一个是Lambda 表达式；另外一个则是Stream API。<br>Stream API ( java.util.stream)把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。<br>为什么要使用Stream API<br>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。<br>Stream 和Collection 集合的区别：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。<br>/**</p>
<ul>
<li>1.Stream关注的是对数据的运算，与CPU打交道</li>
<li>  集合关注的是数据的存储，与内存打交道</li>
<li></li>
<li>2.</li>
<li>①Stream 自己不会存储元素。</li>
<li>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</li>
<li></li>
<li>3.Stream 执行流程</li>
<li>① Stream的实例化</li>
<li>② 一系列的中间操作（过滤、映射、…)</li>
<li>③ 终止操作</li>
<li></li>
<li>4.说明：</li>
<li>4.1 一个中间操作链，对数据源的数据进行处理</li>
<li>4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li>
<li>/</li>
</ul>
<p>7.2、Stream的实例化<br>1、EmployeeData类</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>/**</p>
<ul>
<li>提供用于测试的数据</li>
<li>/<br>  public class EmployeeData {  public static List<Employee> getEmployees(){<pre><code>  List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
  
  list.add(new Employee(1001, &quot;马化腾&quot;, 34, 6000.38));
  list.add(new Employee(1002, &quot;马云&quot;, 12, 9876.12));
  list.add(new Employee(1003, &quot;刘强东&quot;, 33, 3000.82));
  list.add(new Employee(1004, &quot;雷军&quot;, 26, 7657.37));
  list.add(new Employee(1005, &quot;李彦宏&quot;, 65, 5555.32));
  list.add(new Employee(1006, &quot;比尔盖茨&quot;, 42, 9500.43));
  list.add(new Employee(1007, &quot;任正非&quot;, 26, 4333.32));
  list.add(new Employee(1008, &quot;扎克伯格&quot;, 35, 2500.32));
  
  return list;
</code></pre>
  }<br>  }</li>
</ul>
<p> 2、Employee类</p>
<p>public class Employee {</p>
<pre><code>private int id;
private String name;
private int age;
private double salary;

public int getId() &#123;
    return id;
&#125;

public void setId(int id) &#123;
    this.id = id;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public int getAge() &#123;
    return age;
&#125;

public void setAge(int age) &#123;
    this.age = age;
&#125;

public double getSalary() &#123;
    return salary;
&#125;

public void setSalary(double salary) &#123;
    this.salary = salary;
&#125;

public Employee() &#123;
    System.out.println(&quot;Employee().....&quot;);
&#125;

public Employee(int id) &#123;
    this.id = id;
    System.out.println(&quot;Employee(int id).....&quot;);
&#125;

public Employee(int id, String name) &#123;
    this.id = id;
    this.name = name;
&#125;

public Employee(int id, String name, int age, double salary) &#123;

    this.id = id;
    this.name = name;
    this.age = age;
    this.salary = salary;
&#125;

@Override
public String toString() &#123;
    return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#39;&#125;&#39;;
&#125;

@Override
public boolean equals(Object o) &#123;
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;

    Employee employee = (Employee) o;

    if (id != employee.id)
        return false;
    if (age != employee.age)
        return false;
    if (Double.compare(employee.salary, salary) != 0)
        return false;
    return name != null ? name.equals(employee.name) : employee.name == null;
&#125;

@Override
public int hashCode() &#123;
    int result;
    long temp;
    result = id;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + age;
    temp = Double.doubleToLongBits(salary);
    result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
    return result;
&#125;
</code></pre>
<p>}</p>
<p>3、测试类</p>
<p>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.IntStream;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的实例化</p>
</li>
<li><p>/<br>  public class StreamAPITest {</p>
<p>  //创建 Stream方式一：通过集合<br>  @Test<br>  public void test(){</p>
<pre><code>  List&lt;Employee&gt; employees = EmployeeData.getEmployees();
</code></pre>
</li>
</ul>
<p>//        default Stream<E> stream() : 返回一个顺序流<br>        Stream<Employee> stream = employees.stream();</p>
<p>//        default Stream<E> parallelStream() : 返回一个并行流<br>        Stream<Employee> parallelStream = employees.parallelStream();<br>    }</p>
<pre><code>//创建 Stream方式二：通过数组
@Test
public void test2()&#123;
    int[] arr = new int[]&#123;1,2,3,4,5,6&#125;;
    //调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流
    IntStream stream = Arrays.stream(arr);

    Employee e1 = new Employee(1001,&quot;Hom&quot;);
    Employee e2 = new Employee(1002,&quot;Nut&quot;);
    Employee[] arr1 = new Employee[]&#123;e1,e2&#125;;

    Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);
&#125;
//创建 Stream方式三：通过Stream的of()
@Test
public void test3()&#123;
    Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
&#125;

//创建 Stream方式四：创建无限流
@Test
public void test4()&#123;
</code></pre>
<p>//      迭代<br>//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)<br>        //遍历前10个偶数<br>        Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println);</p>
<p>//      生成<br>//      public static<T> Stream<T> generate(Supplier<T> s)<br>        Stream.generate(Math::random).limit(10).forEach(System.out::println);<br>    }<br>}</p>
<p>7.3、Stream的中间操作：筛选与切片<br>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p>方法    描述<br>filter(Predicate p)    接收Lambda ，从流中排除某些元素<br>distinct()    筛选，通过流所生成元素的hashCode() 和equals() 去除重复元素<br>limit(long maxSize)    截断流，使其元素不超过给定数量<br>skip(long n)    跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与limit(n)互补<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的中间操作</p>
</li>
<li><p>/<br>  public class StreamAPITest2 {</p>
<p>  //1-筛选与切片<br>  @Test<br>  public void test(){</p>
<pre><code>  List&lt;Employee&gt; list = EmployeeData.getEmployees();
</code></pre>
<p>  //        filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</p>
<pre><code>  Stream&lt;Employee&gt; stream = list.stream();
  //练习：查询员工表中薪资大于7000的员工信息
  stream.filter(e -&gt; e.getSalary() &gt; 7000).forEach(System.out::println);

  System.out.println(&quot;+++++++++++++++++++++++&quot;);
</code></pre>
<p>  //        limit(n)——截断流，使其元素不超过给定数量。</p>
<pre><code>  list.stream().limit(3).forEach(System.out::println);
  System.out.println(&quot;+++++++++++++++++++++++&quot;);
</code></pre>
</li>
</ul>
<p>//        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补<br>        list.stream().skip(3).forEach(System.out::println);</p>
<pre><code>    System.out.println(&quot;+++++++++++++++++++++++&quot;);
</code></pre>
<p>//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</p>
<pre><code>    list.add(new Employee(1013,&quot;李飞&quot;,42,8500));
    list.add(new Employee(1013,&quot;李飞&quot;,41,8200));
    list.add(new Employee(1013,&quot;李飞&quot;,28,6000));
    list.add(new Employee(1013,&quot;李飞&quot;,39,7800));
    list.add(new Employee(1013,&quot;李飞&quot;,40,8000));
</code></pre>
<p>//        System.out.println(list);</p>
<pre><code>    list.stream().distinct().forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>7.4、Stream的中间操作：映射<br>方法    描述<br>map(Function f)    接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<br>mapToDouble(ToDoubleFunction f)    接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。<br>mapToInt(ToIntFunction f)    接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。<br>mapToLong(ToLongFunction f)    接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。<br>flatMap(Function f)    接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的中间操作</p>
</li>
<li><p>/<br>  public class StreamAPITest2 {</p>
<p>  //2-映射<br>  @Test<br>  public void test2(){<br>  //        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
<pre><code>  List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
  list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);
</code></pre>
</li>
</ul>
<p>//        练习1：获取员工姓名长度大于3的员工的姓名。<br>        List<Employee> employees = EmployeeData.getEmployees();<br>        Stream<String> namesStream = employees.stream().map(Employee::getName);<br>        namesStream.filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);<br>        System.out.println();</p>
<pre><code>    //练习2：
    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest2::fromStringToStream);
    
    streamStream.forEach(s -&gt;&#123;
        s.forEach(System.out::println);
    &#125;);
    System.out.println(&quot;++++++++++++++++++++++&quot;);
</code></pre>
<p>//        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。<br>        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest2::fromStringToStream);</p>
<pre><code>    characterStream.forEach(System.out::println);
&#125;

//将字符串中的多个字符构成的集合转换为对应的Stream的实例
public static Stream&lt;Character&gt; fromStringToStream(String str)&#123;//aa
    ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();
    for(Character c : str.toCharArray())&#123;
        list.add(c);
    &#125;
    return list.stream();
&#125;

@Test
public void test3()&#123;
    ArrayList list1 = new ArrayList();
    list1.add(25);
    list1.add(33);
    list1.add(14);

    ArrayList list2 = new ArrayList();
    list2.add(51);
    list2.add(23);
    list2.add(61);
</code></pre>
<p>//        list1.add(list2);<br>        list1.addAll(list2);<br>        System.out.println(list1);<br>    }<br>}</p>
<p>7.5、Stream的中间操作：排序<br>方法    描述<br>sorted()    产生一个新流，其中按自然顺序排序<br>sorted(Comparator com)    产生一个新流，其中按比较器顺序排序<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的中间操作</p>
</li>
<li><p>/<br>  public class StreamAPITest2 {</p>
<p>  //3-排序<br>  @Test<br>  public void test4(){<br>  //        sorted()——自然排序</p>
<pre><code>  List&lt;Integer&gt; list = Arrays.asList(25,45,36,12,85,64,72,-95,4);
  list.stream().sorted().forEach(System.out::println);
  //抛异常，原因:Employee没有实现Comparable接口
</code></pre>
<p>  //        List<Employee> employees = EmployeeData.getEmployees();<br>  //        employees.stream().sorted().forEach(System.out::println);</p>
</li>
</ul>
<p>//        sorted(Comparator com)——定制排序</p>
<pre><code>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();
    employees.stream().sorted( (e1,e2) -&gt; &#123;

        int ageValue = Integer.compare(e1.getAge(),e2.getAge());
        if(ageValue != 0)&#123;
            return ageValue;
        &#125;else&#123;
            return -Double.compare(e1.getSalary(),e2.getSalary());
        &#125;

    &#125;).forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>7.6、Stream的终止操作：匹配与查找<br>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 。<br>流进行了终止操作后，不能再次使用。<br>方法    描述<br>allMatch(Predicate p)    检查是否匹配所有元素<br>anyMatch(Predicate p)    检查是否至少匹配一个元素<br>noneMatch(Predicate p)    检查是否没有匹配所有元素<br>findFirst()    返回第一个元素<br>findAny()    返回当前流中的任意元素<br>count()    返回流中元素总数<br>max(Comparator c)    返回流中最大值<br>min(Comparator c)    返回流中最小值<br>forEach(Consumer c)    内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.List;<br>import java.util.Optional;<br>import java.util.stream.Stream;</p>
<p>public class StreamAPITest3 {<br>    //1-匹配与查找<br>    @Test<br>    public void test(){<br>        List<Employee> employees = EmployeeData.getEmployees();</p>
<p>//        allMatch(Predicate p)——检查是否匹配所有元素。<br>//          练习：是否所有的员工的年龄都大于18<br>        boolean allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; 23);<br>        System.out.println(allMatch);</p>
<p>//        anyMatch(Predicate p)——检查是否至少匹配一个元素。<br>//         练习：是否存在员工的工资大于 10000<br>        boolean anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; 9000);<br>        System.out.println(anyMatch);</p>
<p>//        noneMatch(Predicate p)——检查是否没有匹配的元素。<br>//          练习：是否存在员工姓“马”<br>        boolean noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith(“马”));<br>        System.out.println(noneMatch);</p>
<p>//        findFirst——返回第一个元素<br>        Optional<Employee> employee = employees.stream().findFirst();<br>        System.out.println(employee);</p>
<p>//        findAny——返回当前流中的任意元素<br>        Optional<Employee> employee1 = employees.parallelStream().findAny();<br>        System.out.println(employee1);<br>    }</p>
<pre><code>@Test
public void test2()&#123;
    List&lt;Employee&gt; employees = EmployeeData.getEmployees();
    
    // count——返回流中元素的总个数
    long count = employees.stream().filter(e -&gt; e.getSalary() &gt; 4500).count();
    System.out.println(count);
</code></pre>
<p>//        max(Comparator c)——返回流中最大值<br>//        练习：返回最高的工资：<br>        Stream<Double> salaryStream = employees.stream().map(e -&gt; e.getSalary());<br>        Optional<Double> maxSalary = salaryStream.max(Double::compare);<br>        System.out.println(maxSalary);</p>
<p>//        min(Comparator c)——返回流中最小值<br>//        练习：返回最低工资的员工<br>        Optional<Employee> employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));<br>        System.out.println(employee);<br>        System.out.println();</p>
<p>//        forEach(Consumer c)——内部迭代<br>        employees.stream().forEach(System.out::println);</p>
<pre><code>    //使用集合的遍历操作
    employees.forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>7.7、Stream的终止操作：归约<br>方法    描述<br>reduce(T iden, BinaryOperator b)    可以将流中元素反复结合起来，得到一个值。返回T<br>reduce(BinaryOperator b)    可以将流中元素反复结合起来，得到一个值。返回Optional<br>备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。</p>
<p>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.Optional;<br>import java.util.stream.Stream;</p>
<p>public class StreamAPITest3 {</p>
<pre><code>//2-归约
@Test
public void test3()&#123;
</code></pre>
<p>//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T<br>//        练习1：计算1-10的自然数的和<br>        List<Integer> list = Arrays.asList(72,25,32,34,43,56,81,15,29,71);<br>        Integer sum = list.stream().reduce(0, Integer::sum);<br>        System.out.println(sum);</p>
<p>//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T><br>//        练习2：计算公司所有员工工资的总和<br>        List<Employee> employees = EmployeeData.getEmployees();<br>        Stream<Double> salaryStream = employees.stream().map(Employee::getSalary);<br>//        Optional<Double> sumMoney = salaryStream.reduce(Double::sum);<br>        Optional<Double> sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);<br>        System.out.println(sumMoney.get());<br>    }<br>}</p>
<p>7.8、Stream的终止操作：收集<br>方法    描述<br>collect(Collector c)    将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.Optional;<br>import java.util.Set;<br>import java.util.stream.Collectors;<br>import java.util.stream.Stream;</p>
<p>public class StreamAPITest3 {</p>
<pre><code>//3-收集
@Test
public void test4() &#123;
</code></pre>
<p>//        collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法<br>//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</p>
<pre><code>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();
    List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toList());

    employeeList.forEach(System.out::println);
    
    System.out.println(&quot;++++++++++++++++++&quot;);
    
    Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toSet());

    employeeSet.forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。</p>
<p>Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<h2 id="08、Optional类"><a href="#08、Optional类" class="headerlink" title="08、Optional类"></a>08、Optional类</h2><p>8.1、Optional类的介绍<br>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
<p>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。<br>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>创建Optional类对象的方法：<br>Optional.of(T t): 创建一个Optional 实例，t必须非空；<br>Optional.empty() : 创建一个空的Optional 实例<br>Optional.ofNullable(T t)：t可以为null<br>判断Optional容器中是否包含对象：<br>boolean isPresent() : 判断是否包含对象<br>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。<br>获取Optional容器的对象：<br>T get(): 如果调用对象包含值，返回该值，否则抛异常<br>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。<br>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。<br>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。<br>1、Boy类</p>
<p>public class Boy {<br>    private Girl girl;</p>
<pre><code>public Boy() &#123;
&#125;

public Boy(Girl girl) &#123;
    this.girl = girl;
&#125;

public Girl getGirl() &#123;
    return girl;
&#125;

public void setGirl(Girl girl) &#123;
    this.girl = girl;
&#125;

@Override
public String toString() &#123;
    return &quot;Boy&#123;&quot; +
            &quot;girl=&quot; + girl +
            &#39;&#125;&#39;;
&#125;
</code></pre>
<p>}</p>
<p>2、Girl类</p>
<p>public class Girl {<br>    private String name;</p>
<pre><code>public Girl() &#123;
&#125;

public Girl(String name) &#123;
    this.name = name;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

@Override
public String toString() &#123;
    return &quot;Girl&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &#39;&#125;&#39;;
&#125;
</code></pre>
<p>}</p>
<p>3、测试类</p>
<p>import org.junit.Test;<br>import java.util.Optional;</p>
<p>/**</p>
<ul>
<li><p>Optional类：为了在程序中避免出现空指针异常而创建的。</p>
</li>
<li></li>
<li><p>常用的方法：ofNullable(T t)</p>
</li>
<li><pre><code>      orElse(T t)
</code></pre>
</li>
<li><p>/<br>public class OptionalTest {<br>  /**</p>
<ul>
<li>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</li>
<li>Optional.empty() : 创建一个空的 Optional 实例</li>
<li>Optional.ofNullable(T t)：t可以为null</li>
<li>/<br>  @Test<br>  public void test(){<br>  Girl girl = new Girl();<br>//        girl = null;<br>  //of(T t):保证t是非空的<br>  Optional<Girl> optionalGirl = Optional.of(girl);<br>  }</li>
</ul>
<p>  @Test<br>  public void test2(){</p>
<pre><code>  Girl girl = new Girl();
</code></pre>
<p>//        girl = null;</p>
<pre><code>  //ofNullable(T t)：t可以为null
  Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);
  System.out.println(optionalGirl);
  //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.
  //如果内部的t是空的，则返回orElse()方法中的参数t1.
  Girl girl1 = optionalGirl.orElse(new Girl(&quot;&quot;));
  System.out.println(girl1);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>8.2、Optional类的使用举例<br>1、测试类</p>
<p>import org.junit.Test;<br>import java.util.Optional;</p>
<p>/**</p>
<ul>
<li><p>Optional类：为了在程序中避免出现空指针异常而创建的。</p>
</li>
<li></li>
<li><p>常用的方法：ofNullable(T t)</p>
</li>
<li><pre><code>      orElse(T t)
</code></pre>
</li>
<li><p>/<br>public class OptionalTest {</p>
<p>  @Test<br>  public void test3(){</p>
<pre><code>  Boy boy = new Boy();
  boy = null;
  String girlName = getGirlName(boy);
  System.out.println(girlName);
</code></pre>
<p>  }</p>
<p>  private String getGirlName(Boy boy) {</p>
<pre><code>  return boy.getGirl().getName();
</code></pre>
<p>  }</p>
<p>  //优化以后的getGirlName():<br>  public String getGirlName1(Boy boy){</p>
<pre><code>  if(boy != null)&#123;
      Girl girl = boy.getGirl();
      if(girl != null)&#123;
          return girl.getName();
      &#125;
  &#125;
  return null;
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test4(){</p>
<pre><code>  Boy boy = new Boy();
  boy = null;
  String girlName = getGirlName1(boy);
  System.out.println(girlName);
</code></pre>
<p>  }</p>
<p>  //使用Optional类的getGirlName():<br>  public String getGirlName2(Boy boy){</p>
<pre><code>  Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);
  //此时的boy1一定非空
  Boy boy1 = boyOptional.orElse(new Boy(new Girl(&quot;朱淑贞&quot;)));
  
  Girl girl = boy1.getGirl();
  
  Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);
  //girl1一定非空
  Girl girl1 = girlOptional.orElse(new Girl(&quot;阿青&quot;));
  
  return girl1.getName();
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test5(){</p>
<pre><code>  Boy boy = null;
  boy = new Boy();
  boy = new Boy(new Girl(&quot;李清照&quot;));
  String girlName = getGirlName2(boy);
  System.out.println(girlName);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
]]></content>
  </entry>
</search>
