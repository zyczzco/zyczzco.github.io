<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VUE详细基础语法</title>
    <url>/2021/11/20/VUE%E8%AF%A6%E7%BB%86%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="VUE详细基础语法"><a href="#VUE详细基础语法" class="headerlink" title="VUE详细基础语法"></a>VUE详细基础语法</h1><span id="more"></span>
<h2 id="一-v-bind动态绑定"><a href="#一-v-bind动态绑定" class="headerlink" title="一.v-bind动态绑定"></a>一.v-bind动态绑定</h2><p>参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a v-bind:href = &quot;url&quot;&gt;.。。。。.&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>动态参数</p>
<h3 id="1-动态绑定属性class"><a href="#1-动态绑定属性class" class="headerlink" title="(1)动态绑定属性class"></a>(1)动态绑定属性class</h3><p>v-bind绑定class中的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;V-bind 动态绑定&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">​</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&lt;p :class=&quot;&#123;fontCol:isNmae,setBack:!isAge&#125;&quot; class = &quot;weoght&quot;&gt;</span><br><span class="line">				&#123; &#123;name &#125; &#125;</span><br><span class="line">			&lt;/p&gt;</span><br><span class="line">			&lt;i :class=&quot;addClass&quot;&gt; &#123; &#123;name &#125; &#125;beautiful&lt;/i&gt;</span><br><span class="line">		&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">	el:&#x27;#app&#x27;,</span><br><span class="line">	data:&#123;</span><br><span class="line">		isName:true,</span><br><span class="line">		isAge:false,</span><br><span class="line">		name:&quot;zycc&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	computed:&#123;</span><br><span class="line">		addClass:function()&#123;</span><br><span class="line">			return&#123;</span><br><span class="line">				checked:this.isName&amp;&amp;!this.isAge</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="2-v-bind动态绑定属性style"><a href="#2-v-bind动态绑定属性style" class="headerlink" title="(2)v-bind动态绑定属性style"></a>(2)v-bind动态绑定属性style</h3><p>vbind可将style的属性实时渲染到html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-bind =&quot;http://www.w3.org/1999/xtml&quot;&gt;</span><br><span class="line">	&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;V-bind 动态绑定style&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html</span><br><span class="line">	&lt;div :style=&quot;&#123;&#x27;color&#x27;:color,&#x27;fontSize&#x27;:fontSize+&#x27;px&#x27;&#125;&quot;&gt;</span><br><span class="line">		修饰文本</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		var af = new Vue(&#123;</span><br><span class="line">			el:&#x27;#app&#x27;,</span><br><span class="line">			data:&#123;</span><br><span class="line">				color:&#x27;red&#x27;,</span><br><span class="line">				fonSize:24</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</html>

<h2 id="二-过滤器filter"><a href="#二-过滤器filter" class="headerlink" title="二.过滤器filter"></a>二.过滤器filter</h2><h3 id="1-定义过滤器"><a href="#1-定义过滤器" class="headerlink" title="(1)定义过滤器"></a>(1)定义过滤器</h3><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="*全局过滤器"></a>*全局过滤器</h4><p>Vue.filter(“过滤器名称”，function(value[,value2…])){</p>
<p>//逻辑代码}</p>
<h4 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="*局部过滤器"></a>*局部过滤器</h4><p>new Vue({</p>
<p>filters:{</p>
<p>‘过滤器名称’:function(value2[,value2,..]){</p>
<p>​    //逻辑代码}</p>
<p>}</p>
<p>})</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>局部过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-bind =&quot;http://www.w3.org/1999/xtml&quot;&gt;</span><br><span class="line">	&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;局部过滤器&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">            &lt;!--|管道符号用于作为分隔，前个为参数，后个为处理函数--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">html</span><br><span class="line">	&lt;p&gt;计算机价格:&#123; &#123;price|addPriceIcon &#125; &#125;&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		var af = new Vue(&#123;</span><br><span class="line">			el:&#x27;#app&#x27;,</span><br><span class="line">			data:&#123;</span><br><span class="line">				price:200</span><br><span class="line">			&#125;,filters:&#123;</span><br><span class="line">				//处理函数</span><br><span class="line">				addPriceIcon(value)&#123;</span><br><span class="line">					console.log(value)//200</span><br><span class="line">					return &#x27;$&#x27;+value;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

</html>



<p>全局过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:v-bind =&quot;http://www.w3.org/1999/xtml&quot;&gt;</span><br><span class="line">	&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;全部过滤器&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">			&lt;h3&gt;&#123; &#123;viewContent | addNamePrefix &#125; &#125;&lt;/h3&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;script&gt;</span><br><span class="line">	Vue.filter(&quot;addNamePrefix&quot;,(value)=&gt;&#123;</span><br><span class="line">		return &quot;my name is &quot;+value</span><br><span class="line">	&#125;)</span><br><span class="line">		var af = new Vue(&#123;</span><br><span class="line">			el:&#x27;#app&#x27;,</span><br><span class="line">			data:&#123;</span><br><span class="line">				viewContent:&quot;阿朝&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="三-Vue实例及选项"><a href="#三-Vue实例及选项" class="headerlink" title="三.Vue实例及选项"></a>三.Vue实例及选项</h2><h3 id="1-数据选项data"><a href="#1-数据选项data" class="headerlink" title="1.数据选项data"></a>1.数据选项data</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--是用来输出Vue对象中的message值。如果message内容改变，这里输出也会改变。--&gt;</span><br><span class="line">    &#123; &#123;message&#125; &#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /*在script标签内，创建了Vue实例对象，该对象中有两个属性：el和data。el属性的作用是将Vue实例绑定到id为App的DOM中，data用于数据的存储*/</span><br><span class="line">    var app=new Vue(&#123;</span><br><span class="line">        el:&#x27;#app&#x27;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:&#x27;Hello world&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-属性选项props"><a href="#2-属性选项props" class="headerlink" title="2.属性选项props"></a>2.属性选项props</h3><p>props选项可以是数组或者对象类型，用于接收从父组件传递过来的参数，允许为其赋值默认值，类型检查和规则检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;message content=&#x27;Hello World&#x27;&gt;&lt;/message&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 测试组件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var Message = Vue.extend(&#123;</span><br><span class="line">        props : [&#x27;content&#x27;],</span><br><span class="line">        data : function()&#123;return &#123;</span><br><span class="line">            a: &#x27;it worked&#x27;</span><br><span class="line">        &#125; &#125;,</span><br><span class="line">        template : &#x27;&lt;h1&gt;&#123; &#123;content&#125; &#125;&lt;/h1&gt;&lt;h1&gt;&#123; &#123;a &#125; &#125;&lt;/h1&gt;&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    Vue.component(&#x27;message&#x27;, Message)</span><br><span class="line">    var vm = new Vue( &#123;</span><br><span class="line">        el : &#x27;#app&#x27;,</span><br><span class="line">    &#125; )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-方法选项methods"><a href="#3-方法选项methods" class="headerlink" title="3.方法选项methods"></a>3.方法选项methods</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;test&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 测试组件 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el : &#x27;#app&#x27;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            /*定义了一个test函数*/</span><br><span class="line">            test: function () &#123;</span><br><span class="line">                // console.log(new Date().toLocaleTimeString());</span><br><span class="line">             var aData = new Date();</span><br><span class="line">                console.log(aData)</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="4-计算属性computed"><a href="#4-计算属性computed" class="headerlink" title="4.计算属性computed"></a>4.计算属性computed</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el:&#x27;#app&#x27;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        Math:66,</span><br><span class="line">        English: 77,</span><br><span class="line">        Chinese:88</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        &lt;!-- 一个计算属性的getter --&gt;</span><br><span class="line">        sum:function()&#123;</span><br><span class="line">            &lt;!-- this指向vm实例 --&gt;</span><br><span class="line">            return this.Math+ this.English+this.Chinese;</span><br><span class="line">        &#125;,</span><br><span class="line">average:function()&#123;</span><br><span class="line">    return Math.round(this.sum/3);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="5-v-model表单控件"><a href="#5-v-model表单控件" class="headerlink" title="5.v-model表单控件"></a>5.v-model表单控件</h3><h4 id="①input使用v-model双向绑定"><a href="#①input使用v-model双向绑定" class="headerlink" title="①input使用v-model双向绑定"></a>①input使用v-model双向绑定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!--创建一个id为APP的div标签--&gt;</span><br><span class="line">	&lt;div id=&quot;app&quot; class=&quot;demo&quot;&gt;</span><br><span class="line">		&lt;input v-model = &quot;message&quot; placeholder=&quot;请输入信息&quot;&gt;</span><br><span class="line">		&lt;!--placeholder提示信息在获取字段后消失--&gt;</span><br><span class="line">		&lt;p&gt;Message is: &#123; &#123;message&#125; &#125;&lt;/p&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;script&gt;</span><br><span class="line">		var app = new Vue(&#123;</span><br><span class="line">			el:&#x27;#app&#x27;,</span><br><span class="line">			data:&#123;</span><br><span class="line">				message:&quot;&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="②多复选框绑定"><a href="#②多复选框绑定" class="headerlink" title="②多复选框绑定"></a>②多复选框绑定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example-checkboxs&quot; class=&quot;demo&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &#x27;#example-checkboxs&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            checkedNames: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h4 id="③单选按钮的绑定"><a href="#③单选按钮的绑定" class="headerlink" title="③单选按钮的绑定"></a>③单选按钮的绑定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		&lt;div id=&quot;exampleRadio&quot;&gt;</span><br><span class="line">			&lt;input type=&quot;radio&quot; id=&quot;runoob&quot; value=&quot;Runoob&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">			&lt;lable for=&quot;runoob&quot;&gt;Runoob&lt;/lable&gt;</span><br><span class="line">			&lt;br&gt;</span><br><span class="line">			&lt;input type=&quot;radio&quot; id=&quot;google&quot; value=&quot;Google&quot; v-model=&quot;picked&quot;&gt;</span><br><span class="line">			&lt;lable for=&quot;google&quot;&gt;Google&lt;/lable&gt;</span><br><span class="line">			&lt;br&gt;</span><br><span class="line">			&lt;span&gt;选中值:&#123;&#123;picked&#125;&#125;&lt;/span&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​	</span><br><span class="line">​	&lt;script&gt;</span><br><span class="line">​	var app=new Vue(&#123;</span><br><span class="line">​		el:&#x27;#exampleRadio&#x27;,</span><br><span class="line">​		data:&#123;</span><br><span class="line">​			picked:&quot;Runoob&quot;</span><br><span class="line">​		&#125;</span><br><span class="line">​	&#125;)</span><br><span class="line">​	&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="④列表绑定"><a href="#④列表绑定" class="headerlink" title="④列表绑定"></a>④列表绑定</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div id=&quot;exampleSelected&quot;&gt;</span><br><span class="line">	&lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">		&lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;A&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;B&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;C&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;D&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	&lt;span&gt;Selected:&#123;&#123;selected&#125;&#125;&lt;/span&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app=new Vue(&#123;</span><br><span class="line">	el:&#x27;#exampleSelected&#x27;,</span><br><span class="line">	data:&#123;</span><br><span class="line">		selected:&#x27;&#x27;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h3 id="6-Vmodel修饰符"><a href="#6-Vmodel修饰符" class="headerlink" title="6.Vmodel修饰符"></a>6.Vmodel修饰符</h3><p>v-model.lazy:input事件触发后,输入框值与数据同步</p>
<p>v-model.number：将用户输入值转换为是值类型</p>
<p>v-model.trim:自动过滤用户输入的首尾空白字符</p>
<h2 id="四-生命周期"><a href="#四-生命周期" class="headerlink" title="四.生命周期"></a>四.生命周期</h2><p>1创造前beforeCreate和创造完毕状态Created</p>
<p><em><strong>初始化事件，进行数据观测,判断是否有el选项，进行编译</strong></em></p>
<p>2.挂载前beforeMount和挂载完毕状态Mounted</p>
<p><strong>给Vue实例添加$el成员,mounted钩子函数对数据进行实时渲染</strong></p>
<p>3.更新前beforeUpdate和更新完毕状态Updated</p>
<p><strong>当数据data发生改变，通过updated钩子函数进行组件重新渲染</strong></p>
<p>4.销毁前beforeDestroyed和销毁完成状态Destroyed</p>
<p><em><strong>在Vue实例化销毁后调用destroyed钩子函数，所有东西解除绑定，所有事件监听器会被移除，所有子实例也会被销毁</strong></em></p>
<h2 id="五-模板渲染"><a href="#五-模板渲染" class="headerlink" title="五.模板渲染"></a>五.模板渲染</h2><h3 id="1-条件渲染v-if-v-else-if-v-else"><a href="#1-条件渲染v-if-v-else-if-v-else" class="headerlink" title="1.条件渲染v-if v-else-if v-else"></a>1.条件渲染v-if v-else-if v-else</h3><p>v-if v-else-if v-else后接表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; &gt;</span><br><span class="line">    &lt;!--if、else、指令--&gt;</span><br><span class="line">	&lt;select v-model=&quot;status&quot;&gt;</span><br><span class="line">		&lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;1&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;2&lt;/option&gt;</span><br><span class="line">		&lt;option&gt;3&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">    &lt;p v-if=&quot;status==1&quot;&gt;当status为1时，显示该行zyc&lt;/p&gt;</span><br><span class="line">    &lt;p v-else-if=&quot;status==2&quot;&gt;当status为2时，显示该行zzz&lt;/p&gt;</span><br><span class="line">    &lt;p v-else-if=&quot;status==3&quot;&gt;当status为3时，显示该行eee&lt;/p&gt;</span><br><span class="line">    &lt;p v-else&gt;否则显示该行&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--script脚本--&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //创建vue实例</span><br><span class="line">    var  vm=new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            status: 1,</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-列表渲染"><a href="#2-列表渲染" class="headerlink" title="2.列表渲染"></a>2.列表渲染</h3><p>v-for循环基于数组用于渲染一个列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;ul id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm= new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                items: [</span><br><span class="line">                    &#123; name: &#x27;beixi&#x27; &#125;,</span><br><span class="line">                    &#123; name: &#x27;jzj&#x27; &#125;</span><br><span class="line">            ]</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;) --&gt;</span><br><span class="line"></span><br><span class="line">v-for可通过一个对象的属性来遍历输出结果</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;ul id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;value in object&quot;&gt;</span><br><span class="line">        &#123; &#123; value &#125; &#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm=new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                object: &#123;</span><br><span class="line">                    name: &#x27;beixi&#x27;,</span><br><span class="line">                    gender: &#x27;男&#x27;,</span><br><span class="line">                    age: 30</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;) </span><br></pre></td></tr></table></figure>
<p>​        </p>
<h3 id="3-template标签用法"><a href="#3-template标签用法" class="headerlink" title="3.template标签用法"></a>3.template标签用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--html中修改的--&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;message + &#x27;这是在outer HTML中的&#x27;&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">    template: &quot;&lt;h1&gt;&#123;&#123;message +&#x27;这是在template中的&#x27;&#125;&#125;&lt;/h1&gt;&quot;, //在vue配置项中修改的</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &#x27;Vue的生命周期&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<h2 id="六-事件绑定"><a href="#六-事件绑定" class="headerlink" title="六.事件绑定"></a>六.事件绑定</h2><p><em><strong>Vue中的事件绑定: 使用 v - on:事件名.修饰符 = 方法名() |方法名 |简单的JS表达式</strong></em></p>
<p><em><strong>简写: @事件名.修饰符 = 方法名() |方法名 |简单的 JS表达式</strong></em></p>
<p><em><strong>事件名: click | keydown | keyup | mouseover | mouseout |自定义事件名</strong></em></p>
<p>数据放入Vue的data中</p>
<p>方法函数则放入method中定义</p>
<p>computed只有一个用于计算属性</p>
<h3 id="1-直接使用"><a href="#1-直接使用" class="headerlink" title="1.直接使用"></a>1.直接使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;say&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm= new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">       data:&#123;</span><br><span class="line">           msg:&#x27;Say Hello&#x27;</span><br><span class="line">       &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            say: function () &#123;</span><br><span class="line">                alert(this.msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt; --&gt;</span><br><span class="line"></span><br><span class="line">#### 传入参数</span><br><span class="line"></span><br><span class="line">&lt;!-- &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;say(&#x27;hello zyc&#x27;)&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm= new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">       data:&#123;</span><br><span class="line">           msg:&#x27;Say Hello&#x27;</span><br><span class="line">       &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            say: function (val) &#123;</span><br><span class="line">                alert(val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) --&gt;</span><br></pre></td></tr></table></figure>
<h4 id="传入对象"><a href="#传入对象" class="headerlink" title="传入对象"></a>传入对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var vm= new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">       data:&#123;</span><br><span class="line">           msg:&#x27;Say Hello&#x27;</span><br><span class="line">       &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">           eventFn:function(e)</span><br><span class="line">		   &#123;</span><br><span class="line">			 console.log(e);</span><br><span class="line">			  //e.srcElement,DOM节点</span><br><span class="line">			 e.srcElement.style.background = &#x27;red&#x27;;</span><br><span class="line">			 console.log(e.srcElement.dataset.aid);</span><br><span class="line">			 /*获取自定义属性的值*/</span><br><span class="line">		   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-v-on修饰符"><a href="#2-v-on修饰符" class="headerlink" title="2.v-on修饰符"></a>2.v-on修饰符</h3><p>(1).stop阻止事件继续传播</p>
<p>(2).prevent组织默认事件</p>
<p>(3).capture添加事件监听器时使用事件捕获模式</p>
<p>(4).self当前元素自身是触发处理函数时才会触发函数</p>
<p>(5).once只会触发一次</p>
<p>(6)@keydown键盘事件</p>
<h2 id="七-自定义指令"><a href="#七-自定义指令" class="headerlink" title="七.自定义指令"></a>七.自定义指令</h2><h2 id="八-组件props"><a href="#八-组件props" class="headerlink" title="八.组件props"></a>八.组件props</h2><h3 id="1-组件的基本使用"><a href="#1-组件的基本使用" class="headerlink" title="1.组件的基本使用"></a>1.组件的基本使用</h3><h4 id="1-全局注册"><a href="#1-全局注册" class="headerlink" title="(1)全局注册"></a>(1)全局注册</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.componet(&#x27;my-component&#x27;,&#123;</span><br><span class="line"></span><br><span class="line">//选项</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">使用: &lt;my-componet&gt;&lt;/my-componet&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-局部注册"><a href="#2-局部注册" class="headerlink" title="(2)局部注册"></a>(2)局部注册</h4><figure class="highlight plaintext"><figcaption><span><div id</span></figcaption><table><tr><td class="code"><pre><span class="line">    &lt;account&gt;&lt;/account&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 创建 Vue 实例,得到 ViewModel</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line">        components: &#123; // 定义子组件</span><br><span class="line">            account: &#123; // account 组件</span><br><span class="line">                template: &#x27;&lt;div&gt;&lt;h1&gt;这是Account组&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&#x27;,                            // 在这里使用定义的子组件</span><br><span class="line">                components: &#123; // 定义子组件的子组件</span><br><span class="line">                    login: &#123; // login 组件</span><br><span class="line">                        template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt; --&gt;</span><br></pre></td></tr></table></figure>


<p>(3)动态props</p>
<p>把父组件的数据动态绑定到子模板的props中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;parentMessage&quot;&gt;</span><br><span class="line">    &lt;my-componet :message=&quot;parentMessage&quot;&gt;&lt;/my-componet&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    Vue.component(&#x27;my-componet&#x27;, &#123;</span><br><span class="line">        props: [&#x27;message&#x27;],</span><br><span class="line">        template: &#x27;&lt;span&gt;&#123; &#123; message &#125; &#125;&lt;/span&gt;&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&#x27;#app&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            parentMessage:&#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt; --&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2与vue3共存</title>
    <url>/2021/08/12/vue2%E4%B8%8Evue3%E5%85%B1%E5%AD%98/</url>
    <content><![CDATA[<h2 id="一、安装vue-cli脚手架"><a href="#一、安装vue-cli脚手架" class="headerlink" title="一、安装vue-cli脚手架"></a>一、安装vue-cli脚手架</h2>  <span id="more"></span>

<p>（1）首先建立一个存放vue版本的文件夹，分别对应vue2和vue3</p>
<p> （2）然后进入vue3文件夹，直接在他的地址栏进行cmd回车，并执行安装命令<br> 使用vue3必须确保@vue-cli版本在4.5.0以上，因此我们默认安装最新版本即可</p>
<p> 在要安装的文件夹中下面命令不要加 -g，不然就是全局安装了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install @vue/cli</span><br></pre></td></tr></table></figure>


<p>此时默认安装的就是最新版本的脚手架。</p>
<p>我安装完成之后是5.0.6版本</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923195904499.png" alt="image-20220923195904499"></p>
<p> （3）安装vue2脚手架<br>同理，这里我们指定版本安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-cli@2.9.6</span><br></pre></td></tr></table></figure>

<p> （4）分别查看是否安装成功<br>分别进入  \vue_version\vue2\node_modules.bin 路径下找到vue的命令脚本文件</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923195925877.png" alt="image-20220923195925877"></p>
<p> 直接拖入cmd窗口，再加上–version，查看版本号</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923195932749.png" alt="image-20220923195932749"></p>
<p> 此时可看到vue2对应的脚手架安装成功。</p>
<p>查看版本3同理，</p>
<p> 均安装成功。</p>
<h2 id="二、修改名称"><a href="#二、修改名称" class="headerlink" title="二、修改名称"></a>二、修改名称</h2><p>（1）找到.bin文件夹下的vue 和vue.cmd 文件，分别改名为vue2和vue2.cmd，下面是改好的样子</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923195940378.png" alt="image-20220923195940378"></p>
<p> （2）找到.bin文件夹下的vue 和vue.cmd 文件，分别改名为vue3和vue3.cmd，下面是改好的样子<br>vue3也是同上。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923195949303.png" alt="image-20220923195949303"></p>
<h2 id="三、最后一步，配置环境变量，实现全局调用"><a href="#三、最后一步，配置环境变量，实现全局调用" class="headerlink" title="三、最后一步，配置环境变量，实现全局调用"></a>三、最后一步，配置环境变量，实现全局调用</h2><p>（1）右键我的电脑 — 属性 — 高级系统配置 — 环境变量</p>
<p> （2）新建环境变量，目的是把我们的vue2和vue3的命令添加进去。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923195959560.png" alt="image-20220923195959560"></p>
<p> （3）同理，vue2也是如此</p>
<p>点击确定，查看，可以看到添加成功。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923200007430.png" alt="image-20220923200007430"></p>
<p> （4）修改path变量<br>双击path出现左边弹框。 </p>
<p> 点击新建，输入以%包裹的变量名，中间的变量名就是你新建的环境变量。头尾分别加上%，别搞错哈。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923200014959.png" alt="image-20220923200014959"></p>
<p> 注意：win10电脑追加path是上面所述，不是win10的话，直接在path后面用分号隔开追加<br> 例如：;%VUE_CLI2%;%VUE_CLI3%</p>
<h2 id="四、重启电脑就可以了。"><a href="#四、重启电脑就可以了。" class="headerlink" title="四、重启电脑就可以了。"></a>四、重启电脑就可以了。</h2><p>配置环境变量的目的就是为了让Path找到vue所在的文件路径而已，而我们前面修改的文件名vue2、vue3，就决定了我们全局使用的时候的名称。可自行定义。</p>
<h2 id="五、配置完成之后我们来创建vue2和vue3项目"><a href="#五、配置完成之后我们来创建vue2和vue3项目" class="headerlink" title="五、配置完成之后我们来创建vue2和vue3项目"></a>五、配置完成之后我们来创建vue2和vue3项目</h2><p>此时我们就可以用全局变量查看vue2和vue3的版本号 ，直接vue2 -V 或 vue2 –version 就可以查看</p>
<p>（1）我们再新建一个文件夹叫vue3项目搭建</p>
<p> 在此处进行cmd，利用vue3创建项目的新命令vue3 create testvue3（自定义文件名）</p>
<p>回车后出现下图，我们选择vue3，然后回车。</p>
<p> 此时我们的vue3项目就创建好了</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/vue3create.png" alt="vue3create"></p>
<p> （2）同理，vue2创建的时候就不能用create命令，他会提示这是vue3的命令，并且你的cli版本是2.9.6，也不符合vue3要求。</p>
<p> 因此我们就需要用，vue2的原始命令创建 vue2 init webpack testvue</p>
<p> 按照常规，需要选一堆设置</p>
<p>vue2项目也安装成功</p>
<h2 id="六、对比vue2和vue3项目结构"><a href="#六、对比vue2和vue3项目结构" class="headerlink" title="六、对比vue2和vue3项目结构"></a>六、对比vue2和vue3项目结构</h2><p>打开testvue2和testvue3项目，可见vue3项目结构确实精简了许多，看着比较舒服</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/comparevue.png" alt="comparevue"><br>参考原文链接：<a href="https://blog.csdn.net/qq_41579104/article/details/121553469">https://blog.csdn.net/qq_41579104/article/details/121553469</a></p>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a><strong>什么是设计模式？</strong></h3><p>参考来源于 鱼皮 <a href="https://mp.weixin.qq.com/s/11HvyNLC4_GPICVG0BufDA">https://mp.weixin.qq.com/s/11HvyNLC4_GPICVG0BufDA</a></p>
<p>设计模式是我们开发软件时针对常见问题的 <strong>通用</strong> 解决方案，也是前辈们在写代码时不断摸索总结出来的好方法。</p>
<p>可以理解为打游戏的攻略，就是我们遇到同一类的对手时，怎么走位、怎么放技能之类的。</p>
<h3 id="设计模式有什么用？"><a href="#设计模式有什么用？" class="headerlink" title="设计模式有什么用？"></a><strong>设计模式有什么用？</strong></h3><p>设计模式最直接的作用就是 <strong>减少烂代码、让项目代码更好维护</strong> 。</p>
<p>举个栗子，如果没学过设计模式，可能随着产品不断加需求、改需求，你的代码会充满大量的 if else，新同事来了呢，也不敢动前人代码，只能再去补充 if else，于是屎山越堆越高。</p>
<p>而使用设计模式后，你可以把每段逻辑单独封装和维护，大家协作开发也会更高效。</p>
<h3 id="为什么要学设计模式？"><a href="#为什么要学设计模式？" class="headerlink" title="为什么要学设计模式？"></a><strong>为什么要学设计模式？</strong></h3><p>学好设计模式，不仅能让我们写出更好维护、性能更高的代码，还能开拓我们的思维，在遇到问题时能想到更多的解决方案。</p>
<p>因此设计模式也是软件开发岗面试的重点，想进大厂的同学一定要学习它。</p>
<p>此外，很多知名项目都用到了大量的设计模式，比如 Spring、MyBatis 等。如果不学习它，可能你天天写代码都是 CRUD、读别人的源码会非常吃力。</p>
<p>所以建议开发岗的朋友们都要认真学习设计模式。</p>
<h3 id="什么时候学？"><a href="#什么时候学？" class="headerlink" title="什么时候学？"></a><strong>什么时候学？</strong></h3><p>我建议大家在学过一门编程语言、并且能够使用开发框架去完成项目之后，再去学设计模式。如果你写代码的熟练度还不够的话，直接去学设计模式会比较吃力，可能也无法理解用设计模式的好处。</p>
<p>那如果你学前端的话，我建议你先把界面开发、JS 语法、组件库和 Vue / React 之类的框架运用熟练，有空了再把设计模式作为进阶知识来学习就好。</p>
<h3 id="要学什么？"><a href="#要学什么？" class="headerlink" title="要学什么？"></a><strong>要学什么？</strong></h3><p>设计模式的学习主要分为两部分：</p>
<h4 id="1-软件开发原则"><a href="#1-软件开发原则" class="headerlink" title="1. 软件开发原则"></a>1. 软件开发原则</h4><p>所有的设计模式基本都是建立以下几个软件开发原则的基础上。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUGiaj4F3X65ibqWtvvr8ewltMWCHhOY4UaWONzsRmCMXclP2Z4ibSU29OA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>比如开闭原则，就是建议我们把模块设计的好扩展一些，每次新增功能只需要加代码、而不用改老代码。</p>
<h4 id="2-学习主流设计模式"><a href="#2-学习主流设计模式" class="headerlink" title="2. 学习主流设计模式"></a>2. 学习主流设计模式</h4><p>主流的设计模式共有以下 23 种：</p>
<blockquote>
<p>注意，不是说设计模式只有 23 种！</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUGD8HznaJGEEHPPnYINalq6ZCnkvGJu5JbhmyhicmYu3LMibJzvaibjBMw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">设计模式学习路线 by 程序员鱼皮</p>
<p>其中单例、工厂方法、建造者、适配器、装饰器、代理、策略、责任链、观察者、迭代器模式是重点，我自己工作中经常用到这些、也总能在框架源码中见到它们。这些设计模式的特色也比较鲜明、相对比较好理解。</p>
<p>尤其是单例模式，是重点中的重点！它有很多种不同的实现方式，都要了解。我用的最多的应该是饿汉式还有双检锁模式。</p>
<h2 id="设计模式学习路线"><a href="#设计模式学习路线" class="headerlink" title="设计模式学习路线"></a>设计模式学习路线</h2><p>建议大家按照以下 3 个阶段来学习：</p>
<h3 id="一、基础学习"><a href="#一、基础学习" class="headerlink" title="一、基础学习"></a><strong>一、基础学习</strong></h3><p>目标：从上面提到的重点开始依次了解每一种设计模式的概念、作用、应用场景、特点、类和对象的关系，能够对设计模式有个基础的印象。</p>
<p>学习方式有很多种：</p>
<ul>
<li>喜欢看视频的同学挑个高播放量的、讲师口音能接受的教程看就好了；</li>
<li>喜欢读书的同学可以看《图解设计模式》、《大话设计模式》，个人感觉这两本书都还不错，我自己是看前者入门的。</li>
<li>想快速上手的同学可以直接看菜鸟教程的文档，每个设计模式都有讲解和代码示例，还是比较推荐的。像我有的时候忘了某个冷门的设计模式，也是靠这个文档快速补回来。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUoEghice0Xw5JK6pzgtSGeDMia37vWTawESNLBTibAbQp5sjAEHBxF3rGQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这里建议大家在学设计模式的时候多和实际生活结合，会更好理解一些。</p>
<p>比如适配器模式可以理解为用一个转接头连接两根线；代理模式理解为你找了个代购帮你去买东西；责任链模式理解为公司出了问题，员工依次甩锅。</p>
<h3 id="二、编码实现"><a href="#二、编码实现" class="headerlink" title="二、编码实现"></a><strong>二、编码实现</strong></h3><p>这个阶段的目标是：用你熟悉的编程语言来写代码实现每个设计模式，要能够独立（不借助任何资料）从 0 写出完整代码，这样才算是学会了。</p>
<p>如果刚开始大家不知道设计模式怎么应用的话，我建议去看一些示例代码。</p>
<p>可以直接在 GitHub 搜索关键词 <code>Design Pattern</code> 或 <code>设计模式</code> ，就能搜出来一大堆不同语言的代码了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUx4hOjIG7YuicA90Qf3EfAfuwOdicw4hZ9LibxavC8tgfmK4aCcLSiayqTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>那我建议大家把自己写过的代码保存好，可以打造一个自己的设计模式代码库，写在简历上也是能加分的。</p>
<h3 id="三、项目实战"><a href="#三、项目实战" class="headerlink" title="三、项目实战"></a><strong>三、项目实战</strong></h3><p>本阶段的目标：能够根据某个场景主动选出合适的设计模式来优化代码，而不是说别人告诉你这里能用设计模式，你才想起来去用。这就是架构师和拧螺丝的区别。</p>
<p>这里给大家两个学习方法吧：</p>
<h4 id="1-搜索式"><a href="#1-搜索式" class="headerlink" title="1. 搜索式"></a>1. 搜索式</h4><p>花时间到网上搜设计模式在知名框架中的应用，比如 Spring：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/mngWTkJEOYLshyBE3PzUib850OYI6tNOUUAtlj0D4CfxNo6iavbExxzkAJefNFLiaJBlQfPRKUMtybcNwr1eRGYBg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>网上的文章很多，我就不一一列举了。比较建议大家在面试前这么干，可以快速积累。</p>
<h4 id="2-探索式"><a href="#2-探索式" class="headerlink" title="2. 探索式"></a>2. 探索式</h4><p>就是在你写代码的过程中，一旦遇到重复代码，就问一下自己：我能不能用上某个设计模式呢？合适的话就使用设计模式。次数多了，你就有经验了。</p>
<p>此外，我自己在写代码时，特别喜欢点进源码看一看，一般是能够通过文件命名来快速判断出它是否使用了设计模式的，然后你就可以进一步读源码来学习，帮助我积累了很多知识。</p>
<p>但我们也要注意，设计模式虽然好用，但它不是银弹，不要为了用而用。</p>
<p>比如非要把一句简单的 if else 搞成策略模式，过分使用设计模式只会徒增系统的复杂度。</p>
<h3 id="面试考点"><a href="#面试考点" class="headerlink" title="面试考点"></a><strong>面试考点</strong></h3><p>面试时对设计模式的考察可能比较多元，主要有理论、实践、源码等考法：</p>
<p>理论就是问你不同设计模式的概念、优缺点、应用场景，设计模式之间的区别等等。</p>
<p>实践就是让你手写某个设计模式。最常考的就是单例模式，我就被考过，当时还让我写出几种不同的单例模式实现。</p>
<p>源码就是说问你某个框架用了哪些设计模式，或者某个设计模式在哪些框架中应用过。如果我是面试官，大概率会这么考，因为能看出候选人的知识储备。</p>
<p>所以要想在设计模式这块不吃瘪，除了背八股文外，还是要保证能手写出常考的设计模式，并且多去了解一下它在知名项目中的应用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/0202/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8(Spring)/</url>
    <content><![CDATA[<h1 id="设计模式的应用-Spring"><a href="#设计模式的应用-Spring" class="headerlink" title="设计模式的应用(Spring)"></a>设计模式的应用(Spring)</h1><p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/springdesign.png" alt="springdesign"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>vue入门学习</title>
    <url>/2021/11/20/vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ul>
<li><input disabled="" type="checkbox"> <h1 id="vue入门学习"><a href="#vue入门学习" class="headerlink" title="vue入门学习"></a>vue入门学习</h1></li>
</ul>
<h2 id="1-MVVM-框架"><a href="#1-MVVM-框架" class="headerlink" title="1.MVVM 框架"></a>1.MVVM 框架</h2><ul>
<li><p>M:model</p>
<p>数据层（存储数据及对数据的处理如增删改查）</p>
<span id="more"></span></li>
<li><p>V：view</p>
<p>视图层(UI用户界面)</p>
</li>
<li><p>VM： ViewModel</p>
<p>业务逻辑层（一切 js 可视为业务逻辑）,及时修改，及时编译，双向绑定了View层和Model层</p>
</li>
<li><p>v-model 双向绑定的演示</p>
<p>（1）引入vue.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>(2) html代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    输入的文本：&lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &#123; &#123;message&#125; &#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message: &quot;123&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>（3）演示view的改变，导致model层的改变</p>
<p><img src="https://cdn.jsdelivr.net/gh/bomingxu/picgo/image/20210623140245.png" alt="image-20210623140245731"></p>
</li>
</ul>
<h2 id="2-vue的七大属性"><a href="#2-vue的七大属性" class="headerlink" title="2.vue的七大属性"></a>2.vue的七大属性</h2><ul>
<li><p>el属性</p>
<p>用来指示vue编译器从什么地方开始解析 vue的语法，可以说是一个占位符。</p>
</li>
<li><p>data属性</p>
<p>用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放在data中。</p>
</li>
<li><p>template属性</p>
<p>用来设置模板，会替换页面元素，包括占位符。</p>
</li>
<li><p>methods属性</p>
<p>放置页面中的业务逻辑，js方法一般都放置在methods中</p>
</li>
<li><p>render属性</p>
<p>创建真正的Virtual Dom</p>
</li>
<li><p>computed属性</p>
<p>用来计算</p>
</li>
<li><p>watch属性</p>
<p>watch:function(new,old){}</p>
<p>监听data中数据的变化</p>
<p>两个参数，一个返回新值，一个返回旧值</p>
</li>
</ul>
<h2 id="3-vue的基本语法"><a href="#3-vue的基本语法" class="headerlink" title="3. vue的基本语法"></a>3. vue的基本语法</h2><h3 id="3-1-v-if-v-else-if-v-else"><a href="#3-1-v-if-v-else-if-v-else" class="headerlink" title="3.1 v-if v-else-if v-else"></a>3.1 v-if v-else-if v-else</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;type===&#x27;A&#x27;&quot;&gt;A&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else-if=&quot;type===&#x27;B&#x27;&quot;&gt;B&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;C&lt;/h1&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">    type: &#x27;A&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-v-for"><a href="#3-2-v-for" class="headerlink" title="3.2 v-for"></a>3.2 v-for</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li v-for=&quot;(item,index) in items&quot;&gt;&#123; &#123;index&#125; &#125; &#123; &#123;item.message&#125; &#125;&lt;/li&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">        &#123;message: &#x27;kuansheng说java&#x27;&#125;,</span><br><span class="line">        &#123;message: &#x27;kuansheng说vue&#x27;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-vue绑定事件"><a href="#3-2-vue绑定事件" class="headerlink" title="3.2 vue绑定事件"></a>3.2 vue绑定事件</h3><ul>
<li>v-on 绑定方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;sayHi&quot;&gt;Click Me&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg333: &quot;Hello&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            sayHi:function(event)&#123;</span><br><span class="line">                alert(this.msg333);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-model 双向绑定</li>
</ul>
<p>(1) 单选框</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    性别：</span><br><span class="line">    &lt;input type=&quot;radio&quot; value=&quot;男&quot; v-model=&quot;sex&quot;&gt;男</span><br><span class="line">    &lt;input type=&quot;radio&quot; value=&quot;女&quot; v-model=&quot;sex&quot;&gt;女</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    你选择了：&#123; &#123;sex&#125; &#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            sex: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>(2) 下拉框</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    下拉框：</span><br><span class="line">    &lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;&quot; disabled&gt;---请选择---&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;A&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;B&lt;/option&gt;</span><br><span class="line">        &lt;option&gt;C&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &#123; &#123;selected&#125; &#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            selected: &quot;A&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-bind 绑定数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input v-bind:value=message /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message: &#x27;hello&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-组件化构建"><a href="#4-组件化构建" class="headerlink" title="4. 组件化构建"></a>4. 组件化构建</h2><h3 id="4-1-组件化的概念"><a href="#4-1-组件化的概念" class="headerlink" title="4.1 组件化的概念"></a>4.1 组件化的概念</h3><p> 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/bomingxu/picgo/image/20210623140713.png" alt="image-20210623140713502"></p>
<h3 id="4-2-构建一个简单的组件"><a href="#4-2-构建一个简单的组件" class="headerlink" title="4.2 构建一个简单的组件"></a>4.2 构建一个简单的组件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;    &lt;xbm v-for=&quot;item in items&quot; :project=&quot;item&quot;&gt;&lt;/xbm&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    Vue.component(&quot;xbm&quot;,&#123;        props:[&#x27;project&#x27;],        template: &#x27;&lt;li&gt;&#123; &#123;project&#125; &#125;&lt;/li&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el: &quot;#app&quot;,        data:&#123;            items:[&quot;java&quot;,&quot;vue&quot;,&quot;linux&quot;],            message: &#x27;hello&#x27;        &#125;    &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-axios-通讯"><a href="#5-axios-通讯" class="headerlink" title="5. axios 通讯"></a>5. axios 通讯</h2><p> 由于vue是一个视图层框架，并且作为严格遵守SOC（关注度分离原则）所以vue.js并不包括ajax通信功能，为了解决通信问题，作者单独开发了一个名叫vue-resouce的插件，不过在进入2.0版本后停止了对该插件的维护，并推荐了Axois框架。少用jquery，因为操作dom过于频繁。</p>
<ul>
<li>模拟数据 data.json</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;  &quot;name&quot;: &quot;xbm&quot;,  &quot;url&quot;: &quot;www.baidu.com&quot;,  &quot;page&quot;: 1,  &quot;isNonProfit&quot;: true,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;含光门&quot;,    &quot;city&quot;: &quot;陕西西安&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;,  &quot;links&quot;:[&#123;    &quot;name&quot;: &quot;bilibili&quot;,    &quot;url&quot;: &quot;https://space.bilibili.com/95256449&quot;  &#125;,    &#123;      &quot;name&quot;: &quot;狂神说java&quot;,      &quot;url&quot;: &quot;https://blog.kuanngstudy.com&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;百度&quot;,      &quot;url&quot;: &quot;https://www.baidu.com/&quot;    &#125;  ]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>html代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;    //解决闪烁问题    [v-clock]&#123;        display:none;    &#125;&lt;/style&gt;&lt;div id=&quot;app&quot; v-clock&gt;    &lt;div&gt;&#123; &#123;info.name&#125; &#125;&lt;/div&gt;    &lt;div&gt;&#123; &#123;info.address.city&#125; &#125;&lt;/div&gt;    &lt;a v-bind:href=&quot;info.url&quot;&gt;click me&lt;/a&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue(&#123;        el: &quot;#app&quot;,        data()&#123;            return&#123;                info:  &#123;                    name:null,                    url:null,                    address:&#123;                        street:null,                        city:null,                        country:null                    &#125;                &#125;            &#125;        &#125;,        mounted()&#123;//钩子函数 链式编程            axios.get(&#x27;../data.json&#x27;).then(response=&gt;(this.info=response.data));        &#125;    &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>使用钩子函数mounted方法，在vue实例挂载的时候将json里的数据，加到示例的data函数的info属性中，利用mounted会将el替换成实例下的el的特性，把数据渲染到我们的app中</strong></p>
<h2 id="6-computed-计算属性"><a href="#6-computed-计算属性" class="headerlink" title="6. computed 计算属性"></a>6. computed 计算属性</h2><p>我们的vue对象中有一个属性，使用缓存来 将不经常变化的属性的结果缓存，下一次可以不用重复，直接从内存中调取，节省系统的资源开销<br>注意事项：</p>
<ul>
<li>methods computed不能重名，重名之后会有优先级问题，method优先级高</li>
</ul>
<p>特性：</p>
<ul>
<li>作用于缓存中，和mybatis十分相似,一旦内部有属性变化就会立刻刷新</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; v-clock&gt;    Now:&#123; &#123;getTime()&#125; &#125;    Now2:&#123; &#123;getTime2&#125; &#125;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    var vm = new Vue(&#123;        el: &quot;#app&quot;,        data:&#123;            message:&#x27;123&#x27;        &#125;,        methods:&#123;            getTime:function()&#123;                return Date.now();            &#125;        &#125;,        computed:&#123;            getTime2:function()&#123;                this.message;                return Date.now();            &#125;        &#125;    &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="7-插槽"><a href="#7-插槽" class="headerlink" title="7. 插槽"></a>7. 插槽</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;    &lt;to_do&gt;        &lt;to_title slot=&quot;to_title&quot; v-bind:title=&quot;title&quot;&gt;&lt;/to_title&gt;        &lt;to_items slot=&quot;to_items&quot; v-for=&quot;item in todoItems&quot; v-bind:item=&quot;item&quot;&gt;        &lt;/to_items&gt;    &lt;/to_do&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    Vue.component(&quot;to_do&quot;,&#123;        template: &#x27;&lt;div&gt;&#x27; +                    &#x27;&lt;slot name=&quot;to_title&quot;&gt;&lt;/slot&gt;&#x27;+                    &#x27;&lt;ul&gt;&#x27; +                        &#x27;&lt;slot name=&quot;to_items&quot;&gt;&lt;/slot&gt;&#x27;+                    &#x27;&lt;/ul&gt;&#x27;+                  &#x27;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;to_title&quot;,&#123;        props: [&#x27;title&#x27;],        template: &#x27;&lt;p&gt;&#123; &#123;title&#125; &#125;&lt;/p&gt;&#x27;    &#125;);    Vue.component(&quot;to_items&quot;,&#123;        props: [&#x27;item&#x27;],        template: &#x27;&lt;li&gt;&#123; &#123;item&#125; &#125;&lt;/li&gt;&#x27;    &#125;);    var vm = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            title: &#x27;课程列表&#x27;,            todoItems: [&#x27;kuansheng说java&#x27;,&#x27;kuansheng说vue&#x27;]        &#125;    &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="8-自定义事件分发"><a href="#8-自定义事件分发" class="headerlink" title="8. 自定义事件分发"></a>8. 自定义事件分发</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;    &lt;to_do&gt;        &lt;to_title slot=&quot;to_title&quot; v-bind:title=&quot;title&quot;&gt;&lt;/to_title&gt;        &lt;to_items slot=&quot;to_items&quot; v-for=&quot;(item,index) in todoItems&quot; v-bind:item=&quot;item&quot;                  :index=&quot;index&quot; v-on:remove2=&quot;removeItem(index)&quot;&gt;&lt;/to_items&gt;    &lt;/to_do&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    Vue.component(&quot;to_do&quot;,&#123;        template: &#x27;&lt;div&gt;&#x27; +                    &#x27;&lt;slot name=&quot;to_title&quot;&gt;&lt;/slot&gt;&#x27;+                    &#x27;&lt;ul&gt;&#x27; +                        &#x27;&lt;slot name=&quot;to_items&quot;&gt;&lt;/slot&gt;&#x27;+                    &#x27;&lt;/ul&gt;&#x27;+                  &#x27;&lt;/div&gt;&#x27;    &#125;);    Vue.component(&quot;to_title&quot;,&#123;        props: [&#x27;title&#x27;],        template: &#x27;&lt;p&gt;&#123; &#123;title&#125; &#125;&lt;/p&gt;&#x27;    &#125;);    Vue.component(&quot;to_items&quot;,&#123;        props: [&#x27;item&#x27;,&#x27;index&#x27;],        template: &#x27;&lt;li&gt;&#123; &#123;item&#125; &#125; &lt;button @click=&quot;remove&quot;&gt;删除&lt;/button&gt;&lt;/li&gt;&#x27;,        methods:&#123;            remove:function (index) &#123;                this.$emit(&#x27;remove2&#x27;,index);            &#125;        &#125;    &#125;);    var vm = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            title: &#x27;课程列表&#x27;,            todoItems: [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]        &#125;,        methods:&#123;            removeItem:function(index)&#123;                this.todoItems.splice(index,1);            &#125;        &#125;    &#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/06/15/kuangstudy406de86d-2721-4155-b1ff-fef29c2405f2.png" alt="img"></p>
<h2 id="9-第一个vue-cli"><a href="#9-第一个vue-cli" class="headerlink" title="9. 第一个vue-cli"></a>9. 第一个vue-cli</h2><p>先安装node.js(<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a>)</p>
<ul>
<li><p>再安装vue-cli，管理员打开cmd,运行一下命令</p>
<p>npm install vue-cli -g 或 cnpm install vue-cli -g(推荐使用这个方法)</p>
</li>
<li><p>初始化第一个vue项目，在项目安放目录下运行一下命令</p>
<p>vue init webpack myvue(项目名称)</p>
</li>
<li><p>进入项目中</p>
<p>cd myvue</p>
</li>
<li><p>安装依赖</p>
<p>npm install</p>
</li>
<li><p>启动命令</p>
<p>npm run dev</p>
</li>
</ul>
<h2 id="10、webpack-学习使用"><a href="#10、webpack-学习使用" class="headerlink" title="10、webpack 学习使用"></a>10、webpack 学习使用</h2><p> 作用是把ES6（少数浏览器支持，但开发必须用ES6）规范的代码打包编译成ES5(大多数浏览器支持)规范的代码运行。</p>
<ul>
<li><p>node.js遵循commons.js规范</p>
<p>export 暴露接口</p>
<p>import引用接口</p>
<p>require加载模块</p>
</li>
<li><p>安装</p>
<p>npm install webpack -g</p>
<p>npm install webpack-cli -g</p>
</li>
</ul>
<h5 id="10-1-使用webpack"><a href="#10-1-使用webpack" class="headerlink" title="10.1 使用webpack"></a>10.1 使用webpack</h5><ul>
<li>1.创建项目</li>
<li>2.创建一个名为modules的目录，用于存放JS模块等资源文件</li>
<li>3.在modules目录下创建模块文件，如hello.js,用于编写js模块相关代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//暴露一个方法</span><br><span class="line">exports.sayHi = function() &#123;</span><br><span class="line">    document.write(&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">exports.sayHi2 = function() &#123;</span><br><span class="line">    document.write(&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">exports.sayHi3 = function() &#123;</span><br><span class="line">    document.write(&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.在modules目录下创建main.js入口文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var hello = require(&quot;./hello&quot;);</span><br><span class="line">hello.sayHi();</span><br><span class="line">hello.sayHi2()</span><br></pre></td></tr></table></figure>

<ul>
<li>5.在根目录下创建 webpack.config.js 打包文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //入口</span><br><span class="line">    entry: &#x27;./modules/main.js&#x27;,</span><br><span class="line">    //输出</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &#x27;./js/bundle.js&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>6.输入打包命令 webpack</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/bomingxu/picgo/image/20210623140811.png" alt="image-20210623140811431"></p>
<ul>
<li>7.创建index.html文件。引入打包后的js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--引入打包后的js--&gt;</span><br><span class="line">&lt;script src=&quot;dist/js/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="11-vue路由-vue-router-（axios的安装同vue-router）"><a href="#11-vue路由-vue-router-（axios的安装同vue-router）" class="headerlink" title="11. vue路由 vue-router （axios的安装同vue-router）"></a>11. vue路由 vue-router （axios的安装同vue-router）</h2><ul>
<li><p>安装(在项目位置)</p>
<p>npm install vue-router —save-dev</p>
</li>
<li><p>引用vue-router</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">//显示声明vue-router</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>路由使用演示</li>
</ul>
<p>（1）创建两个组件，Main和Content</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;内容页&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Content&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>（2）创建一个路由文件夹router ,在其下面创建一个路由配置文件index.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">//导入组件</span><br><span class="line">import Content from &quot;../components/Content&quot;;</span><br><span class="line">import Main from &quot;../components/Main&quot;;</span><br><span class="line">//显示声明</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">//配置导出路由</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      //路由路径</span><br><span class="line">      path: &#x27;/content&#x27;,</span><br><span class="line">      //名字，自己取(可省略)</span><br><span class="line">      name: &#x27;content&#x27;,</span><br><span class="line">      //跳转组件</span><br><span class="line">      component: Content</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      //路由路径</span><br><span class="line">      path: &#x27;/main&#x27;,</span><br><span class="line">      //名字，自己取(可省略)</span><br><span class="line">      name: &#x27;main&#x27;,</span><br><span class="line">      //跳转组件</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(3) main.js中配置路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The Vue build version to load with the `import` command</span><br><span class="line">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import router from &#x27;./router&#x27; //自动扫描里面的路由</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">//显示声明vue-router</span><br><span class="line">Vue.use(router);</span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  //配置路由</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>(4) app.vue中展示不同的组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;vue-router&lt;/h1&gt;</span><br><span class="line">    &lt;router-link to=&quot;/main&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/content&quot;&gt;内容页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="12-vue-elementUI"><a href="#12-vue-elementUI" class="headerlink" title="12. vue+elementUI"></a>12. vue+elementUI</h2><ul>
<li><p>创建项目</p>
<p>//初始化项目</p>
<p>vue init webpack hello-vue</p>
<p>//进入项目</p>
<p>cd hello-vue</p>
<p>//安装 vue-router</p>
<p>npm install vue-router —save-dev</p>
<p>//安装elementUI</p>
<p>npm i element-ui -s</p>
<p>//安装依赖</p>
<p>npm install</p>
<p>//启动测试</p>
<p>npm run dev</p>
</li>
<li><p>登录页面 login.vue</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;login-container&quot;&gt;</span><br><span class="line">    &lt;el-form :model=&quot;ruleForm2&quot; :rules=&quot;rules2&quot;</span><br><span class="line">             status-icon</span><br><span class="line">             ref=&quot;ruleForm2&quot;</span><br><span class="line">             label-position=&quot;left&quot;</span><br><span class="line">             label-width=&quot;0px&quot;</span><br><span class="line">             class=&quot;demo-ruleForm login-page&quot;&gt;</span><br><span class="line">      &lt;h3 class=&quot;title&quot;&gt;系统登录&lt;/h3&gt;</span><br><span class="line">      &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">        &lt;el-input type=&quot;text&quot;</span><br><span class="line">                  v-model=&quot;ruleForm2.username&quot;</span><br><span class="line">                  auto-complete=&quot;off&quot;</span><br><span class="line">                  placeholder=&quot;用户名&quot;</span><br><span class="line">        &gt;&lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item prop=&quot;password&quot;&gt;</span><br><span class="line">        &lt;el-input type=&quot;password&quot;</span><br><span class="line">                  v-model=&quot;ruleForm2.password&quot;</span><br><span class="line">                  auto-complete=&quot;off&quot;</span><br><span class="line">                  placeholder=&quot;密码&quot;</span><br><span class="line">        &gt;&lt;/el-input&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-checkbox</span><br><span class="line">        v-model=&quot;checked&quot;</span><br><span class="line">        class=&quot;rememberme&quot;</span><br><span class="line">      &gt;记住密码&lt;/el-checkbox&gt;</span><br><span class="line">      &lt;el-form-item style=&quot;width:100%;&quot;&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot; style=&quot;width:100%;&quot; @click=&quot;handleSubmit&quot; :loading=&quot;logining&quot;&gt;登录&lt;/el-button&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                logining: false,</span><br><span class="line">                ruleForm2: &#123;</span><br><span class="line">                    username: &#x27;admin&#x27;,</span><br><span class="line">                    password: &#x27;123456&#x27;,</span><br><span class="line">                &#125;,</span><br><span class="line">                rules2: &#123;</span><br><span class="line">                    username: [&#123;required: true, message: &#x27;please enter your account&#x27;, trigger: &#x27;blur&#x27;&#125;],</span><br><span class="line">                    password: [&#123;required: true, message: &#x27;enter your password&#x27;, trigger: &#x27;blur&#x27;&#125;]</span><br><span class="line">                &#125;,</span><br><span class="line">                checked: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            handleSubmit(event)&#123;</span><br><span class="line">                this.$refs.ruleForm2.validate((valid) =&gt; &#123;</span><br><span class="line">                    if(valid)&#123;</span><br><span class="line">                        this.logining = true;</span><br><span class="line">                        if(this.ruleForm2.username === &#x27;admin&#x27; &amp;&amp;</span><br><span class="line">                            this.ruleForm2.password === &#x27;123456&#x27;)&#123;</span><br><span class="line">                            this.logining = false;</span><br><span class="line">                            sessionStorage.setItem(&#x27;user&#x27;, this.ruleForm2.username);</span><br><span class="line">                            this.$router.push(&#123;name: &#x27;main&#x27;,params:&#123;username:this.ruleForm2.username&#125; &#125;);</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            this.logining = false;</span><br><span class="line">                            this.$alert(&#x27;username or password wrong!&#x27;, &#x27;info&#x27;, &#123;</span><br><span class="line">                                confirmButtonText: &#x27;ok&#x27;</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        console.log(&#x27;error submit!&#x27;);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .login-container &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">  .login-page &#123;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    margin: 180px auto;</span><br><span class="line">    width: 350px;</span><br><span class="line">    padding: 35px 35px 15px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    border: 1px solid #eaeaea;</span><br><span class="line">    box-shadow: 0 0 25px #cac6c6;</span><br><span class="line">  &#125;</span><br><span class="line">  label.el-checkbox.rememberme &#123;</span><br><span class="line">    margin: 0px 0px 15px;</span><br><span class="line">    text-align: left;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>首页Main</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt;</span><br><span class="line">    &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;</span><br><span class="line">      &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;, &#x27;3&#x27;]&quot;&gt;</span><br><span class="line">        &lt;el-submenu index=&quot;1&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;&gt;用户管理&lt;/template&gt;</span><br><span class="line">          &lt;el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item index=&quot;1-1&quot;&gt;&lt;router-link to=&quot;/user/list&quot;&gt;用户列表&lt;/router-link&gt;&lt;/el-menu-item&gt;</span><br><span class="line">             &lt;!-- :to 绑定，name：路由器中的名字，params：传参 --&gt;</span><br><span class="line">            &lt;el-menu-item index=&quot;1-2&quot;&gt;&lt;router-link :to=&quot;&#123;name: &#x27;userProfile&#x27;,params: &#123; id: 123 &#125; &#125;&quot;&gt;个人信息&lt;/router-link&gt;&lt;/el-menu-item&gt;</span><br><span class="line">          &lt;/el-menu-item-group&gt;</span><br><span class="line">        &lt;/el-submenu&gt;</span><br><span class="line">        &lt;el-submenu index=&quot;2&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;&gt;系统管理&lt;/template&gt;</span><br><span class="line">          &lt;el-menu-item-group&gt;</span><br><span class="line">            &lt;el-menu-item index=&quot;2-1&quot;&gt;系统查看&lt;/el-menu-item&gt;</span><br><span class="line">            &lt;el-menu-item index=&quot;2-2&quot;&gt;系统设置&lt;/el-menu-item&gt;</span><br><span class="line">          &lt;/el-menu-item-group&gt;</span><br><span class="line">        &lt;/el-submenu&gt;</span><br><span class="line">      &lt;/el-menu&gt;</span><br><span class="line">    &lt;/el-aside&gt;</span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt;</span><br><span class="line">        &#123; &#123;username&#125; &#125;</span><br><span class="line">      &lt;/el-header&gt;</span><br><span class="line">      &lt;el-main&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;/el-main&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/el-container&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props: [&#x27;username&#x27;],</span><br><span class="line">        name: &quot;Main&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>404页面</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;404，你找的页面走丢了!&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .el-header &#123;</span><br><span class="line">    background-color: #B3C0D1;</span><br><span class="line">    color: #333;</span><br><span class="line">    line-height: 60px;</span><br><span class="line">  &#125;</span><br><span class="line">  .el-aside &#123;</span><br><span class="line">    color: #333;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;NotFound&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用户列表页面 user/UserList</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;用户列表 &lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;UserList&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>用户个人信息页面 user/UserProfile</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;用户个人信息&#123; &#123;id&#125; &#125;&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props: [&#x27;id&#x27;],</span><br><span class="line">        name: &quot;UserProfile&quot;,</span><br><span class="line">        //路由钩子</span><br><span class="line">        beforeRouteEnter:(to, from, next)=&gt;&#123;</span><br><span class="line">            console.log(&quot;进入路由之前&quot;);</span><br><span class="line">            next(vm=&gt;&#123;</span><br><span class="line">                vm.getData()</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        //路由钩子</span><br><span class="line">        beforeRouteLeave:(to, from, next) =&gt; &#123;</span><br><span class="line">            console.log(&quot;离开路由之前&quot;);</span><br><span class="line">            next();</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            //模拟获取后台数据</span><br><span class="line">            getData:function () &#123;</span><br><span class="line">                this.axios(&#123;</span><br><span class="line">                    method: &#x27;get&#x27;,</span><br><span class="line">                    url: &#x27;http://localhost:8080/static/mock/data.json&#x27;</span><br><span class="line">                &#125;).then(function (response)&#123;</span><br><span class="line">                    console.log(response.data);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由 index.js</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;;</span><br><span class="line">import Main from &quot;../components/Main&quot;;</span><br><span class="line">import Login from &quot;../components/Login&quot;</span><br><span class="line">import UserList from &quot;../components/user/UserList&quot;;</span><br><span class="line">import UserProfile from &quot;../components/user/UserProfile&quot;;</span><br><span class="line">import NotFound from &quot;../components/NotFound&quot;;</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">  mode: &#x27;history&#x27;,//去掉url中的/#/</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/main/:username&#x27;,</span><br><span class="line">      name: &#x27;main&#x27;,</span><br><span class="line">      component: Main,</span><br><span class="line">      props: true,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;/user/list&#x27;,</span><br><span class="line">          component: UserList,</span><br><span class="line">          props: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: &#x27;/user/profile/:id&#x27;,//id为参数 </span><br><span class="line">          name: &#x27;userProfile&#x27;,</span><br><span class="line">          component: UserProfile,</span><br><span class="line">          props: true</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/login&#x27;,</span><br><span class="line">      name: &#x27;login&#x27;,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;*&#x27;,</span><br><span class="line">      component: NotFound</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>main.js 代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The Vue build version to load with the `import` command</span><br><span class="line">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">//需要先安装axios  npm install axios</span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">//需先安装vue-axios npm install --save axios vue-axios</span><br><span class="line">import VueAxios from &quot;vue-axios&quot;;</span><br><span class="line">Vue.use(VueAxios, axios)</span><br><span class="line">Vue.use(router);</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟数据 data.json static/mock/data.json</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;  &quot;name&quot;: &quot;郑文杰&quot;,  &quot;url&quot;: &quot;www.baidu.com&quot;,  &quot;page&quot;: 1,  &quot;isNonProfit&quot;: true,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;含光门&quot;,    &quot;city&quot;: &quot;陕西西安&quot;,    &quot;country&quot;: &quot;中国&quot;  &#125;,  &quot;links&quot;:[&#123;    &quot;name&quot;: &quot;bilibili&quot;,    &quot;url&quot;: &quot;https://space.bilibili.com/95256449&quot;  &#125;,    &#123;      &quot;name&quot;: &quot;狂神说java&quot;,      &quot;url&quot;: &quot;https://blog.kuanngstudy.com&quot;    &#125;,    &#123;      &quot;name&quot;: &quot;百度&quot;,      &quot;url&quot;: &quot;https://www.baidu.com/&quot;    &#125;  ]&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>App.vue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;      &lt;!--显示路由的页面--&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#x27;App&#x27;,  components: &#123;  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>springcloud微服务</title>
    <url>/2021/07/12/springcloud/</url>
    <content><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><span id="more"></span>

<p>参考学习文件</p>
<p><strong>JAVA\Springcloud\spring-cloud-book-v1-master</strong></p>
<h2 id="一、注册中心-配置管理"><a href="#一、注册中心-配置管理" class="headerlink" title="一、注册中心/配置管理"></a>一、注册中心/配置管理</h2><h3 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h3><p>启动nacos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure>

<p>ndalone</p>
<p>nacos-springcloud-config</p>
<p>nacos配置管理</p>
<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/12.png" alt="12" style="zoom:50%;" />

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/11.png" alt="11"></p>
<p>nacos服务注册</p>
<p>nacos-springcloud-discovery</p>
<p>运行创建服务，可看见nacos面板显示服务example</p>
<p><img src="E:\大三学期\JAVA\Springcloud\springcloud微服务\14.png" alt="14"></p>
<p>nacos-springcloud-discovery-01</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/15.png" alt="15"></p>
<p>nacos-springcloud-discovery-02</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/16.png" alt="16"></p>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><h4 id="spring-cloud-concul-producer"><a href="#spring-cloud-concul-producer" class="headerlink" title="spring-cloud-concul-producer"></a>spring-cloud-concul-producer</h4><p>程序运行，consul服务发现并配置</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.png" alt="2"></p>
<h4 id="spring-cloud-concul-consumer"><a href="#spring-cloud-concul-consumer" class="headerlink" title="spring-cloud-concul-consumer"></a>spring-cloud-concul-consumer</h4><p>消费者获取生产者发送的消息</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.png" alt="4"></p>
<p>消费者获取生产者详细信息</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.png" alt="1"></p>
<p>消费者获取生产者信息 发现服务</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/5.png" alt="5"></p>
<p>当前运行的服务</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.png" alt="3"></p>
<h4 id="spring-cloud-consul-config"><a href="#spring-cloud-consul-config" class="headerlink" title="spring-cloud-consul-config"></a>spring-cloud-consul-config</h4><h2 id="二、微服务网关"><a href="#二、微服务网关" class="headerlink" title="二、微服务网关"></a>二、微服务网关</h2><h3 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h3><p>zuul-service</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/23.png" alt="23"></p>
<p>同时启动eureka、zuul-provider、zuul-consumer</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/24.png" alt="24"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/22.png" alt="22"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/21.png" alt="21"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/25.png" alt="25"></p>
<h3 id="spring-cloud-gateway"><a href="#spring-cloud-gateway" class="headerlink" title="spring cloud gateway"></a>spring cloud gateway</h3><ul>
<li>协议转换，路由转发</li>
<li>流量聚合，对流量进行监控，日志输出</li>
<li>作为整个系统的前端工程，对流量进行控制，有限流的作用</li>
<li>作为系统的前端边界，外部流量只能通过网关才能访问系统</li>
<li>可以在网关层做权限的判断</li>
<li>可以在网关层做缓存</li>
</ul>
<p>spring-cloud-gateway-01</p>
<p>访问9021/user/1的地址，请求被路由转发到8201/user/1</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/26.png" alt="26"></p>
<p>访问9021/user2/getUser的地址，请求被路由转发到8201/user2/getUser</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/27.png" alt="27"></p>
<h4 id="1-predicate路由断言"><a href="#1-predicate路由断言" class="headerlink" title="1.predicate路由断言"></a>1.predicate路由断言</h4><h5 id="After-Route-Predicate-Factory"><a href="#After-Route-Predicate-Factory" class="headerlink" title="After Route Predicate Factory"></a>After Route Predicate Factory</h5><p>AfterRoutePredicateFactory，可配置一个时间，当请求的时间在配置时间之后，才交给 router去处理。否则则报错，不通过路由。</p>
<p>在工程的application.yml配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: after_route</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: after_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - After=2017-01-20T17:42:47.789-07:00[America/Denver]</span><br><span class="line">  profiles: after_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置文件中，配置了服务的端口为8081，配置spring.profiles.active:after_route指定了程序的spring的启动文件为after_route文件。在application.yml再建一个配置文件，语法是三个横线，在此配置文件中通过spring.profiles来配置文件名，和spring.profiles.active一致，然后配置spring cloud gateway 相关的配置，id标签配置的是router的id，每个router都需要一个唯一的id，uri配置的是将请求路由到哪里，本案例全部路由到<a href="http://httpbin.org/get%E3%80%82">http://httpbin.org:80/get。</a></p>
<p>predicates： After=2017-01-20T17:42:47.789-07:00[America/Denver] 会被解析成PredicateDefinition对象 （name =After ，args= 2017-01-20T17:42:47.789-07:00[America/Denver]）。在这里需要注意的是predicates的After这个配置，遵循的契约大于配置的思想，它实际被AfterRoutePredicateFactory这个类所处理，这个After就是指定了它的Gateway web handler类为AfterRoutePredicateFactory，同理，其他类型的predicate也遵循这个规则。</p>
<p>当请求的时间在这个配置的时间之后，请求会被路由到<a href="http://httpbin.org/get%E3%80%82">http://httpbin.org:80/get。</a></p>
<p>启动工程，在浏览器上访问<a href="http://localhost:8081/%EF%BC%8C%E4%BC%9A%E6%98%BE%E7%A4%BAhttp://httpbin.org:80/get%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E6%AD%A4%E6%97%B6gateway%E8%B7%AF%E7%94%B1%E5%88%B0%E4%BA%86%E9%85%8D%E7%BD%AE%E7%9A%84uri%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%B0%86%E9%85%8D%E7%BD%AE%E7%9A%84%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE%E5%88%B0%E5%BD%93%E5%89%8D%E6%97%B6%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E6%98%BE%E7%A4%BA404%EF%BC%8C%E6%AD%A4%E6%97%B6%E8%AF%81%E6%98%8E%E6%B2%A1%E6%9C%89%E8%B7%AF%E7%94%B1%E5%88%B0%E9%85%8D%E7%BD%AE%E7%9A%84uri">http://localhost:8081/，会显示http://httpbin.org:80/get返回的结果，此时gateway路由到了配置的uri。如果我们将配置的时间设置到当前时之后，浏览器会显示404，此时证明没有路由到配置的uri</a>.</p>
<p>跟时间相关的predicates还有Before Route Predicate Factory、Between Route Predicate Factory</p>
<h5 id="Header-Route-Predicate-Factory"><a href="#Header-Route-Predicate-Factory" class="headerlink" title="Header Route Predicate Factory"></a>Header Route Predicate Factory</h5><p>Header Route Predicate Factory需要2个参数，一个是header名，另外一个header值，该值可以是一个正则表达式。当此断言匹配了请求的header名和值时，断言通过，进入到router的规则中去。</p>
<p>在工程的配置文件加上以下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: header_route</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: header_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Header=X-Request-Id, \d+</span><br><span class="line">  profiles: header_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，当请求的Header中有X-Request-Id的header名，且header值为数字时，请求会被路由到配置的 uri. 使用curl执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -H &#x27;X-Request-Id:1&#x27; localhost:8081</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/221.png" alt="221"></p>
<p>执行命令后，会正确的返回请求结果，结果省略。如果在请求中没有带上X-Request-Id的header名，并且值不为数字时，请求就会报404，路由没有被正确转发。</p>
<h5 id="Cookie-Route-Predicate-Factory"><a href="#Cookie-Route-Predicate-Factory" class="headerlink" title="Cookie Route Predicate Factory"></a>Cookie Route Predicate Factory</h5><p>Cookie Route Predicate Factory需要2个参数，一个时cookie名字，另一个时值，可以为正则表达式。它用于匹配请求中，带有该名称的cookie和cookie匹配正则表达式的请求。</p>
<p>在配置文件添加以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: cookie_route</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: cookie_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Cookie=name, forezp</span><br><span class="line">  profiles: cookie_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，请求带有cookie名为 name, cookie值为forezp 的请求将都会转发到uri为 <a href="http://httpbin.org/get%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8A%E3%80%82">http://httpbin.org:80/get的地址上。</a> 使用curl命令进行请求，在请求中带上 cookie，会返回正确的结果，否则，请求报404错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -H &#x27;Cookie:name=forezp&#x27; localhost:8081</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/222.png" alt="222"></p>
<h5 id="Host-Route-Predicate-Factory"><a href="#Host-Route-Predicate-Factory" class="headerlink" title="Host Route Predicate Factory"></a>Host Route Predicate Factory</h5><p>Host Route Predicate Factory需要一个参数即hostname，它可以使用. * 等去匹配host。这个参数会匹配请求头中的host的值，一致，则请求正确转发。</p>
<p>在工程的配置文件，加上以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: host_route</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: host_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Host=**.fangzhipeng.com</span><br><span class="line">  profiles: host_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，请求头中含有Host为fangzhipeng.com的请求将会被路由转发转发到配置的uri。 启动工程，执行以下的curl命令，请求会返回正确的请求结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &#x27;Host:www.fangzhipeng.com&#x27; localhost:8081</span><br></pre></td></tr></table></figure>

<h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/223.png" alt="223"></h5><h5 id="Method-Route-Predicate-Factory"><a href="#Method-Route-Predicate-Factory" class="headerlink" title="Method Route Predicate Factory"></a>Method Route Predicate Factory</h5><p>Method Route Predicate Factory 需要一个参数，即请求的类型。比如GET类型的请求都转发到此路由。在工程的配置文件加上以下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: method_route</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: method_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Method=GET</span><br><span class="line">  profiles: method_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，所有的GET类型的请求都会路由转发到配置的uri。使用 curl命令模拟 get类型的请求，会得到正确的返回结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8081</span><br></pre></td></tr></table></figure>

<p>使用 curl命令模拟 post请求，则返回404结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -X POST localhost:8081</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/224.png" alt="224"></p>
<h5 id="Path-Route-Predicate-Factory"><a href="#Path-Route-Predicate-Factory" class="headerlink" title="Path Route Predicate Factory"></a>Path Route Predicate Factory</h5><p>Path Route Predicate Factory 需要一个参数: 一个spel表达式，应用匹配路径。</p>
<p>在工程的配置文件application.yml文件中，做以下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: path_route</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: path_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Path=/foo/&#123;segment&#125;</span><br><span class="line">  profiles: path_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置中，所有的请求路径满足/foo/{segment}的请求将会匹配并被路由，比如/foo/1 、/foo/bar的请求，将会命中匹配，并成功转发。</p>
<p>使用curl模拟一个请求localhost:8081/foo/dew，执行之后会返回正确的请求结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8081/foo/dew</span><br></pre></td></tr></table></figure>

<h5 id="Query-Route-Predicate-Factory"><a href="#Query-Route-Predicate-Factory" class="headerlink" title="Query Route Predicate Factory"></a>Query Route Predicate Factory</h5><p>Query Route Predicate Factory 需要2个参数:一个参数名和一个参数值的正则表达式。在工程的配置文件application.yml做以下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: query_route</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: query_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Query=foo, ba.</span><br><span class="line">  profiles: query_route</span><br></pre></td></tr></table></figure>

<p>在上面的配置文件中，配置了请求中含有参数foo，并且foo的值匹配ba.，则请求命中路由，比如一个请求中含有参数名为foo，值的为bar，能够被正确路由转发。</p>
<p>模拟请求的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8081?foo=bar</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/225.png" alt="225"></p>
<p>Query Route Predicate Factory也可以只填一个参数，填一个参数时，则只匹配参数名，即请求的参数中含有配置的参数名，则命中路由。比如以下的配置中，配置了请求参数中含有参数名为foo 的参数将会被请求转发到uri为<a href="http://httpbin.org/get%E3%80%82">http://httpbin.org:80/get。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: query_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        predicates:</span><br><span class="line">        - Query=foo</span><br><span class="line">  profiles: query_route</span><br></pre></td></tr></table></figure>

<h4 id="2-gateway-之filters"><a href="#2-gateway-之filters" class="headerlink" title="2.gateway 之filters"></a>2.gateway 之filters</h4><p>Spring Cloud Gateway根据作用范围划分为GatewayFilter和GlobalFilter，二者区别如下：</p>
<ul>
<li>GatewayFilter : 需要通过spring.cloud.routes.filters 配置在具体路由下，只作用在当前路由上或通过spring.cloud.default-filters配置在全局，作用在所有路由上</li>
<li>GlobalFilter : 全局过滤器，不需要在配置文件中配置，作用在所有的路由上，最终通过GatewayFilterAdapter包装成GatewayFilterChain可识别的过滤器，它为请求业务以及路由的URI转换为真实业务服务的请求地址的核心过滤器，不需要配置，系统初始化时加载，并作用在每个路由上。</li>
</ul>
<h5 id="gateway-filter"><a href="#gateway-filter" class="headerlink" title="gateway filter"></a>gateway filter</h5><h6 id="AddRequestHeader-GatewayFilter-Factory"><a href="#AddRequestHeader-GatewayFilter-Factory" class="headerlink" title="AddRequestHeader GatewayFilter Factory"></a>AddRequestHeader GatewayFilter Factory</h6><p>创建工程，引入相关的依赖,包括spring boot 版本2.0.5，spring Cloud版本Finchley，gateway依赖如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在工程的配置文件中，加入以下的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: add_request_header_route</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: add_request_header_route</span><br><span class="line">        uri: http://httpbin.org:80/get</span><br><span class="line">        filters:</span><br><span class="line">        - AddRequestHeader=X-Request-Foo, Bar</span><br><span class="line">        predicates:</span><br><span class="line">        - After=2017-01-20T17:42:47.789-07:00[America/Denver]</span><br><span class="line">  profiles: add_request_header_route</span><br></pre></td></tr></table></figure>

<p>在上述的配置中，工程的启动端口为8081，配置文件为add_request_header_route，在add_request_header_route配置中，配置了roter的id为add_request_header_route，路由地址为<a href="http://httpbin.org/get%EF%BC%8C%E8%AF%A5router%E6%9C%89AfterPredictFactory%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AAfilter%E4%B8%BAAddRequestHeaderGatewayFilterFactory(%E7%BA%A6%E5%AE%9A%E5%86%99%E6%88%90AddRequestHeader)%EF%BC%8CAddRequestHeader%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82%E4%BC%9A%E5%9C%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%8A%A0%E4%B8%8A%E4%B8%80%E5%AF%B9%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%8C%E5%90%8D%E7%A7%B0%E4%B8%BAX-Request-Foo%EF%BC%8C%E5%80%BC%E4%B8%BABar%E3%80%82%E4%B8%BA%E4%BA%86%E9%AA%8C%E8%AF%81AddRequestHeaderGatewayFilterFactory%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%AE%83%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%8CAddRequestHeaderGatewayFilterFactory%E7%9A%84%E6%BA%90%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">http://httpbin.org:80/get，该router有AfterPredictFactory，有一个filter为AddRequestHeaderGatewayFilterFactory(约定写成AddRequestHeader)，AddRequestHeader过滤器工厂会在请求头加上一对请求头，名称为X-Request-Foo，值为Bar。为了验证AddRequestHeaderGatewayFilterFactory是怎么样工作的，查看它的源码，AddRequestHeaderGatewayFilterFactory的源码如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public GatewayFilter apply(NameValueConfig config) &#123;</span><br><span class="line">		return (exchange, chain) -&gt; &#123;</span><br><span class="line">			ServerHttpRequest request = exchange.getRequest().mutate()</span><br><span class="line">					.header(config.getName(), config.getValue())</span><br><span class="line">					.build();</span><br><span class="line"></span><br><span class="line">			return chain.filter(exchange.mutate().request(request).build());</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可知，根据旧的ServerHttpRequest创建新的 ServerHttpRequest ，在新的ServerHttpRequest加了一个请求头，然后创建新的 ServerWebExchange ，提交过滤器链继续过滤。</p>
<p>启动工程，通过curl命令来模拟请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost:8081</span><br></pre></td></tr></table></figure>

<p>最终显示了从 <a href="http://httpbin.org/get%E5%BE%97%E5%88%B0%E4%BA%86%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%93%8D%E5%BA%94%E5%A6%82%E4%B8%8B%EF%BC%9A">http://httpbin.org:80/get得到了请求，响应如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class="line">    &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">    &quot;Forwarded&quot;: &quot;proto=http;host=\&quot;localhost:8081\&quot;;for=\&quot;0:0:0:0:0:0:0:1:56248\&quot;&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;curl/7.58.0&quot;,</span><br><span class="line">    &quot;X-Forwarded-Host&quot;: &quot;localhost:8081&quot;,</span><br><span class="line">    &quot;X-Request-Foo&quot;: &quot;Bar&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;origin&quot;: &quot;0:0:0:0:0:0:0:1, 210.22.21.66&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://localhost:8081/get&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以上面的响应可知，确实在请求头中加入了X-Request-Foo这样的一个请求头，在配置文件中配置的AddRequestHeader过滤器工厂生效。</p>
<h6 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h6><p>Spring Cloud Gateway内置了19种强大的过滤器工厂，能够满足很多场景的需求，那么能不能自定义自己的过滤器呢，当然是可以的。在spring Cloud Gateway中，过滤器需要实现GatewayFilter和Ordered2个接口。写一个RequestTimeFilter，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RequestTimeFilter implements GatewayFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private static final Log log = LogFactory.getLog(GatewayFilter.class);</span><br><span class="line">    private static final String REQUEST_TIME_BEGIN = &quot;requestTimeBegin&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line"></span><br><span class="line">        exchange.getAttributes().put(REQUEST_TIME_BEGIN, System.currentTimeMillis());</span><br><span class="line">        return chain.filter(exchange).then(</span><br><span class="line">                Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">                    Long startTime = exchange.getAttribute(REQUEST_TIME_BEGIN);</span><br><span class="line">                    if (startTime != null) &#123;</span><br><span class="line">                        log.info(exchange.getRequest().getURI().getRawPath() + &quot;: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，Ordered中的int getOrder()方法是来给过滤器设定优先级别的，值越大则优先级越低。还有有一个filterI(exchange,chain)方法，在该方法中，先记录了请求的开始时间，并保存在ServerWebExchange中，此处是一个“pre”类型的过滤器，然后再chain.filter的内部类中的run()方法中相当于”post”过滤器，在此处打印了请求所消耗的时间。然后将该过滤器注册到router中，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RouteLocator customerRouteLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line">    // @formatter:off</span><br><span class="line">    return builder.routes()</span><br><span class="line">            .route(r -&gt; r.path(&quot;/customer/**&quot;)</span><br><span class="line">                    .filters(f -&gt; f.filter(new RequestTimeFilter())</span><br><span class="line">                            .addResponseHeader(&quot;X-Response-Default-Foo&quot;, &quot;Default-Bar&quot;))</span><br><span class="line">                    .uri(&quot;http://httpbin.org:80/get&quot;)</span><br><span class="line">                    .order(0)</span><br><span class="line">                    .id(&quot;customer_filter_router&quot;)</span><br><span class="line">            )</span><br><span class="line">            .build();</span><br><span class="line">    // @formatter:on</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启程序，通过curl命令模拟请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost:8081/customer/123</span><br></pre></td></tr></table></figure>

<p>在程序的控制台输出一下的请求信息的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-11-16 15:02:20.177  INFO 20488 --- [ctor-http-nio-3] o.s.cloud.gateway.filter.GatewayFilter   : /customer/123: 152ms</span><br></pre></td></tr></table></figure>

<h5 id="global-filter"><a href="#global-filter" class="headerlink" title="global filter"></a>global filter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">    String token = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span> || token.isEmpty()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;token is empty...&quot;</span>);</span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/211.png" alt="212"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/212.png" alt="212"></p>
<h2 id="三、Ribbon负载均衡"><a href="#三、Ribbon负载均衡" class="headerlink" title="三、Ribbon负载均衡"></a>三、Ribbon负载均衡</h2><p>ribbon-provider 和ribbon-consumer</p>
<p>使用负载均衡 轮询法</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/28.png" alt="28"></p>
<p>ribbon-custom和nacos-ribbon-provider同时启动</p>
<p>自定myrule负载均衡规则:只调用第一个服务器8070</p>
<p>访问<a href="http://localhost:7089/test/getUserName">localhost:7089/test/getUserName</a></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/31.png" alt="31"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/32.png" alt="32"></p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>著作权归<a href="https://pdai.tech所有./">https://pdai.tech所有。</a> 链接：<a href="https://pdai.tech/md/algorithm/alg-domain-load-balance.html">https://pdai.tech/md/algorithm/alg-domain-load-balance.html</a></p>
<p>常见的负载均衡算法包含:</p>
<ul>
<li>轮询法(Round Robin)</li>
<li>加权轮询法(Weight Round Robin)</li>
<li>平滑加权轮询法(Smooth Weight Round Robin)</li>
<li>随机法(Random)</li>
<li>加权随机法(Weight Random)</li>
<li>源地址哈希法(Hash)</li>
<li>最小连接数法(Least Connections)</li>
</ul>
<h3 id="¶-轮询法-Round-Robin"><a href="#¶-轮询法-Round-Robin" class="headerlink" title="¶ 轮询法(Round Robin)"></a><a href="#%E8%BD%AE%E8%AF%A2%E6%B3%95round-robin">¶</a> 轮询法(Round Robin)</h3><p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
<h3 id="¶-加权轮询法-Weight-Round-Robin"><a href="#¶-加权轮询法-Weight-Round-Robin" class="headerlink" title="¶ 加权轮询法(Weight Round Robin)"></a><a href="#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E6%B3%95weight-round-robin">¶</a> 加权轮询法(Weight Round Robin)</h3><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<h3 id="¶-随机法-Random"><a href="#¶-随机法-Random" class="headerlink" title="¶ 随机法(Random)"></a><a href="#%E9%9A%8F%E6%9C%BA%E6%B3%95random">¶</a> 随机法(Random)</h3><p>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p>
<h3 id="¶-加权随机法-Weight-Random"><a href="#¶-加权随机法-Weight-Random" class="headerlink" title="¶ 加权随机法(Weight Random)"></a><a href="#%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E6%B3%95weight-random">¶</a> 加权随机法(Weight Random)</h3><p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<h3 id="¶-源地址哈希法-Hash"><a href="#¶-源地址哈希法-Hash" class="headerlink" title="¶ 源地址哈希法(Hash)"></a><a href="#%E6%BA%90%E5%9C%B0%E5%9D%80%E5%93%88%E5%B8%8C%E6%B3%95hash">¶</a> 源地址哈希法(Hash)</h3><p>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
<h3 id="¶-最小连接数法-Least-Connections"><a href="#¶-最小连接数法-Least-Connections" class="headerlink" title="¶ 最小连接数法(Least Connections)"></a><a href="#%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%B3%95least-connections">¶</a> 最小连接数法(Least Connections)</h3><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
<p>负载均衡规则说明</p>
<p>NFLoadBalancerclassName:配置ILoadBalancer的实现类<br>NFLoadBalancerRuleclassName:配置IRule的实现类<br>NFLoadBalancerPingclassName:配置IPing的实现类<br>NFWSServerListclassName:配置ServerList的实现类<br>NIWSServerListFilterclassName:配置ServerListFilter的实现类</p>
<table>
<thead>
<tr>
<th align="left">策略名</th>
<th>策略声明</th>
<th>策略描述</th>
<th>实现说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BestAvailableRule</td>
<td>public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule</td>
<td>选择一个最小的并发请求的server</td>
<td>逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td>public class AvailabilityFilteringRule extends PredicateBasedRule</td>
<td>过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）</td>
<td>使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td>public class WeightedResponseTimeRule extends RoundRobinRule</td>
<td>根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低</td>
<td>一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas时，使用roubine策略选择server。</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td>public class RetryRule extends AbstractLoadBalancerRule</td>
<td>对选定的负载均衡策略机上重试机制。</td>
<td>在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server</td>
</tr>
<tr>
<td align="left">RoundRobinRule</td>
<td>public class RoundRobinRule extends AbstractLoadBalancerRule</td>
<td>roundRobin方式轮询选择server</td>
<td>轮询index，选择index对应位置的server</td>
</tr>
<tr>
<td align="left">RandomRule</td>
<td>public class RandomRule extends AbstractLoadBalancerRule</td>
<td>随机选择一个server</td>
<td>在index上随机，选择index对应位置的server</td>
</tr>
<tr>
<td align="left">ZoneAvoidanceRule</td>
<td>public class ZoneAvoidanceRule extends PredicateBasedRule</td>
<td>复合判断server所在区域的性能和server的可用性选择server</td>
<td>使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。</td>
</tr>
</tbody></table>
<h2 id="四、OpenFeign声明式调用"><a href="#四、OpenFeign声明式调用" class="headerlink" title="四、OpenFeign声明式调用"></a>四、OpenFeign声明式调用</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>Feign是一个声明式web服务客户端，只需要创建一个接口并添加注解，即可实现远程调用服务。</p>
<pre><code>    Feign 就是一个 Http 客户端的模板，目标是减少 HTTP API 的复杂性，希望能将 HTTP 远程服务调用做到像 RPC 一样易用。Feign 集成 RestTemplate、Ribbon 实现了客户端的负载均衡的 Http 调用，并对原调用方式进行了封装，使得开发者不必手动使用 RestTemplate 调用服务，而是声明一个接口，并在这个接口中标注一个注解即可完成服务调用，这样更加符合面向接口编程的宗旨，客户端在调用服务端时也不需要再关注请求的方式、地址以及是 forObject 还是 forEntity，结构更加明了，耦合也更低，简化了开发。但 Feign 已经停止迭代了，所以本篇文章我们也不过多的介绍，而在 Feign 的基础上，又衍生出了 openFeign，那么 openFeign 又是什么呢？

    openFeign 在 Feign 的基础上支持了 SpringMVC 的注解，如 @RequestMapping 等。OpenFeign 的 @FeignClient 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。

    总的就是，openFeign 作为微服务架构下服务间调用的解决方案，是一种声明式、模板化的 HTTP 的模板，使 HTTP 请求就像调用本地方法一样，通过 openFeign 可以替代基于 RestTemplate 的远程服务调用，并且默认集成了 Ribbon 进行负载均衡。
</code></pre>
<h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><p> ①服务消费者在远程调用时，只需通过编写一个接口，并表上注解进行配置，即可实现对服务提供方接口的绑定。</p>
<p>②Feign集成Ribbon，Feign利用Ribbon维护服务提供方列表，实现轮询调用服务提供者。</p>
<p>架构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/41.png" alt="41"></p>
<h3 id="3-openFeign-的传参："><a href="#3-openFeign-的传参：" class="headerlink" title="3.openFeign 的传参："></a>3.openFeign 的传参：</h3><p>​        开发中接口传参的方式有很多，但是在 openFeign 中的传参是有一定规则的，下面详细介绍四种常见的传参方式。</p>
<p>3.1、传递JSON数据：<br>provider 接口中 JSON 传参方法如下：</p>
<p>@RestController<br>@RequestMapping(“/openfeign/provider”)<br>public class OpenFeignProviderController {<br>    @PostMapping(“/order2”)<br>    public Order createOrder2(@RequestBody Order order){<br>        return order;<br>    }<br>}<br>consumer消费者openFeign代码如下：</p>
<p>@FeignClient(value = “openFeign-provider”)<br>public interface OpenFeignService {<br>    /**<br>     * 参数默认是@RequestBody标注的，这里的@RequestBody可以不填<br>     * 方法名称任意<br>     */<br>    @PostMapping(“/openfeign/provider/order2”)<br>    Order createOrder2(@RequestBody Order order);<br>}<br>注意：openFeign 默认的传参方式就是JSON传参（@RequestBody），因此定义接口的时候可以不用@RequestBody注解标注，不过为了规范，一般都填上。</p>
<p>3.2、POJO表单传参：<br>provider服务提供者代码如下：</p>
<p>@RestController<br>@RequestMapping(“/openfeign/provider”)<br>public class OpenFeignProviderController {<br>    @PostMapping(“/order1”)<br>    public Order createOrder1(Order order){<br>        return order;<br>    }<br>}<br>consumer消费者openFeign代码如下：</p>
<p>@FeignClient(value = “openFeign-provider”)<br>public interface OpenFeignService {<br>    /**<br>     * 如果通过POJO表单传参的，使用@SpringQueryMap标注<br>     */<br>    @PostMapping(“/openfeign/provider/order1”)<br>    Order createOrder1(@SpringQueryMap Order order);<br>}<br>3.3、URL中携带参数：<br>此种方式针对restful方式中的GET请求，也是比较常用请求方式。</p>
<p>provider服务提供者代码如下：</p>
<p>@RestController<br>@RequestMapping(“/openfeign/provider”)<br>public class OpenFeignProviderController {</p>
<pre><code>@GetMapping(&quot;/test/&#123;id&#125;&quot;)
public String test(@PathVariable(&quot;id&quot;)Integer id)&#123;
    return &quot;accept one msg id=&quot;+id;
</code></pre>
<p>}<br>consumer消费者openFeign接口如下：</p>
<p>@FeignClient(value = “openFeign-provider”)<br>public interface OpenFeignService {</p>
<pre><code>@GetMapping(&quot;/openfeign/provider/test/&#123;id&#125;&quot;)
String get(@PathVariable(&quot;id&quot;)Integer id);
</code></pre>
<p>}<br>使用注解 @PathVariable 接收url中的占位符，这种方式很好理解。</p>
<p>3.4、普通表单参数：<br>此种方式传参不建议使用，但是也有很多开发在用。</p>
<p>provider服务提供者代码如下：</p>
<p>@RestController<br>@RequestMapping(“/openfeign/provider”)<br>public class OpenFeignProviderController {<br>    @PostMapping(“/test2”)<br>    public String test2(String id,String name){<br>        return MessageFormat.format(“accept on msg id={0}，name={1}”,id,name);<br>    }<br>}<br>consumer消费者openFeign接口传参如下：</p>
<p>@FeignClient(value = “openFeign-provider”)<br>public interface OpenFeignService {<br>    /**<br>     * 必须要@RequestParam注解标注，且value属性必须填上参数名<br>          * 方法参数名可以任意，但是@RequestParam注解中的value属性必须和provider中的参数名相同<br>          */<br>        @PostMapping(“/openfeign/provider/test2”)<br>        String test(@RequestParam(“id”) String arg1,@RequestParam(“name”) String arg2);<br>}</p>
<h3 id="4、案例说明"><a href="#4、案例说明" class="headerlink" title="4、案例说明"></a>4、案例说明</h3><p>spring-boot-openfeign-01</p>
<p>feign创建接口，调用http的基本方法(post、get)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;openfeign&quot;)</span><br><span class="line">interface NameFeignApi &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test/name&quot;)</span><br><span class="line">    String getName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/42.png" alt="42"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/43.png" alt="43"></p>
<p>Spring Cloud OpenFeign 的核心工作原理经上文探究可以非常简单的总结为：</p>
<ol>
<li><ol>
<li>通过 @EnableFeignCleints 触发 Spring 应用程序对 classpath 中 @FeignClient 修饰类的扫描</li>
<li>解析到 @FeignClient 修饰类后， Feign 框架通过扩展 Spring Bean Deifinition 的注册逻辑， 最终注册一个 FeignClientFacotoryBean 进入 Spring 容器</li>
<li>Spring 容器在初始化其他用到 @FeignClient 接口的类时， 获得的是 FeignClientFacotryBean 产生的一个代理对象 Proxy.</li>
<li>基于 java 原生的动态代理机制， 针对 Proxy 的调用， 都会被统一转发给 Feign 框架所定义的一个 InvocationHandler ， 由该 Handler 完成后续的 HTTP 转换， 发送， 接收， 翻译HTTP响应的工作</li>
</ol>
</li>
</ol>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/image-20220923200504398.png" alt="image-20220923200504398"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/44.png" alt="44"></p>
<h2 id="五、熔断、限流、降级"><a href="#五、熔断、限流、降级" class="headerlink" title="五、熔断、限流、降级"></a>五、熔断、限流、降级</h2><h3 id="spring-cloud-Hystrix"><a href="#spring-cloud-Hystrix" class="headerlink" title="spring cloud Hystrix"></a>spring cloud Hystrix</h3><p>（1）服务降级<br>服务出现故障时，给故障服务降级到事先准备好的故障处理结果，将此结果返回给服务消费者，如：</p>
<p> <img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/57.png" alt="57"></p>
<p>客户端访问服务1，服务1调用服务2，服务2出现故障，Hystrix服务降级，返回一个可以处理的结果给服务1，服务1再以友好的错误界面返回给客户端。</p>
<p>（2）服务熔断<br>熔断机制是应对服务雪崩的一种链路保护机制，当服务出现故障时，服务会进行降级，熔断该服务节点，迅速返回错误响应信息。当检测到服务访问正常时，恢复其链路节点。<br><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/58.png" alt="58"></p>
<h4 id="Hystrix-demo"><a href="#Hystrix-demo" class="headerlink" title="Hystrix-demo"></a>Hystrix-demo</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/testCollapser&quot;)</span><br><span class="line">public String testCollapser() throws Exception&#123;</span><br><span class="line">    new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            User user = userService.getUserById(1L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            User user = userService.getUserById(2L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    new Thread()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            User user = userService.getUserById(3L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    return &quot;操作成功&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/51.png" alt="51"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/hello&quot;)</span><br><span class="line">@HystrixCommand(fallbackMethod = &quot;fallbackHello&quot;, commandProperties = &#123;</span><br><span class="line">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1000&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public String hello() throws InterruptedException &#123;</span><br><span class="line">    //模拟访问超时</span><br><span class="line">    Thread.sleep(3000);</span><br><span class="line">    return &quot;Hello Hystrix&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/52.png" alt="52"></p>
<h4 id="Hystrix监测"><a href="#Hystrix监测" class="headerlink" title="Hystrix监测"></a>Hystrix监测</h4><p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/56.png" alt="56"></p>
<p>Hystrix-dashboard</p>
<p>访问8070/hello</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/hello&quot;)</span><br><span class="line">@HystrixCommand(fallbackMethod = &quot;planb&quot;, commandProperties = &#123;</span><br><span class="line">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1000&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public String hello() throws InterruptedException &#123;</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">    return &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br><span class="line">private String planb() &#123;</span><br><span class="line">    return &quot;Sorry our Systems are busy! try again later.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/55.png" alt="55"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/54.png" alt="54"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/53.png" alt="53"></p>
<h4 id="Turbine集群监测"><a href="#Turbine集群监测" class="headerlink" title="Turbine集群监测"></a>Turbine集群监测</h4><p>启动turbine-dashboard(9090)、turbine-eureka-service(8001)、turbine-user-service(8070)</p>
<p>userservice</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/593.png" alt="593"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/591.png" alt="591"></p>
<p>turbine-dashboard</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/59.png" alt="59"></p>
<p>关闭localhost:9090/turbine.stream和localhost:8070/actutor/hystrix.stream   turbine-dashboard能够检测curl的stream流连接</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/595.png" alt="595"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/596.png" alt="596"></p>
<p>turbine-eureka-server</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/594.png" alt="594"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/592.png" alt="592"></p>
<h2 id="六、Sring-cloud-bus消息总线"><a href="#六、Sring-cloud-bus消息总线" class="headerlink" title="六、Sring cloud bus消息总线"></a>六、Sring cloud bus消息总线</h2><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p>docker安装部署kafka</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull wurstmeister/zookeeper</span><br><span class="line"></span><br><span class="line">docker pull wurstmeister/kafka</span><br><span class="line"></span><br><span class="line">docker run -d --name zookeeper -p 2181:2181 wurstmeister/zookeeper</span><br><span class="line"> </span><br><span class="line">docker run -d --name kafka --publish 9092:9092 --link zookeeper --env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 --env KAFKA_ADVERTISED_HOST_NAME=localhost --env KAFKA_ADVERTISED_PORT=9092 wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<p>kafka-map可视化界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull dushixiang/kafka-map</span><br><span class="line">docker run -d --name kafka-map -p 8049:8080 -e DEFAULT_USERNAME=admin -e DEFAULT_PASSWORD=admin  dushixiang/kafka-map:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/61.png" alt="61"></p>
<p>zookeeper可视化界面</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/62.png" alt="62"></p>
<p>运行 stream-input、Stream-output</p>
<p>访问<a href="http://localhost:18091/test/send4">localhost:18091/test/send4</a></p>
<p>可见对应的ay-topic的messages数量增加</p>
<p>说明消息发送成功</p>
<p>output生产者发送消息</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/64.png" alt="64"></p>
<p>input消费者接收信息如下<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/63.png" alt="63"></p>
<h2 id="七、分布式事务Seata"><a href="#七、分布式事务Seata" class="headerlink" title="七、分布式事务Seata"></a>七、分布式事务Seata</h2><p>Spring cloud Alibaba Seata</p>
<p>下载seata并运行seata-server，启动nacos</p>
<p>同时运行seata-orderservice、seata-stockservice,seata-userservice，最后在网站中测试<a href="http://localhost:9001/order/create?userId=1&productOd=1&count=10&money=100">localhost:9001/order/create?userId=1&amp;productOd=1&amp;count=10&amp;money=100</a></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/seata-server.png" alt="seata-server"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/seata-userservice.png" alt="seata-userservice"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/seata-stockservice.png" alt="seata-stockservice"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/seata-orderservice.png" alt="seata-orderservice"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/71.png" alt="71"></p>
<h2 id="八、服务链路追踪Sleuth"><a href="#八、服务链路追踪Sleuth" class="headerlink" title="八、服务链路追踪Sleuth"></a>八、服务链路追踪Sleuth</h2><p>spring cloud Sleuth</p>
<p>运行sleuth-zipkin中的gateway、provider、consumer</p>
<p>同时配置运行zipkin、nacos、sentinel环境</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/81.png" alt="81"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/82.png" alt="82"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/83.png" alt="83"></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/84.png" alt="84"></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5基础</title>
    <url>/2021/07/12/spring5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="spring5基础"><a href="#spring5基础" class="headerlink" title="spring5基础"></a>spring5基础</h1><h2 id="Spring——IOC（控制反转）"><a href="#Spring——IOC（控制反转）" class="headerlink" title="Spring——IOC（控制反转）"></a>Spring——IOC（控制反转）</h2><h3 id="一、IOC容器"><a href="#一、IOC容器" class="headerlink" title="一、IOC容器"></a>一、IOC容器</h3><h3 id="1、什么是IOC（控制反转）"><a href="#1、什么是IOC（控制反转）" class="headerlink" title="1、什么是IOC（控制反转）"></a>1、什么是IOC（控制反转）</h3><p> a）把对象创建和对象之间的调用过程，交给Spring进行管理</p>
<p> b）使用IOC目的：为了降低耦合度<br> <span id="more"></span></p>
<h3 id="2、IOC底层"><a href="#2、IOC底层" class="headerlink" title="2、IOC底层"></a>2、IOC底层</h3><p> a）xml解析、工厂模式、反射</p>
<p> 3、Spring提供的IOC容器实现的两种方式（两个接口）</p>
<p> a）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。）</p>
<p> b）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！</p>
<p> 4、ApplicationContext接口的实现类（具体根据API文档查看☺）</p>
<h3 id="二、IOC容器-Bean管理"><a href="#二、IOC容器-Bean管理" class="headerlink" title="二、IOC容器-Bean管理"></a>二、IOC容器-Bean管理</h3><h3 id="1、IOC操作Bean管理"><a href="#1、IOC操作Bean管理" class="headerlink" title="1、IOC操作Bean管理"></a>1、IOC操作Bean管理</h3><p> a）Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性</p>
<h3 id="2、基于XML配置文件创建对象"><a href="#2、基于XML配置文件创建对象" class="headerlink" title="2、基于XML配置文件创建对象"></a>2、基于XML配置文件创建对象</h3><!--1 配置User对象创建-->

<p><bean id="user" class="com.atguigu.spring5.User"></bean></p>
<h3 id="3、基于XML方式注入属性（DI：依赖注入（注入属性））"><a href="#3、基于XML方式注入属性（DI：依赖注入（注入属性））" class="headerlink" title="3、基于XML方式注入属性（DI：依赖注入（注入属性））"></a>3、基于XML方式注入属性（DI：依赖注入（注入属性））</h3><h5 id="a）set方式注入"><a href="#a）set方式注入" class="headerlink" title="a）set方式注入"></a>a）set方式注入</h5><p>//（1）传统方式： 创建类，定义属性和对应的set方法<br>public class Book {<br>        //创建属性<br>        private String bname;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建属性对应的set方法</span><br><span class="line">public void setBname(String bname) &#123;</span><br><span class="line">    this.bname = bname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   }</p>
<!--（2）spring方式： set方法注入属性-->

<bean id="book" class="com.atguigu.spring5.Book">
    <!--使用property完成属性注入
        name：类里面属性名称
        value：向属性注入的值
    -->
    <property name="bname" value="Hello"></property>
    <property name="bauthor" value="World"></property>
</bean>

<h5 id="b）有参构造函数注入"><a href="#b）有参构造函数注入" class="headerlink" title="b）有参构造函数注入"></a>b）有参构造函数注入</h5><p>//（1）传统方式：创建类，构建有参函数<br>public class Orders {<br>    //属性<br>    private String oname;<br>    private String address;<br>    //有参数构造<br>    public Orders(String oname,String address) {<br>        this.oname = oname;<br>        this.address = address;<br>    }<br>  }</p>
<!--（2）spring方式：有参数构造注入属性-->

<bean id="orders" class="com.atguigu.spring5.Orders">
    <constructor-arg name="oname" value="Hello"></constructor-arg>
    <constructor-arg name="address" value="China！"></constructor-arg>
</bean>

<h5 id="c）p名称空间注入（了解即可）"><a href="#c）p名称空间注入（了解即可）" class="headerlink" title="c）p名称空间注入（了解即可）"></a>c）p名称空间注入（了解即可）</h5><!--1、添加p名称空间在配置文件头部-->

<?xml version="1.0" encoding="UTF-8"?>

<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a><br>       xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>       xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a>        <!--在这里添加一行p--></p>
<!--2、在bean标签进行属性注入（算是set方式注入的简化操作）-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot; p:bname=&quot;very&quot; p:bauthor=&quot;good&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4、注入空值和特殊符号"><a href="#4、注入空值和特殊符号" class="headerlink" title="4、注入空值和特殊符号"></a>4、注入空值和特殊符号</h4><bean id="book" class="com.atguigu.spring5.Book">
    <!--（1）null值-->
    <property name="address">
        <null/><!--属性里边添加一个null标签-->
    </property>
    

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--（2）特殊符号赋值--&gt;</span><br><span class="line"> &lt;!--属性值包含特殊符号</span><br><span class="line">   a 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span><br><span class="line">   b 把带特殊符号内容写到CDATA</span><br><span class="line">  --&gt;</span><br><span class="line">    &lt;property name=&quot;address&quot;&gt;</span><br><span class="line">        &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure>

</bean>

<h4 id="5、注入属性-外部bean"><a href="#5、注入属性-外部bean" class="headerlink" title="5、注入属性-外部bean"></a>5、注入属性-外部bean</h4><p> a）创建两个类service和dao类</p>
<p>public class UserService {//service类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建UserDao类型属性，生成set方法</span><br><span class="line">private UserDao userDao;</span><br><span class="line">public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">    this.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add() &#123;</span><br><span class="line">    System.out.println(&quot;service add...............&quot;);</span><br><span class="line">    userDao.update();//调用dao方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>public class UserDaoImpl implements UserDao {//dao类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line">    System.out.println(&quot;dao update...........&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p> b）在spring配置文件中进行配置</p>
<!--1 service和dao对象创建-->

<bean id="userService" class="com.atguigu.spring5.service.UserService">
    <!--注入userDao对象
        name属性：类里面属性名称
        ref属性：创建userDao对象bean标签id值
    -->
    <property name="userDao" ref="userDaoImpl"></property>
</bean>
<bean id="userDaoImpl" class="com.atguigu.spring5.dao.UserDaoImpl"></bean>

<h4 id="6、基于XML方式注入内部bean和级联赋值"><a href="#6、基于XML方式注入内部bean和级联赋值" class="headerlink" title="6、基于XML方式注入内部bean和级联赋值"></a>6、基于XML方式注入内部bean和级联赋值</h4><p> a）注入属性-内部bean</p>
<p>（1）一对多关系：部门和员工<br>一个部门有多个员工，一个员工属于一个部门（部门是一，员工是多）<br>（2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</p>
<p>//部门类<br>public class Dept {<br>    private String dname;<br>    public void setDname(String dname) {<br>        this.dname = dname;<br>    }<br>}</p>
<p>//员工类<br>public class Emp {<br>    private String ename;<br>    private String gender;<br>    //员工属于某一个部门，使用对象形式表示<br>    private Dept dept;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setDept(Dept dept) &#123;</span><br><span class="line">    this.dept = dept;</span><br><span class="line">&#125;</span><br><span class="line">public void setEname(String ename) &#123;</span><br><span class="line">    this.ename = ename;</span><br><span class="line">&#125;</span><br><span class="line">public void setGender(String gender) &#123;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>（3）在spring配置文件中配置</p>
<!--内部bean-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=&quot;ename&quot; value=&quot;Andy&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置对象类型属性--&gt;</span><br><span class="line">    &lt;property name=&quot;dept&quot;&gt;</span><br><span class="line">        &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;&lt;!--内部bean赋值--&gt;</span><br><span class="line">            &lt;property name=&quot;dname&quot; value=&quot;宣传部门&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p> b）注入属性-级联赋值</p>
<!--方式一：级联赋值-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=&quot;ename&quot; value=&quot;Andy&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dname&quot; value=&quot;公关部门&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p> //方式二：生成dept的get方法（get方法必须有！！）<br>    public Dept getDept() {<br>        return dept;<br>    }</p>
 <!--级联赋值-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;</span><br><span class="line">    &lt;!--设置两个普通属性--&gt;</span><br><span class="line">    &lt;property name=&quot;ename&quot; value=&quot;jams&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--级联赋值--&gt;</span><br><span class="line">    &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;dept.dname&quot; value=&quot;技术部门&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="7、IOC-操作-Bean-管理——xml-注入集合属性"><a href="#7、IOC-操作-Bean-管理——xml-注入集合属性" class="headerlink" title="7、IOC 操作 Bean 管理——xml 注入集合属性"></a>7、IOC 操作 Bean 管理——xml 注入集合属性</h4><p>1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性</p>
<p>//（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法<br>public class Stu {<br>    //1 数组类型属性<br>    private String[] courses;<br>    //2 list集合类型属性<br>    private List<String> list;<br>    //3 map集合类型属性<br>    private Map&lt;String,String&gt; maps;<br>    //4 set集合类型属性<br>    private Set<String> sets;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setSets(Set&lt;String&gt; sets) &#123;</span><br><span class="line">    this.sets = sets;</span><br><span class="line">&#125;</span><br><span class="line">public void setCourses(String[] courses) &#123;</span><br><span class="line">    this.courses = courses;</span><br><span class="line">&#125;</span><br><span class="line">public void setList(List&lt;String&gt; list) &#123;</span><br><span class="line">    this.list = list;</span><br><span class="line">&#125;</span><br><span class="line">public void setMaps(Map&lt;String, String&gt; maps) &#123;</span><br><span class="line">    this.maps = maps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--（2）在 spring 配置文件进行配置-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt;</span><br><span class="line">    &lt;!--数组类型属性注入--&gt;</span><br><span class="line">    &lt;property name=&quot;courses&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;java课程&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;数据库课程&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--list类型属性注入--&gt;</span><br><span class="line">    &lt;property name=&quot;list&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;小三&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--map类型属性注入--&gt;</span><br><span class="line">    &lt;property name=&quot;maps&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br></pre></td></tr></table></figure>

<p>​        </property><br>​        <!--set类型属性注入--><br>​        <property name="sets"><br>​            <set><br>​                <value>MySQL</value><br>​                <value>Redis</value><br>​            </set><br>​        </property><br></bean></p>
<h4 id="8、在集合里面设置对象类型值"><a href="#8、在集合里面设置对象类型值" class="headerlink" title="8、在集合里面设置对象类型值"></a>8、在集合里面设置对象类型值</h4><p>  //学生所学多门课程<br>    private List<Course> courseList;//创建集合<br>    public void setCourseList(List<Course> courseList) {<br>        this.courseList = courseList;<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--创建多个course对象--&gt;</span><br><span class="line">&lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;cname&quot; value=&quot;Spring5框架&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;cname&quot; value=&quot;MyBatis框架&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注入list集合类型，值是对象--&gt;</span><br><span class="line">   &lt;property name=&quot;courseList&quot;&gt;</span><br><span class="line">       &lt;list&gt;</span><br><span class="line">           &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt;</span><br><span class="line">           &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt;</span><br><span class="line">       &lt;/list&gt;</span><br><span class="line">   &lt;/property&gt;</span><br></pre></td></tr></table></figure>

<!--第一步：在 spring 配置文件中引入名称空间 util-->

<?xml version="1.0" encoding="UTF-8"?>

<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a><br>       xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>       xmlns:util=”<a href="http://www.springframework.org/schema/util&quot;">http://www.springframework.org/schema/util&quot;</a> <!--添加util名称空间--><br>    xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> </p>
<p><a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a><br>  <a href="http://www.springframework.org/schema/util">http://www.springframework.org/schema/util</a> <a href="http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;">http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;</a>  <!--添加util名称空间--></p>
<!--第二步：使用 util 标签完成 list 集合注入提取-->

<!--把集合注入部分提取出来-->

 <!--1 提取list集合类型属性注入-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;util:list id=&quot;bookList&quot;&gt;</span><br><span class="line">    &lt;value&gt;易筋经&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;九阴真经&lt;/value&gt;</span><br><span class="line">    &lt;value&gt;九阳神功&lt;/value&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure>

 <!--2 提取list集合类型属性注入使用-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-IOC容器-Bean管理——基于XML（续集）"><a href="#Spring-IOC容器-Bean管理——基于XML（续集）" class="headerlink" title="Spring IOC容器-Bean管理——基于XML（续集）"></a>Spring IOC容器-Bean管理——基于XML（续集）</h2><h3 id="1、IOC-操作-Bean-管理（FactoryBean）"><a href="#1、IOC-操作-Bean-管理（FactoryBean）" class="headerlink" title="1、IOC 操作 Bean 管理（FactoryBean）"></a>1、IOC 操作 Bean 管理（FactoryBean）</h3><p> 1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</p>
<p> 2、普通 bean：在配置文件中定义 bean 类型就是返回类型</p>
<p> 3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 </p>
<p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean </p>
<p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p>
<p>public class MyBean implements FactoryBean<Course> {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义返回bean</span><br><span class="line">@Override</span><br><span class="line">public Course getObject() throws Exception &#123;</span><br><span class="line">    Course course = new Course();</span><br><span class="line">    course.setCname(&quot;abc&quot;);</span><br><span class="line">    return course;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<bean id="myBean" class="com.atguigu.spring5.factorybean.MyBean">
</bean>

<p>@Test<br>public void test3() {<br> ApplicationContext context =<br> new ClassPathXmlApplicationContext(“bean3.xml”);<br> Course course = context.getBean(“myBean”, Course.class);//返回值类型可以不是定义的bean类型！<br> System.out.println(course);<br>}</p>
<h3 id="2、IOC-操作-Bean-管理（bean-作用域）"><a href="#2、IOC-操作-Bean-管理（bean-作用域）" class="headerlink" title="2、IOC 操作 Bean 管理（bean 作用域）"></a>2、IOC 操作 Bean 管理（bean 作用域）</h3><p> 在 Spring 里面，默认情况下，bean 是单实例对象，下面进行作用域设置：</p>
<p>（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p>
<p>（2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象</p>
<p><bean id="book" class="com.atguigu.spring5.collectiontype.Book" scope="prototype"><!--设置为多实例--><br>        <property name="list" ref="bookList"></property><br></bean></p>
<p>（3）singleton 和 prototype 区别</p>
<p> a）singleton 单实例，prototype 多实例</p>
<p> b）设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 ；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象</p>
<h3 id="3、IOC-操作-Bean-管理（bean-生命周期）"><a href="#3、IOC-操作-Bean-管理（bean-生命周期）" class="headerlink" title="3、IOC 操作 Bean 管理（bean 生命周期）"></a>3、IOC 操作 Bean 管理（bean 生命周期）</h3><p>1、生命周期 ：从对象创建到对象销毁的过程</p>
<p>2、bean 生命周期</p>
<p> （1）通过构造器创建 bean 实例（无参数构造）</p>
<p> （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p>
<p> （3）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p>
<p> （4）bean 可以使用了（对象获取到了）</p>
<p> （5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<p>3、演示 bean 生命周期 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Orders &#123;</span><br><span class="line"> //无参数构造</span><br><span class="line"> public Orders() &#123;</span><br><span class="line"> System.out.println(&quot;第一步 执行无参数构造创建 bean 实例&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> private String oname;</span><br><span class="line"> public void setOname(String oname) &#123;</span><br><span class="line"> this.oname = oname;</span><br><span class="line"> System.out.println(&quot;第二步 调用 set 方法设置属性值&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> //创建执行的初始化的方法</span><br><span class="line"> public void initMethod() &#123;</span><br><span class="line"> System.out.println(&quot;第三步 执行初始化的方法&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> //创建执行的销毁的方法</span><br><span class="line"> public void destroyMethod() &#123;</span><br><span class="line"> System.out.println(&quot;第五步 执行销毁的方法&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public class MyBeanPost implements BeanPostProcessor {//创建后置处理器实现类<br>    @Override<br>    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {<br>        System.out.println(“在初始化之前执行的方法”);<br>        return bean;<br>    }<br>    @Override<br>    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {<br>        System.out.println(“在初始化之后执行的方法”);<br>        return bean;<br>    }<br>}</p>
<!--配置文件的bean参数配置-->

<p><bean id="orders" class="com.atguigu.spring5.bean.Orders" init-method="initMethod" destroy-method="destroyMethod">    <!--配置初始化方法和销毁方法--><br>    <property name="oname" value="手机"></property><!--这里就是通过set方式（注入属性）赋值--><br></bean></p>
<!--配置后置处理器-->

<p><bean id="myBeanPost" class="com.atguigu.spring5.bean.MyBeanPost"></bean></p>
<p> @Test<br> public void testBean3() {<br>// ApplicationContext context =<br>// new ClassPathXmlApplicationContext(“bean4.xml”);<br> ClassPathXmlApplicationContext context =<br> new ClassPathXmlApplicationContext(“bean4.xml”);<br> Orders orders = context.getBean(“orders”, Orders.class);<br> System.out.println(“第四步 获取创建 bean 实例对象”);<br> System.out.println(orders);<br> //手动让 bean 实例销毁<br> context.close();<br> }</p>
<p>4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）</p>
<p> （1）通过构造器创建 bean 实例（无参数构造）</p>
<p> （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p>
<p> （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</p>
<p> （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p>
<p> （5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</p>
<p> （6）bean 可以使用了（对象获取到了）</p>
<p> （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p>
<h3 id="4、IOC-操作-Bean-管理-外部属性文件"><a href="#4、IOC-操作-Bean-管理-外部属性文件" class="headerlink" title="4、IOC 操作 Bean 管理(外部属性文件)"></a>4、IOC 操作 Bean 管理(外部属性文件)</h3><p>方式一：直接配置数据库信息 ：（1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包</p>
<!--直接配置连接池-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/userDb&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>方式二：引入外部属性文件配置数据库连接池</p>
<p>（1）创建外部属性文件，properties 格式文件，写数据库信息（jdbc.properties）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prop.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">prop.url=jdbc:mysql://localhost:3306/userDb</span><br><span class="line">prop.userName=root</span><br><span class="line">prop.password=root</span><br></pre></td></tr></table></figure>

<p>（2）把外部 properties 属性文件引入到 spring 配置文件中 —— 引入 context 名称空间</p>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"><!--引入context名称空间--></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    &lt;!--引入外部属性文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置连接池--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.userName&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

</beans>

<h2 id="IOC-操作-Bean-管理-基于注解方式"><a href="#IOC-操作-Bean-管理-基于注解方式" class="headerlink" title="IOC 操作 Bean 管理(基于注解方式)"></a>IOC 操作 Bean 管理(基于注解方式)</h2><h3 id="1、什么是注解"><a href="#1、什么是注解" class="headerlink" title="1、什么是注解"></a>1、什么是注解</h3><p> （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)</p>
<p> （2）使用注解，注解作用在类上面，方法上面，属性上面</p>
<p> （3）使用注解目的：简化 xml 配置</p>
<h3 id="2、Spring-针对-Bean-管理中创建对象提供注解"><a href="#2、Spring-针对-Bean-管理中创建对象提供注解" class="headerlink" title="2、Spring 针对 Bean 管理中创建对象提供注解"></a>2、Spring 针对 Bean 管理中创建对象提供注解</h3><p> 下面四个注解功能是一样的，都可以用来创建 bean 实例</p>
<p> （1）@Component</p>
<p> （2）@Service</p>
<p> （3）@Controller</p>
<p> （4）@Repository</p>
<h3 id="3、基于注解方式实现对象创建"><a href="#3、基于注解方式实现对象创建" class="headerlink" title="3、基于注解方式实现对象创建"></a>3、基于注解方式实现对象创建</h3><p> 第一步 引入依赖 （引入spring-aop jar包）</p>
<p> 第二步 开启组件扫描</p>
<!--开启组件扫描
 1 如果扫描多个包，多个包使用逗号隔开
 2 扫描包上层目录
-->

<p>&lt;context:component-scan base-package=”com.atguigu”&gt;</context:component-scan></p>
<p> 第三步 创建类，在类上面添加创建对象注解</p>
<p>//在注解里面 value 属性值可以省略不写，<br>//默认值是类名称，首字母小写<br>//UserService – userService<br>@Component(value = “userService”) //注解等同于XML配置文件：<bean id="userService" class=".."/><br>public class UserService {<br> public void add() {<br> System.out.println(“service add…….”);<br> }<br>}</p>
<h3 id="4、开启组件扫描细节配置"><a href="#4、开启组件扫描细节配置" class="headerlink" title="4、开启组件扫描细节配置"></a>4、开启组件扫描细节配置</h3><!--示例 1
 use-default-filters="false" 表示现在不使用默认 filter，自己配置 filter
 context:include-filter ，设置扫描哪些内容
-->

<p>&lt;context:component-scan base-package=”com.atguigu” use-defaultfilters=”false”&gt;<br> &lt;context:include-filter type=”annotation”</p>
<p>expression=”org.springframework.stereotype.Controller”/&gt;<!--代表只扫描Controller注解的类--><br></context:component-scan></p>
<!--示例 2
 下面配置扫描包所有内容
 context:exclude-filter： 设置哪些内容不进行扫描
-->

<p>&lt;context:component-scan base-package=”com.atguigu”&gt;<br> &lt;context:exclude-filter type=”annotation”</p>
<p>expression=”org.springframework.stereotype.Controller”/&gt;<!--表示Controller注解的类之外一切都进行扫描--><br></context:component-scan></p>
<h3 id="5、基于注解方式实现属性注入"><a href="#5、基于注解方式实现属性注入" class="headerlink" title="5、基于注解方式实现属性注入"></a>5、基于注解方式实现属性注入</h3><p> （1）@Autowired：根据属性类型进行自动装配</p>
<p> 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解</p>
<p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p>
<p>@Service<br>public class UserService {<br> //定义 dao 类型属性<br> //不需要添加 set 方法<br> //添加注入属性注解<br> @Autowired<br> private UserDao userDao;<br> public void add() {<br> System.out.println(“service add…….”);<br> userDao.add();<br> }<br>}</p>
<p>//Dao实现类<br>@Repository<br>//@Repository(value = “userDaoImpl1”)<br>public class UserDaoImpl implements UserDao {<br>    @Override<br>    public void add() {<br>        System.out.println(“dao add…..”);<br>    }<br>}</p>
<p> （2）@Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用</p>
<p>//定义 dao 类型属性<br>//不需要添加 set 方法<br>//添加注入属性注解<br>@Autowired //根据类型进行注入<br>//根据名称进行注入（目的在于区别同一接口下有多个实现类，根据类型就无法选择，从而出错！）<br>@Qualifier(value = “userDaoImpl1”)<br>private UserDao userDao;</p>
<p> （3）@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）</p>
<p>//@Resource //根据类型进行注入<br>@Resource(name = “userDaoImpl1”) //根据名称进行注入<br>private UserDao userDao;</p>
<p> （4）@Value：注入普通类型属性</p>
<p>@Value(value = “abc”)<br>private String name</p>
<h3 id="6、完全注解开发"><a href="#6、完全注解开发" class="headerlink" title="6、完全注解开发"></a>6、完全注解开发</h3><p> （1）创建配置类，替代 xml 配置文件</p>
<p>@Configuration //作为配置类，替代 xml 配置文件<br>@ComponentScan(basePackages = {“com.atguigu”})<br>public class SpringConfig {</p>
<p> （2）编写测试类</p>
<p>@Test<br>public void testService2() {<br> //加载配置类<br> ApplicationContext context<br> = new AnnotationConfigApplicationContext(SpringConfig.class);<br> UserService userService = context.getBean(“userService”,<br>UserService.class);<br> System.out.println(userService);<br> userService.add();<br>}</p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h2><h3 id="1、AOP-基本概念"><a href="#1、AOP-基本概念" class="headerlink" title="1、AOP 基本概念"></a>1、AOP 基本概念</h3><p> （1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p> （2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</p>
<p> （3）使用登录例子说明 AOP</p>
<h3 id="2、AOP（底层原理）"><a href="#2、AOP（底层原理）" class="headerlink" title="2、AOP（底层原理）"></a>2、AOP（底层原理）</h3><p> a）AOP 底层使用动态代理 ，动态代理有两种情况：</p>
<p>第一种 有接口情况，使用 JDK 动态代理 ；创建接口实现类代理对象，增强类的方法</p>
<p>第二种 没有接口情况，使用 CGLIB 动态代理；创建子类的代理对象，增强类的方法</p>
<h3 id="3、AOP（JDK-动态代理）"><a href="#3、AOP（JDK-动态代理）" class="headerlink" title="3、AOP（JDK 动态代理）"></a>3、AOP（JDK 动态代理）</h3><p> 1）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p>
<p>调用 newProxyInstance 方法，方法有三个参数：</p>
<p>public static Object newProxyInstance(ClassLoader loader,<br>                                      Class&lt;?&gt;[] interfaces,<br>                                      InvocationHandler h)</p>
<p> 第一参数，类加载器</p>
<p> 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</p>
<p> 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p>
<p> 2）编写 JDK 动态代理代码</p>
<p>//（1）创建接口，定义方法<br>public interface UserDao {<br> public int add(int a,int b);<br> public String update(String id);<br>}</p>
<p>//（2）创建接口实现类，实现方法<br>public class UserDaoImpl implements UserDao {<br> @Override<br> public int add(int a, int b) {<br> return a+b;<br> }<br> @Override<br> public String update(String id) {<br> return id;<br> }<br>}</p>
<p>//（3）使用 Proxy 类创建接口代理对象<br>public class JDKProxy {<br> public static void main(String[] args) {<br> //创建接口实现类代理对象<br> Class[] interfaces = {UserDao.class};<br> UserDaoImpl userDao = new UserDaoImpl();<br>/** 第一参数，类加载器<br>    第二参数，增强方法所在的类，这个类实现的接口，(支持多个接口)<br>    第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分  */<br> UserDao dao =(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<br>                    new UserDaoProxy(userDao));<br> int result = dao.add(1, 2);<br> System.out.println(“result:”+result);<br> }<br>}</p>
<p>//创建代理对象代码<br>class UserDaoProxy implements InvocationHandler {<br> //1 把创建的是谁的代理对象，把谁传递过来<br> //有参数构造传递<br> private Object obj;<br> public UserDaoProxy(Object obj) {<br> this.obj = obj;<br> }<br> //增强的逻辑<br> @Override<br> public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br> //方法之前<br> System.out.println(“方法之前执行….”+method.getName()+” :传递的参数…”+ Arrays.toString(args));<br> //被增强的方法执行<br> Object res = method.invoke(obj, args);<br> //方法之后<br> System.out.println(“方法之后执行….”+obj);<br> return res;<br> }<br>}</p>
<h3 id="4、AOP（术语）"><a href="#4、AOP（术语）" class="headerlink" title="4、AOP（术语）"></a>4、AOP（术语）</h3><p> a）连接点：类里面哪些方法可以被增强，这些方法称为连接点</p>
<p> b）切入点：实际被真正增强的方法称为切入点</p>
<p> c）通知（增强）：实际增强的逻辑部分称为通知，且分为以下五种类型：</p>
<p> 1）前置通知 2）后置通知 3）环绕通知 4）异常通知 5）最终通知</p>
<p> d）切面：把通知应用到切入点过程</p>
<h3 id="5、AOP操作"><a href="#5、AOP操作" class="headerlink" title="5、AOP操作"></a>5、AOP操作</h3><p> a）Spring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作</p>
<p> b）基于 AspectJ 实现 AOP 操作：1）基于 xml 配置文件实现 （2）基于注解方式实现（使用）</p>
<p> c）引入相关jar包</p>
<p> d）切入点表达式，如下：</p>
<p>（1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强<br>（2）语法结构： execution([权限修饰符] [返回类型] [类全路径] <a href="%5B%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%5D">方法名称</a> )<br>（3）例子如下：<br>    例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强<br>        execution(* com.atguigu.dao.BookDao.add(..))<br>     例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强<br>        execution(* com.atguigu.dao.BookDao.* (..))<br>    例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强<br>        execution(* com.atguigu.dao.<em>.</em> (..))</p>
<h3 id="6、AOP-操作（AspectJ-注解）"><a href="#6、AOP-操作（AspectJ-注解）" class="headerlink" title="6、AOP 操作（AspectJ 注解）"></a>6、AOP 操作（AspectJ 注解）</h3><p>//1、创建类，在类里面定义方法<br>public class User {<br> public void add() {<br> System.out.println(“add…….”);<br> }<br>}<br>//2、创建增强类（编写增强逻辑）<br>//（1）在增强类里面，创建方法，让不同方法代表不同通知类型<br>//增强的类<br>public class UserProxy {<br> public void before() {//前置通知<br> System.out.println(“before……”);<br> }<br>}</p>
<!--3、进行通知的配置-->

<?xml version="1.0" encoding="UTF-8"?>

<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"><br>    <!-- 开启注解扫描 --><br>    &lt;context:component-scan base-package=”com.atguigu.spring5.aopanno”&gt;</context:component-scan></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 开启Aspect生成代理对象--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure>

</beans>

<p>//增强的类<br>@Component<br>@Aspect  //生成代理对象<br>public class UserProxy {}</p>
<p>//被增强的类<br>@Component<br>public class User {}</p>
<p>//4、配置不同类型的通知<br>@Component<br>@Aspect  //生成代理对象<br>public class UserProxy {<br>      //相同切入点抽取<br>    @Pointcut(value = “execution(* com.atguigu.spring5.aopanno.User.add(..))”)<br>    public void pointdemo() {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//前置通知</span><br><span class="line">//@Before注解表示作为前置通知</span><br><span class="line">@Before(value = &quot;pointdemo()&quot;)//相同切入点抽取使用！</span><br><span class="line">public void before() &#123;</span><br><span class="line">    System.out.println(&quot;before.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后置通知（返回通知）</span><br><span class="line">@AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void afterReturning() &#123;</span><br><span class="line">    System.out.println(&quot;afterReturning.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最终通知</span><br><span class="line">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void after() &#123;</span><br><span class="line">    System.out.println(&quot;after.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//异常通知</span><br><span class="line">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void afterThrowing() &#123;</span><br><span class="line">    System.out.println(&quot;afterThrowing.........&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//环绕通知</span><br><span class="line">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span><br><span class="line">public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;环绕之前.........&quot;);</span><br><span class="line"></span><br><span class="line">    //被增强的方法执行</span><br><span class="line">    proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;环绕之后.........&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<h3 id="7、有多个增强类对同一个方法进行增强，设置增强类优先级"><a href="#7、有多个增强类对同一个方法进行增强，设置增强类优先级" class="headerlink" title="7、有多个增强类对同一个方法进行增强，设置增强类优先级"></a>7、有多个增强类对同一个方法进行增强，设置增强类优先级</h3><p>//（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高<br>@Component<br>@Aspect<br>@Order(1)<br>public class PersonProxy{ }</p>
<p>8、AOP 操作（AspectJ 配置文件）</p>
<!--1、创建两个类，增强类和被增强类，创建方法（同上一样）-->

<!--2、在 spring 配置文件中创建两个类对象-->

<!--创建对象-->

<p><bean id="book" class="com.atguigu.spring5.aopxml.Book"></bean><br><bean id="bookProxy" class="com.atguigu.spring5.aopxml.BookProxy"></bean></p>
<!--3、在 spring 配置文件中配置切入点-->

<!--配置 aop 增强-->

<p><a href="aop:config">aop:config</a><br> <!--切入点--><br> &lt;aop:pointcut id=”p” expression=”execution(* com.atguigu.spring5.aopxml.Book.buy(..))”/&gt;<br> <!--配置切面--><br> &lt;aop:aspect ref=”bookProxy”&gt;<br> <!--增强作用在具体的方法上--><br> &lt;aop:before method=”before” pointcut-ref=”p”/&gt;<br> </aop:aspect><br></aop:config></p>
<h2 id="在spring中使用JdbcTemplate进行数据库管理操作"><a href="#在spring中使用JdbcTemplate进行数据库管理操作" class="headerlink" title="在spring中使用JdbcTemplate进行数据库管理操作"></a>在spring中使用JdbcTemplate进行数据库管理操作</h2><p>JdbcTemplate</p>
<h3 id="1、JdbcTemplate概念及使用"><a href="#1、JdbcTemplate概念及使用" class="headerlink" title="1、JdbcTemplate概念及使用"></a>1、JdbcTemplate概念及使用</h3><p> a）Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
<p> b）引入相关 jar 包</p>
<p> c）在 spring 配置文件配置数据库连接池</p>
<p><bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
 destroy-method="close"><br> <property name="url" value="jdbc:mysql:///test" /><br> <property name="username" value="root" /><br> <property name="password" value="root" /><br> <property name="driverClassName" value="com.mysql.jdbc.Driver" /><br></bean></p>
<p> d）配置 JdbcTemplate 对象，注入 DataSource</p>
<!-- JdbcTemplate 对象 -->

<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
 <!--注入 dataSource-->
 <property name="dataSource" ref="dataSource"></property><!--set方式注入-->
</bean>

<p> e）创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象</p>
<!-- 组件扫描 -->

<p>&lt;context:component-scan base-package=”com.atguigu”&gt;</context:component-scan><br>@Service<br>public class BookService {<br> //注入 dao<br> @Autowired<br> private BookDao bookDao;<br>}</p>
<p>@Repository<br>public class BookDaoImpl implements BookDao {<br> //注入 JdbcTemplate<br> @Autowired<br> private JdbcTemplate jdbcTemplate;<br>}</p>
<h3 id="2、JdbcTemplate-操作数据库（添加）"><a href="#2、JdbcTemplate-操作数据库（添加）" class="headerlink" title="2、JdbcTemplate 操作数据库（添加）"></a>2、JdbcTemplate 操作数据库（添加）</h3><p> a）对应数据库创建实体类</p>
<p> b）创建service和dao</p>
<p> （1）在 dao 进行数据库添加操作</p>
<p> （2）调用 JdbcTemplate 对象里面 update 方法实现添加操作</p>
<p>@Repository<br>public class BookDaoImpl implements BookDao {<br> //注入 JdbcTemplate<br> @Autowired<br> private JdbcTemplate jdbcTemplate;<br> //添加的方法<br> @Override<br> public void add(Book book) {<br> //1 创建 sql 语句<br> String sql = “insert into t_book values(?,?,?)”;<br> //2 调用方法实现<br> Object[] args = {book.getUserId(), book.getUsername(),book.getUstatus()};<br> int update = jdbcTemplate.update(sql,args);<br> System.out.println(update);<br> }<br>}</p>
<h3 id="3、JdbcTemplate-操作数据库（修改和删除）"><a href="#3、JdbcTemplate-操作数据库（修改和删除）" class="headerlink" title="3、JdbcTemplate 操作数据库（修改和删除）"></a>3、JdbcTemplate 操作数据库（修改和删除）</h3><p>//1、修改<br>@Override<br>public void updateBook(Book book) {<br> String sql = “update t_book set username=?,ustatus=? where user_id=?”;<br> Object[] args = {book.getUsername(), book.getUstatus(),book.getUserId()};<br> int update = jdbcTemplate.update(sql, args);<br> System.out.println(update);<br>}<br>//2、删除<br>@Override<br>public void delete(String id) {<br> String sql = “delete from t_book where user_id=?”;<br> int update = jdbcTemplate.update(sql, id);<br> System.out.println(update);<br>}<br>//使用JdbcTemplate 模板所实现的 “增删改” 都是调用了同一个 “update” 方法</p>
<h3 id="4、JdbcTemplate-操作数据库（查询返回某个值）"><a href="#4、JdbcTemplate-操作数据库（查询返回某个值）" class="headerlink" title="4、JdbcTemplate 操作数据库（查询返回某个值）"></a>4、JdbcTemplate 操作数据库（查询返回某个值）</h3><p>//查询表记录数<br>@Override<br>public int selectCount() {<br> String sql = “select count(*) from t_book”;<br>//queryForObject方法中：第一个参数代表–sql语句；第二个参数代表–返回类型class<br> Integer count = jdbcTemplate.queryForObject(sql, Integer.class);<br> return count;<br>}<br>JdbcTemplate 操作数据库（</p>
<h3 id="5、JdbcTemplate-操作数据库（查询返回对象）"><a href="#5、JdbcTemplate-操作数据库（查询返回对象）" class="headerlink" title="5、JdbcTemplate 操作数据库（查询返回对象）"></a>5、JdbcTemplate 操作数据库（查询返回对象）</h3><p>//查询返回对象<br>@Override<br>public Book findBookInfo(String id) {<br> String sql = “select * from t_book where user_id=?”;<br> //调用方法<br>/*<br>    queryForObject方法中：<br>        第一个参数：sql语句<br>        第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面 实现类 完成数据封装<br>        第三个参数：sql 语句值<br>*/<br> Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<Book>(Book.class), id);<br> return book;<br>}</p>
<h3 id="6、JdbcTemplate-操作数据库（查询返回集合）"><a href="#6、JdbcTemplate-操作数据库（查询返回集合）" class="headerlink" title="6、JdbcTemplate 操作数据库（查询返回集合）"></a>6、JdbcTemplate 操作数据库（查询返回集合）</h3><p>//所用场景：查询图书列表分页、、<br>//查询返回集合<br>@Override<br>public List<Book> findAllBook() {<br> String sql = “select * from t_book”;<br> //调用方法<br> List<Book> bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper<Book>(Book.class));<br> return bookList;<br>}</p>
<h3 id="7、JdbcTemplate-操作数据库（批量操作）"><a href="#7、JdbcTemplate-操作数据库（批量操作）" class="headerlink" title="7、JdbcTemplate 操作数据库（批量操作）"></a>7、JdbcTemplate 操作数据库（批量操作）</h3><p>//批量添加<br>@Override<br>public void batchAddBook(List&lt;Object[]&gt; batchArgs) {<br> String sql = “insert into t_book values(?,?,?)”;<br>//batchUpdate方法 第一个参数：sql语句        第二个参数：List集合，添加多条记录数据<br> int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);<br> System.out.println(Arrays.toString(ints));<br>}</p>
<p>//批量添加测试<br>List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();<br>Object[] o1 = {“3”,”java”,”a”};<br>Object[] o2 = {“4”,”c++”,”b”};<br>Object[] o3 = {“5”,”MySQL”,”c”};<br>batchArgs.add(o1);<br>batchArgs.add(o2);<br>batchArgs.add(o3);<br>//调用批量添加<br>bookService.batchAdd(batchArgs);</p>
<h3 id="8、JdbcTemplate-实现批量修改操作"><a href="#8、JdbcTemplate-实现批量修改操作" class="headerlink" title="8、JdbcTemplate 实现批量修改操作"></a>8、JdbcTemplate 实现批量修改操作</h3><p>//批量修改(同批量添加一样，调用同一个方法)<br>@Override<br>public void batchUpdateBook(List&lt;Object[]&gt; batchArgs) {<br> String sql = “update t_book set username=?,ustatus=? where user_id=?”;<br> int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);<br> System.out.println(Arrays.toString(ints));<br>}</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库知识点</title>
    <url>/2021/06/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li>事务的四大特性？</li>
<li>数据库的三大范式</li>
<li>事务隔离级别有哪些？</li>
<li>索引<span id="more"></span>
<ul>
<li>什么是索引？</li>
<li>索引的优缺点？</li>
<li>索引的作用？</li>
<li>什么情况下需要建索引？</li>
<li>什么情况下不建索引？</li>
<li>索引的数据结构</li>
<li>Hash索引和B+树索引的区别？</li>
<li>为什么B+树比B树更适合实现数据库索引？</li>
<li>索引有什么分类？</li>
<li>什么是最左匹配原则？</li>
<li>什么是聚集索引？</li>
<li>什么是覆盖索引？</li>
<li>索引的设计原则？</li>
<li>索引什么时候会失效？</li>
<li>什么是前缀索引？</li>
</ul>
</li>
<li>常见的存储引擎有哪些？</li>
<li>MyISAM和InnoDB的区别？</li>
<li>MVCC 实现原理？</li>
<li>快照读和当前读</li>
<li>共享锁和排他锁</li>
<li>大表怎么优化？</li>
<li>MySQL 执行计划了解吗？</li>
<li>bin log/redo log/undo log</li>
<li>bin log和redo log有什么区别？</li>
<li>讲一下MySQL架构？</li>
<li>分库分表</li>
<li>什么是分区表？</li>
<li>分区表类型</li>
<li>分区的问题？</li>
<li>查询语句执行流程？</li>
<li>更新语句执行过程？</li>
<li>exist和in的区别？</li>
<li>MySQL中int(10)和char(10)的区别？　</li>
<li>truncate、delete与drop区别？</li>
<li>having和where区别？</li>
<li>什么是MySQL主从同步？</li>
<li>为什么要做主从同步？</li>
<li>乐观锁和悲观锁是什么？</li>
<li>用过processlist吗？</li>
</ul>
<h2 id="事务的四大特性？"><a href="#事务的四大特性？" class="headerlink" title="事务的四大特性？"></a>事务的四大特性？</h2><p><strong>事务特性ACID</strong>：<strong>原子性</strong>（<code>Atomicity</code>）、<strong>一致性</strong>（<code>Consistency</code>）、<strong>隔离性</strong>（<code>Isolation</code>）、<strong>持久性</strong>（<code>Durability</code>）。</p>
<ul>
<li><strong>原子性</strong>是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性</strong>是指一个事务执行之前和执行之后都必须处于一致性状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。</li>
<li><strong>隔离性</strong>。跟隔离级别相关，如<code>read committed</code>，一个事务只能读到已经提交的修改。</li>
<li><strong>持久性</strong>是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h2 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h2><p><strong>第一范式1NF</strong></p>
<p>确保数据库表字段的原子性。</p>
<p>比如字段 <code>userInfo</code>: <code>广东省 10086&#39;</code> ，依照第一范式必须拆分成 <code>userInfo</code>: <code>广东省</code> <code>userTel</code>:<code>10086</code>两个字段。</p>
<p><strong>第二范式2NF</strong></p>
<p>首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。</p>
<p>举个例子。假定选课关系表为<code>student_course</code>(student_no, student_name, age, course_name, grade, credit)，主键为(student_no, course_name)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式，会导致数据冗余（学生选n门课，姓名年龄有n条记录）、插入异常（插入一门新课，因为没有学号，无法保存新课记录）等问题。</p>
<p>可以拆分成三个表：学生：<code>student</code>(stuent_no, student_name, 年龄)；课程：<code>course</code>(course_name, credit)；选课关系：<code>student_course_relation</code>(student_no, course_name, grade)。</p>
<p><strong>第三范式3NF</strong></p>
<p>首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p>
<p>假定学生关系表为Student(student_no, student_name, age, academy_id, academy_telephone)，主键为”学号”，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。</p>
<p>可以把学生关系表分为如下两个表：学生：(student_no, student_name, age, academy_id)；学院：(academy_id, academy_telephone)。</p>
<p><strong>2NF和3NF的区别？</strong></p>
<ul>
<li>2NF依据是非主键列是否完全依赖于主键，还是依赖于主键的一部分。</li>
<li>3NF依据是非主键列是直接依赖于主键，还是直接依赖于非主键。</li>
</ul>
<h2 id="事务隔离级别有哪些？"><a href="#事务隔离级别有哪些？" class="headerlink" title="事务隔离级别有哪些？"></a>事务隔离级别有哪些？</h2><p>先了解下几个概念：脏读、不可重复读、幻读。</p>
<ul>
<li><strong>脏读</strong>是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li>
<li><strong>不可重复读</strong>是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。</li>
<li><strong>幻读</strong>是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。</li>
</ul>
<p><strong>不可重复读和脏读的区别</strong>是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p>事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。</p>
<p>MySQL数据库为我们提供的四种隔离级别：</p>
<ul>
<li><strong>Serializable</strong> (串行化)：通过强制事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>，使之不可能相互冲突，从而解决幻读问题。</li>
<li><strong>Repeatable read</strong> (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。</li>
<li><strong>Read committed</strong> (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。</li>
<li><strong>Read uncommitted</strong> (读未提交)：所有事务都可以看到其他未提交事务的执行结果。</li>
</ul>
<p>查看隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `@@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p>设置隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set` `session ``transaction` `isolation` `level` `read` `uncommitted``;</span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>。</p>
<h3 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h3><p>优点：</p>
<ul>
<li><strong>加快数据查找的速度</strong></li>
<li>为用来<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>或者是分组的字段添加索引，可以加快分组和<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>的速度</li>
<li>加快表与表之间的连接</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立索引需要<strong>占用物理空间</strong></li>
<li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li>
</ul>
<h3 id="索引的作用？"><a href="#索引的作用？" class="headerlink" title="索引的作用？"></a>索引的作用？</h3><p>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</p>
<h3 id="什么情况下需要建索引？"><a href="#什么情况下需要建索引？" class="headerlink" title="什么情况下需要建索引？"></a>什么情况下需要建索引？</h3><ol>
<li>经常用于查询的字段</li>
<li>经常用于连接的字段建立索引，可以加快连接的速度</li>
<li>经常需要<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>的字段建立索引，因为索引已经排好序，可以加快<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>查询速度</li>
</ol>
<h3 id="什么情况下不建索引？"><a href="#什么情况下不建索引？" class="headerlink" title="什么情况下不建索引？"></a>什么情况下不建索引？</h3><ol>
<li><code>where</code>条件中用不到的字段不适合建立索引</li>
<li>表记录较少</li>
<li>需要经常增删改</li>
<li><strong>参与列计算</strong>的列不适合建索引</li>
<li><strong>区分度不高</strong>的字段不适合建立索引，如性别等</li>
</ol>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>索引的数据结构主要有B+树和<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。</p>
<p><strong>B+树索引</strong></p>
<p>B+ 树是基于B 树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ 树中，节点中的 <code>key</code> 从左到右递增排列，如果某个指针的左右相邻 <code>key</code> 分别是 keyi 和 keyi+1，则该指针指向节点的所有 <code>key</code> 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507955/B%E6%A0%91%E7%B4%A2%E5%BC%950.png" alt="img"></p>
<p>进行查找操作时，首先在根节点进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>，找到<code>key</code>所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">二分查找</a>，找出<code>key</code>所对应的数据项。</p>
<p>MySQL 数据库使用最多的索引类型是<code>BTREE</code>索引，底层基于B+树数据结构来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show ``index` `from` `blog\G;``*************************** 1. row ***************************``    ``Table``: blog``  ``Non_unique: 0``   ``Key_name: ``PRIMARY`` ``Seq_in_index: 1`` ``Column_name: blog_id``  ``Collation: A`` ``Cardinality: 4``   ``Sub_part: ``NULL``    ``Packed: ``NULL``     ``Null``:``  ``Index_type: BTREE``   ``Comment:``Index_comment:``   ``Visible: YES``  ``Expression: ``NULL</span><br></pre></td></tr></table></figure>

<p><strong>哈希索引</strong></p>
<p>哈希索引是基于<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>的key值，将指向数据行的指针作为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</p>
<h3 id="Hash索引和B-树索引的区别？"><a href="#Hash索引和B-树索引的区别？" class="headerlink" title="Hash索引和B+树索引的区别？"></a>Hash索引和B+树索引的区别？</h3><ul>
<li>哈希索引**不支持<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>**，因为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>是无序的。</li>
<li>哈希索引<strong>不支持范围查找</strong>。</li>
<li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li>
<li>因为<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>中会<strong>存在哈希冲突</strong>，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li>
</ul>
<h3 id="为什么B-树比B树更适合实现数据库索引？"><a href="#为什么B-树比B树更适合实现数据库索引？" class="headerlink" title="为什么B+树比B树更适合实现数据库索引？"></a>为什么B+树比B树更适合实现数据库索引？</h3><ul>
<li>由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</li>
<li>B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</li>
<li>B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h3 id="索引有什么分类？"><a href="#索引有什么分类？" class="headerlink" title="索引有什么分类？"></a>索引有什么分类？</h3><p>1、<strong>主键索引</strong>：名为primary的唯一非空索引，不允许有空值。</p>
<p>2、<strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一约束的列可以为<code>null</code>且可以存在多个<code>null</code>值。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。创建唯一索引的SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER` `TABLE` `table_name``ADD` `CONSTRAINT` `constraint_name ``UNIQUE` `KEY``(column_1,column_2,...);</span><br></pre></td></tr></table></figure>

<p>3、<strong>组合索引</strong>：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时需遵循最左前缀原则。</p>
<p>4、<strong>全文索引</strong>：只有在<code>MyISAM</code>引擎上才能使用，只能在<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>类型字段上使用全文索引。</p>
<h3 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a>什么是最左匹配原则？</h3><p>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就会停止匹配，后面的字段不会用到索引。</p>
<p>对<code>(a,b,c)</code>建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。</p>
<p>对<code>(a,b,c,d)</code>建立索引，查询条件为<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。</p>
<p>如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>）。直接执行<code>b = 2</code>这种查询条件无法使用索引。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507953/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80.png" alt="最左前缀"></p>
<p>当a的值确定的时候，b是有序的。例如<code>a = 1</code>时，b值为1，2是有序的状态。当<code>a = 2</code>时候，b的值为1，4也是有序状态。 当执行<code>a = 1 and b = 2</code>时a和b字段能用到索引。而执行<code>a &gt; 1 and b = 2</code>时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段无法使用索引。</p>
<h3 id="什么是聚集索引？"><a href="#什么是聚集索引？" class="headerlink" title="什么是聚集索引？"></a>什么是聚集索引？</h3><p>InnoDB使用表的主键构造主键索引树，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>连接，叶子节点按照主键的顺序<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>，因此对于主键的<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>查找和范围查找速度比较快。</p>
<p>聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</p>
<p>对于<code>InnoDB</code>来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为<code>NULL</code>的唯一索引。如果没有主键也没有合适的唯一索引，那么<code>InnoDB</code>内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。</p>
<h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p><code>select</code>的数据列只用从索引中就能够取得，不需要<strong>回表</strong>进行二次查询，也就是说查询列要被所使用的索引覆盖。对于<code>innodb</code>表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</p>
<p>不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</p>
<p>对于使用了覆盖索引的查询，在查询前面使用<code>explain</code>，输出的extra列会显示为<code>using index</code>。</p>
<p>比如<code>user_like</code> 用户点赞表，组合索引为<code>(user_id, blog_id)</code>，<code>user_id</code>和<code>blog_id</code>都不为<code>null</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain ``select` `blog_id ``from` `user_like ``where` `user_id = 13;</span><br></pre></td></tr></table></figure>

<p><code>explain</code>结果的<code>Extra</code>列为<code>Using index</code>，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过<strong>索引查找</strong>就能直接找到符合条件的数据，不需要回表查询数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain ``select` `user_id ``from` `user_like ``where` `blog_id = 1;</span><br></pre></td></tr></table></figure>

<p><code>explain</code>结果的<code>Extra</code>列为<code>Using where; Using index</code>， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过<strong>索引扫描</strong>找到符合条件的数据，也不需要回表查询数据。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507903/cover-index.png" alt="img"></p>
<h3 id="索引的设计原则？"><a href="#索引的设计原则？" class="headerlink" title="索引的设计原则？"></a>索引的设计原则？</h3><ul>
<li>索引列的<strong>区分度越高</strong>，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。</li>
<li>尽量使用<strong>短索引</strong>，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。</li>
<li>索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。</li>
<li>利用<strong>最左前缀原则</strong>。</li>
</ul>
<h3 id="索引什么时候会失效？"><a href="#索引什么时候会失效？" class="headerlink" title="索引什么时候会失效？"></a>索引什么时候会失效？</h3><p>导致索引失效的情况：</p>
<ul>
<li>对于组合索引，不是使用组合索引最左边的字段，则不会使用索引</li>
<li>以%开头的like查询如<code>%abc</code>，无法使用索引；非%开头的like查询如<code>abc%</code>，相当于范围查询，会使用索引</li>
<li>查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效</li>
<li>判断索引列是否不等于某个值时</li>
<li>对索引列进行运算</li>
<li>查询条件使用<code>or</code>连接，也会导致索引失效</li>
</ul>
<h3 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h3><p>有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。</p>
<p>前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。</p>
<p>创建前缀索引的关键在于选择足够长的前缀以<strong>保证较高的索引选择性</strong>。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。</p>
<p>建立前缀索引的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// email列创建前缀索引``ALTER` `TABLE` `table_name ``ADD` `KEY``(column_name(prefix_length));</span><br></pre></td></tr></table></figure>

<h2 id="常见的存储引擎有哪些？"><a href="#常见的存储引擎有哪些？" class="headerlink" title="常见的存储引擎有哪些？"></a>常见的存储引擎有哪些？</h2><p>MySQL中常用的四种存储引擎分别是： <strong>MyISAM</strong>、<strong>InnoDB</strong>、<strong>MEMORY</strong>、<strong>ARCHIVE</strong>。MySQL 5.5版本后默认的存储引擎为<code>InnoDB</code>。</p>
<p><strong>InnoDB存储引擎</strong></p>
<p>InnoDB是MySQL<strong>默认的事务型存储引擎</strong>，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</p>
<p><strong>优点</strong>：支持事务和崩溃修复能力；引入了行级锁和外键约束。</p>
<p><strong>缺点</strong>：占用的数据空间相对较大。</p>
<p><strong>适用场景</strong>：需要事务支持，并且有较高的并发读写频率。</p>
<p><strong>MyISAM存储引擎</strong></p>
<p>数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件<code>.MYD</code>和索引文件<code>.MYI</code>。</p>
<p><strong>优点</strong>：访问速度快。</p>
<p><strong>缺点</strong>：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</p>
<p><strong>适用场景</strong>：对事务完整性没有要求；表的数据都会只读的。</p>
<p><strong>MEMORY存储引擎</strong></p>
<p>MEMORY引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。</p>
<p>MEMORY引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。</p>
<p><strong>优点</strong>：访问速度较快。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>哈希索引数据不是按照索引值顺序存储，无法用于<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>。</li>
<li>不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。</li>
<li>只支持等值比较，不支持范围查询。</li>
<li>当出现哈希冲突时，存储引擎需要遍历<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中所有的行指针，逐行进行比较，直到找到符合条件的行。</li>
</ol>
<p><strong>ARCHIVE存储引擎</strong></p>
<p>ARCHIVE存储引擎非常适合存储大量独立的、作为历史记录的数据。ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差。</p>
<h2 id="MyISAM和InnoDB的区别？"><a href="#MyISAM和InnoDB的区别？" class="headerlink" title="MyISAM和InnoDB的区别？"></a>MyISAM和InnoDB的区别？</h2><ol>
<li><strong>是否支持行级锁</strong> : <code>MyISAM</code> 只有表级锁，而<code>InnoDB</code> 支持行级锁和表级锁，默认为行级锁。</li>
<li><strong>是否支持事务和崩溃后的安全恢复</strong>： <code>MyISAM</code> 不提供事务支持。而<code>InnoDB</code>提供事务支持，具有事务、回滚和崩溃修复能力。</li>
<li><strong>是否支持外键：</strong> <code>MyISAM</code>不支持，而<code>InnoDB</code>支持。</li>
<li><strong>是否支持MVCC</strong> ：<code>MyISAM</code>不支持，<code>InnoDB</code>支持。应对高并发事务，MVCC比单纯的加锁更高效。</li>
<li><code>MyISAM</code>不支持聚集索引，<code>InnoDB</code>支持聚集索引。</li>
</ol>
<h2 id="MVCC-实现原理？"><a href="#MVCC-实现原理？" class="headerlink" title="MVCC 实现原理？"></a>MVCC 实现原理？</h2><p>MVCC(<code>Multiversion concurrency control</code>) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过<code>read view</code>和版本链找到对应版本的数据。</p>
<p>作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。</p>
<p><strong>MVCC 实现原理如下：</strong></p>
<p>MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。</p>
<ul>
<li><code>DB_TRX_ID</code>：当前事务id，通过事务id的大小判断事务的时间顺序。</li>
<li><code>DB_ROLL_PRT</code>：回滚指针，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成<code>undo log</code>版本链。</li>
<li><code>DB_ROLL_ID</code>：主键，如果数据表没有主键，InnoDB会自动生成主键。</li>
</ul>
<p>每条表记录大概是这样的：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507911/mvcc9.png" alt="img"></p>
<p>使用事务更新行记录的时候，就会生成版本链，执行过程如下：</p>
<ol>
<li>用排他锁锁住该行；</li>
<li>将该行原本的值拷贝到<code>undo log</code>，作为旧版本用于回滚；</li>
<li>修改当前行的值，生成一个新版本，更新事务id，使回滚指针指向旧版本的记录，这样就形成一条版本链。</li>
</ol>
<p>下面举个例子方便大家理解。</p>
<p>1、初始数据如下，其中<code>DB_ROW_ID</code>和<code>DB_ROLL_PTR</code>为空。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507923/mvcc2.png" alt="img"></p>
<p>2、事务A对该行数据做了修改，将<code>age</code>修改为12，效果如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507957/mvcc7.png" alt="img"></p>
<p>3、之后事务B也对该行记录做了修改，将<code>age</code>修改为8，效果如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941509427/mvcc11.png" alt="img"></p>
<p>4、此时undo log有两行记录，并且通过回滚指针连在一起。</p>
<p><strong>接下来了解下read view的概念。</strong></p>
<p><code>read view</code>可以理解成将数据在每个时刻的状态拍成“照片”记录下来。在获取某时刻t的数据时，到t时间点拍的“照片”上取数据。</p>
<p>在<code>read view</code>内部维护一个活跃事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>，表示生成<code>read view</code>的时候还在活跃的事务。这个<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>包含在创建<code>read view</code>之前还未提交的事务，不包含创建<code>read view</code>之后提交的事务。</p>
<p>不同隔离级别创建read view的时机不同。</p>
<ul>
<li>read committed：每次执行select都会创建新的read_view，保证能读取到其他事务已经提交的修改。</li>
<li>repeatable read：在一个事务范围内，第一次select时更新这个read_view，以后不会再更新，后续所有的select都是复用之前的read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。</li>
</ul>
<p><strong>read view的记录筛选方式</strong></p>
<p><strong>前提</strong>：<code>DATA_TRX_ID</code> 表示每个数据行的最新的事务ID；<code>up_limit_id</code>表示当前快照中的最先开始的事务；<code>low_limit_id</code>表示当前快照中的最慢开始的事务，即最后一个事务。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507929/read_view10.png" alt="img"></p>
<ul>
<li><p>如果<code>DATA_TRX_ID</code> &lt; <code>up_limit_id</code>：说明在创建<code>read view</code>时，修改该数据行的事务已提交，该版本的记录可被当前事务读取到。</p>
</li>
<li><p>如果<code>DATA_TRX_ID</code> &gt;= <code>low_limit_id</code>：说明当前版本的记录的事务是在创建<code>read view</code>之后生成的，该版本的数据行不可以被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本的记录对当前事务的可见性。</p>
</li>
<li><p>如果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up_limit_id</span><br></pre></td></tr></table></figure>

<p>&lt;=</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA_TRX_ID</span><br></pre></td></tr></table></figure>

<p>&lt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">low_limit_i</span><br></pre></td></tr></table></figure>

<p>：</p>
<ol>
<li>需要在活跃事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中查找是否存在ID为<code>DATA_TRX_ID</code>的值的事务。</li>
<li>如果存在，因为在活跃事务<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中的事务是未提交的，所以该记录是不可见的。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。</li>
<li>如果不存在，说明事务trx_id 已经提交了，这行记录是可见的。</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：InnoDB 的<code>MVCC</code>是通过 <code>read view</code> 和版本链实现的，版本链保存有历史版本记录，通过<code>read view</code> 判断当前版本的数据是否可见，如果不可见，再从版本链中找到上一个版本，继续进行判断，直到找到一个可见的版本。</p>
<h2 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h2><p>表记录有两种读取方式。</p>
<ul>
<li>快照读：读取的是快照版本。普通的<code>SELECT</code>就是快照读。通过mvcc来进行并发控制的，不用加锁。</li>
<li>当前读：读取的是最新版本。<code>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE</code>是当前读。</li>
</ul>
<p>快照读情况下，InnoDB通过<code>mvcc</code>机制避免了幻读现象。而<code>mvcc</code>机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。</p>
<p>下面举个例子说明下：</p>
<p>1、首先，user表只有两条记录，具体如下：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507925/image-20210922232259664.png" alt="img"></p>
<p>2、事务a和事务b同时开启事务<code>start transaction</code>；</p>
<p>3、事务a插入数据然后提交；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert` `into` `user``(user_name, user_password, user_mail, user_state) ``values``(``&#x27;tyson&#x27;``, ``&#x27;a&#x27;``, ``&#x27;a&#x27;``, 0);</span><br></pre></td></tr></table></figure>

<p>4、事务b执行全表的update；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update` `user` `set` `user_name = ``&#x27;a&#x27;``;</span><br></pre></td></tr></table></figure>

<p>5、事务b然后执行查询，查到了事务a中插入的数据。（下图左边是事务b，右边是事务a。事务开始之前只有两条记录，事务a插入一条数据之后，事务b查询出来是三条数据）</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941507965/%E5%B9%BB%E8%AF%BB1.png" alt="img"></p>
<p>以上就是当前读出现的幻读现象。</p>
<p><strong>那么MySQL是如何避免幻读？</strong></p>
<ul>
<li>在快照读情况下，MySQL通过<code>mvcc</code>来避免幻读。</li>
<li>在当前读情况下，MySQL通过<code>next-key</code>来避免幻读（加行锁和间隙锁来实现的）。</li>
</ul>
<p>next-key包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。</p>
<p><code>Serializable</code>隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。</p>
<h2 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h2><p>SELECT 的读取锁定主要分为两种方式：共享锁和排他锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `* ``from` `table` `where` `id&lt;6 lock ``in` `share mode;``--共享锁``select` `* ``from` `table` `where` `id&lt;6 ``for` `update``;``--排他锁</span><br></pre></td></tr></table></figure>

<p>这两种方式主要的不同在于<code>LOCK IN SHARE MODE</code>多个事务同时更新同一个表单时很容易造成死锁。</p>
<p>申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被<code>commit</code>语句或<code>rollback</code>语句结束为止。</p>
<p><code>SELECT... FOR UPDATE</code> 使用注意事项：</p>
<ol>
<li><code>for update</code> 仅适用于innodb，且必须在事务范围内才能生效。</li>
<li>根据主键进行查询，查询条件为<code>like</code>或者不等于，主键字段产生<strong>表锁</strong>。</li>
<li>根据非索引字段进行查询，会产生<strong>表锁</strong>。</li>
</ol>
<h2 id="大表怎么优化？"><a href="#大表怎么优化？" class="headerlink" title="大表怎么优化？"></a>大表怎么优化？</h2><p>某个表有近千万数据，查询比较慢，如何优化？</p>
<p>当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下：</p>
<ul>
<li>限定数据的范围。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内；</li>
<li>读写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li>通过分库分表的方式进行优化，主要有垂直拆分和水平拆分。</li>
</ul>
<h2 id="bin-log-redo-log-undo-log"><a href="#bin-log-redo-log-undo-log" class="headerlink" title="bin log/redo log/undo log"></a>bin log/redo log/undo log</h2><p>MySQL日志主要包括查询日志、慢查询日志、事务日志、错误日志、二进制日志等。其中比较重要的是 <code>bin log</code>（二进制日志）和 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<p><strong>bin log</strong></p>
<p><code>bin log</code>是MySQL数据库级别的文件，记录对MySQL数据库执行修改的所有操作，不会记录select和show语句，主要用于恢复数据库和同步数据库。</p>
<p><strong>redo log</strong></p>
<p><code>redo log</code>是innodb引擎级别，用来记录innodb存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障，innoDB存储引擎会使用<code>redo log</code>恢复到发生故障前的时刻，以此来保证数据的完整性。将参数<code>innodb_flush_log_at_tx_commit</code>设置为1，那么在执行commit时会将<code>redo log</code>同步写到磁盘。</p>
<p><strong>undo log</strong></p>
<p>除了记录<code>redo log</code>外，当进行数据修改时还会记录<code>undo log</code>，<code>undo log</code>用于数据的撤回操作，它保留了记录修改前的内容。通过<code>undo log</code>可以实现事务回滚，并且可以根据<code>undo log</code>回溯到某个特定的版本的数据，<strong>实现MVCC</strong>。</p>
<h2 id="bin-log和redo-log有什么区别？"><a href="#bin-log和redo-log有什么区别？" class="headerlink" title="bin log和redo log有什么区别？"></a>bin log和redo log有什么区别？</h2><ol>
<li><code>bin log</code>会记录所有日志记录，包括InnoDB、MyISAM等存储引擎的日志；<code>redo log</code>只记录innoDB自身的事务日志。</li>
<li><code>bin log</code>只在事务提交前写入到磁盘，一个事务只写一次；而在事务进行过程，会有<code>redo log</code>不断写入磁盘。</li>
<li><code>bin log</code>是逻辑日志，记录的是SQL语句的原始逻辑；<code>redo log</code>是物理日志，记录的是在某个数据页上做了什么修改。</li>
</ol>
<h2 id="讲一下MySQL架构？"><a href="#讲一下MySQL架构？" class="headerlink" title="讲一下MySQL架构？"></a>讲一下MySQL架构？</h2><p>MySQL主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。</li>
</ul>
<p><strong>Server 层基本组件</strong></p>
<ul>
<li><strong>连接器：</strong> 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。</li>
<li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。</li>
<li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。</li>
<li><strong>执行器：</strong> 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>当单表的数据量达到1000W或100G以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。</p>
<p>数据切分可以分为两种方式：垂直划分和水平划分。</p>
<p><strong>垂直划分</strong></p>
<p>垂直划分数据库是根据业务进行划分，例如购物场景，可以将库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，可以将商品基本信息和商品描述拆分成两张表。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941508067/%E5%9E%82%E7%9B%B4%E5%88%92%E5%88%86.png" alt="img"></p>
<p><strong>优点</strong>：行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>主键出现冗余，需要管理冗余列；</li>
<li>会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力；</li>
<li>依然存在单表数据量过大的问题。</li>
</ul>
<p><strong>水平划分</strong></p>
<p>水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20211103/530285728_1635941508121/%E6%B0%B4%E5%B9%B3%E5%88%92%E5%88%86.png" alt="img"></p>
<p><strong>优点</strong>：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>分片事务一致性难以解决</li>
<li>跨节点<code>join</code>性能差，逻辑复杂</li>
<li>数据分片在扩容时需要迁移</li>
</ul>
<h2 id="什么是分区表？"><a href="#什么是分区表？" class="headerlink" title="什么是分区表？"></a>什么是分区表？</h2><p>分区表是一个独立的逻辑表，但是底层由多个物理子表组成。</p>
<p>当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可。</p>
<h2 id="分区表类型"><a href="#分区表类型" class="headerlink" title="分区表类型"></a>分区表类型</h2><p><strong>按照范围分区。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_range_partition(``    ``id INT auto_increment,``    ``createdate DATETIME,``    ``primary key (id,createdate)``  ``)``  ``PARTITION BY RANGE (TO_DAYS(createdate) ) (``   ``PARTITION p201801 VALUES LESS THAN ( TO_DAYS(``&#x27;20180201&#x27;``) ),``   ``PARTITION p201802 VALUES LESS THAN ( TO_DAYS(``&#x27;20180301&#x27;``) ),``   ``PARTITION p201803 VALUES LESS THAN ( TO_DAYS(``&#x27;20180401&#x27;``) ),``   ``PARTITION p201804 VALUES LESS THAN ( TO_DAYS(``&#x27;20180501&#x27;``) ),``   ``PARTITION p201805 VALUES LESS THAN ( TO_DAYS(``&#x27;20180601&#x27;``) ),``   ``PARTITION p201806 VALUES LESS THAN ( TO_DAYS(``&#x27;20180701&#x27;``) ),``   ``PARTITION p201807 VALUES LESS THAN ( TO_DAYS(``&#x27;20180801&#x27;``) ),``   ``PARTITION p201808 VALUES LESS THAN ( TO_DAYS(``&#x27;20180901&#x27;``) ),``   ``PARTITION p201809 VALUES LESS THAN ( TO_DAYS(``&#x27;20181001&#x27;``) ),``   ``PARTITION p201810 VALUES LESS THAN ( TO_DAYS(``&#x27;20181101&#x27;``) ),``   ``PARTITION p201811 VALUES LESS THAN ( TO_DAYS(``&#x27;20181201&#x27;``) ),``   ``PARTITION p201812 VALUES LESS THAN ( TO_DAYS(``&#x27;20190101&#x27;``) )``  ``);</span><br></pre></td></tr></table></figure>

<p>在<code>/var/lib/mysql/data/</code>可以找到对应的数据文件，每个分区表都有一个使用#分隔命名的表文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``-rw-r----- ``1` `MySQL MySQL  ``65` `Mar ``14` `21``:``47` `db.opt``  ``-rw-r----- ``1` `MySQL MySQL ``8598` `Mar ``14` `21``:``50` `test_range_partition.frm``  ``-rw-r----- ``1` `MySQL MySQL ``98304` `Mar ``14` `21``:``50` `test_range_partition#P#p201801.ibd``  ``-rw-r----- ``1` `MySQL MySQL ``98304` `Mar ``14` `21``:``50` `test_range_partition#P#p201802.ibd``  ``-rw-r----- ``1` `MySQL MySQL ``98304` `Mar ``14` `21``:``50` `test_range_partition#P#p201803.ibd``...</span><br></pre></td></tr></table></figure>

<p><strong>list分区</strong></p>
<p>对于<code>List</code>分区，分区字段必须是已知的，如果插入的字段不在分区时枚举值中，将无法插入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test_list_partiotion``  ``(``    ``id ``int` `auto_increment,``    ``data_type tinyint,``    ``primary key(id,data_type)``  ``)partition by list(data_type)``  ``(``    ``partition p0 values in (``0``,``1``,``2``,``3``,``4``,``5``,``6``),``    ``partition p1 values in (``7``,``8``,``9``,``10``,``11``,``12``),``    ``partition p2 values in (``13``,``14``,``15``,``16``,``17``)``  ``);</span><br></pre></td></tr></table></figure>

<p><strong>hash分区</strong></p>
<p>可以将数据均匀地分布到预先定义的分区中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test_hash_partiotion``  ``(``    ``id ``int` `auto_increment,``    ``create_date datetime,``    ``primary key(id,create_date)``  ``)partition by hash(year(create_date)) partitions ``10``;</span><br></pre></td></tr></table></figure>

<h2 id="分区的问题？"><a href="#分区的问题？" class="headerlink" title="分区的问题？"></a>分区的问题？</h2><ol>
<li>打开和锁住所有底层表的成本可能很高。当查询访问分区表时，MySQL 需要打开并锁住所有的底层表，这个操作在分区过滤之前发生，所以无法通过分区过滤来降低此开销，会影响到查询速度。可以通过批量操作来降低此类开销，比如批量插入、<code>LOAD DATA INFILE</code>和一次删除多行数据。</li>
<li>维护分区的成本可能很高。例如重组分区，会先创建一个临时分区，然后将数据复制到其中，最后再删除原分区。</li>
<li>所有分区必须使用相同的存储引擎。</li>
</ol>
<h2 id="查询语句执行流程？"><a href="#查询语句执行流程？" class="headerlink" title="查询语句执行流程？"></a>查询语句执行流程？</h2><p>查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。</p>
<p>举个例子，查询语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `* ``from` `user` `where` `id &gt; 1 ``and` `name` `= ``&#x27;大彬&#x27;``;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先检查权限，没有权限则返回错误；</li>
<li>MySQL8.0以前会查询缓存，缓存命中则直接返回，没有则执行下一步；</li>
<li>词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；</li>
<li>两种执行方案，先查 <code>id &gt; 1</code> 还是 <code>name = &#39;大彬&#39;</code>，优化器根据自己的优化<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>选择执行效率最好的方案；</li>
<li>校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。</li>
</ol>
<h2 id="更新语句执行过程？"><a href="#更新语句执行过程？" class="headerlink" title="更新语句执行过程？"></a>更新语句执行过程？</h2><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、<code>redo log</code>（<code>prepare</code>状态）、<code>binlog</code>、<code>redo log</code>（<code>commit</code>状态）</p>
<p>举个例子，更新语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update` `user` `set` `name` `= ``&#x27;大彬&#x27;` `where` `id = 1;</span><br></pre></td></tr></table></figure>

<ol>
<li>先查询到 id 为1的记录，有缓存会使用缓存。</li>
<li>拿到查询结果，将 name 更新为大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录<code>redo log</code>，此时<code>redo log</code>进入 <code>prepare</code>状态。</li>
<li>执行器收到通知后记录<code>binlog</code>，然后调用引擎接口，提交<code>redo log</code>为<code>commit</code>状态。</li>
<li>更新完成。</li>
</ol>
<p>为什么记录完<code>redo log</code>，不直接提交，而是先进入<code>prepare</code>状态？</p>
<p>假设先写<code>redo log</code>直接提交，然后写<code>binlog</code>，写完<code>redo log</code>后，机器挂了，<code>binlog</code>日志没有被写入，那么机器重启后，这台机器会通过<code>redo log</code>恢复数据，但是这个时候<code>binlog</code>并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>
<h2 id="exist和in的区别？"><a href="#exist和in的区别？" class="headerlink" title="exist和in的区别？"></a>exist和in的区别？</h2><p><code>exists</code>用于对外表记录做筛选。<code>exists</code>会遍历外表，将外查询表的每一行，代入内查询进行判断。当<code>exists</code>里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。反之如果<code>exists</code>里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `a.* ``from` `A awhere exists(``select` `1 ``from` `B b ``where` `a.id=b.id)</span><br></pre></td></tr></table></figure>

<p><code>in</code>是先把后边的语句查出来放到临时表中，然后遍历临时表，将临时表的每一行，代入外查询去查找。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select` `* ``from` `Awhere id ``in``(``select` `id ``from` `B)</span><br></pre></td></tr></table></figure>

<p><strong>子查询的表比较大的时候</strong>，使用<code>exists</code>可以有效减少总的循环次数来提升速度；<strong>当外查询的表比较大的时候</strong>，使用<code>in</code>可以有效减少对外查询表循环遍历来提升速度。</p>
<h2 id="MySQL中int-10-和char-10-的区别？"><a href="#MySQL中int-10-和char-10-的区别？" class="headerlink" title="MySQL中int(10)和char(10)的区别？"></a>MySQL中int(10)和char(10)的区别？</h2><p>int(10)中的10表示的是显示数据的长度，而char(10)表示的是存储数据的长度。</p>
<h2 id="truncate、delete与drop区别？"><a href="#truncate、delete与drop区别？" class="headerlink" title="truncate、delete与drop区别？"></a>truncate、delete与drop区别？</h2><p><strong>相同点：</strong></p>
<ol>
<li><code>truncate</code>和不带<code>where</code>子句的<code>delete</code>、以及<code>drop</code>都会删除表内的数据。</li>
<li><code>drop</code>、<code>truncate</code>都是<code>DDL</code>语句（数据定义语言），执行后会自动提交。</li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引；</li>
<li>一般来说，执行速度: drop &gt; truncate &gt; delete。</li>
</ol>
<h2 id="having和where区别？"><a href="#having和where区别？" class="headerlink" title="having和where区别？"></a>having和where区别？</h2><ul>
<li>二者作用的对象不同，<code>where</code>子句作用于表和视图，<code>having</code>作用于组。</li>
<li><code>where</code>在数据分组前进行过滤，<code>having</code>在数据分组后进行过滤。</li>
</ul>
<h2 id="什么是MySQL主从同步？"><a href="#什么是MySQL主从同步？" class="headerlink" title="什么是MySQL主从同步？"></a>什么是MySQL主从同步？</h2><p>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（<code>master</code>），其余的服务器充当从服务器（<code>slave</code>）。</p>
<p>因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。</p>
<h2 id="为什么要做主从同步？"><a href="#为什么要做主从同步？" class="headerlink" title="为什么要做主从同步？"></a>为什么要做主从同步？</h2><ol>
<li>读写分离，使数据库能支撑更大的并发。</li>
<li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li>
<li>数据备份，保证数据的安全。</li>
</ol>
<h2 id="乐观锁和悲观锁是什么？"><a href="#乐观锁和悲观锁是什么？" class="headerlink" title="乐观锁和悲观锁是什么？"></a>乐观锁和悲观锁是什么？</h2><p>数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观锁和悲观锁是并发控制主要采用的技术手段。</p>
<ul>
<li>悲观锁：假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。</li>
<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否数据是否被修改过。给表增加<code>version</code>字段，在修改提交之前检查<code>version</code>与原来取到的<code>version</code>值是否相等，若相等，表示数据没有被修改，可以更新，否则，数据为脏数据，不能更新。实现方式：乐观锁一般使用版本号机制或<code>CAS</code><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>实现。</li>
</ul>
<h2 id="用过processlist吗？"><a href="#用过processlist吗？" class="headerlink" title="用过processlist吗？"></a>用过processlist吗？</h2><p><code>show processlist</code> 或 <code>show full processlist</code> 可以查看当前 MySQL 是否有压力，正在运行的<code>SQL</code>，有没有慢<code>SQL</code>正在执行。返回参数如下：</p>
<ol>
<li><p><strong>id</strong>：线程ID，可以用<code>kill id</code>杀死某个线程</p>
</li>
<li><p><strong>db</strong>：数据库名称</p>
</li>
<li><p><strong>user</strong>：数据库用户</p>
</li>
<li><p><strong>host</strong>：数据库实例的IP</p>
</li>
<li><p><strong>command</strong>：当前执行的命令，比如<code>Sleep</code>，<code>Query</code>，<code>Connect</code>等</p>
</li>
<li><p><strong>time</strong>：消耗时间，单位秒</p>
</li>
<li><p>state</p>
<p>：执行状态，主要有以下状态：</p>
<ul>
<li>Sleep，线程正在等待客户端发送新的请求</li>
<li>Locked，线程正在等待锁</li>
<li>Sending data，正在处理<code>SELECT</code>查询的记录，同时把结果发送给客户端</li>
<li>Kill，正在执行<code>kill</code>语句，杀死指定线程</li>
<li>Connect，一个从节点连上了主节点</li>
<li>Quit，线程正在退出</li>
<li>Sorting for group，正在为<code>GROUP BY</code>做<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a></li>
<li>Sorting for order，正在为<code>ORDER BY</code>做<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a></li>
</ul>
</li>
<li><p><strong>info</strong>：正在执行的<code>SQL</code>语句</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8概述</title>
    <url>/2021/05/12/java8learn/</url>
    <content><![CDATA[<h1 id="JAVA8学习"><a href="#JAVA8学习" class="headerlink" title="JAVA8学习"></a>JAVA8学习</h1><h2 id="01、Java8概述"><a href="#01、Java8概述" class="headerlink" title="01、Java8概述"></a>01、Java8概述</h2><p>Java 8 (又称为jdk 1.8) 是Java 语言开发的一个主要版本。<br>Java 8 是oracle公司于2014年3月发布，可以看成是自Java 5 以来最具革命性的版本。Java 8为Java语言、编译器、类库、开发工具与JVM带来了大量新特性。</p>
<span id="more"></span>
<h2 id="02、Java8新特性的好处"><a href="#02、Java8新特性的好处" class="headerlink" title="02、Java8新特性的好处"></a>02、Java8新特性的好处</h2><p>速度更快<br>代码更少(增加了新的语法：Lambda 表达式)<br>强大的Stream API<br>便于并行<br>最大化减少空指针异常：Optional<br>Nashorn引擎，允许在JVM上运行JS应用</p>
<h2 id="03、并行流与串行流"><a href="#03、并行流与串行流" class="headerlink" title="03、并行流与串行流"></a>03、并行流与串行流</h2><p>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</p>
<p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过parallel() 与sequential() 在并行流与顺序流之间进行切换。</p>
<h2 id="04、Lambda表达式"><a href="#04、Lambda表达式" class="headerlink" title="04、Lambda表达式"></a>04、Lambda表达式</h2><p>Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<p>4.1、Lambda表达式使用举例<br>import org.junit.Test;</p>
<p>import java.util.Comparator;</p>
<p>/**</p>
<ul>
<li>Lambda表达式的使用举例</li>
<li>/</li>
<li>public class LambdaTest {<br>@Test<br>public void test(){<pre><code> Runnable r1 = new Runnable() &#123;
     @Override
     public void run() &#123;
         System.out.println(&quot;长安欢迎您&quot;);
     &#125;
 &#125;;
 r1.run();

 System.out.println(&quot;+++++++++++++++++++++++++|&quot;);
  
 Runnable r2 = () -&gt; System.out.println(&quot;长安欢迎您&quot;);
  
 r2.run();
</code></pre>
 } @Test<br> public void test2(){<pre><code> Comparator&lt;Integer&gt; c1 = new Comparator&lt;Integer&gt;() &#123;
     @Override
     public int compare(Integer o1, Integer o2) &#123;
         return Integer.compare(o1,o2);
     &#125;
 &#125;;
 int compare1 = c1.compare(8,16);
 System.out.println(compare1);

 System.out.println(&quot;+++++++++++++++++++++++&quot;);
  
 //Lambda表达式的写法
 Comparator&lt;Integer&gt; c2 = (o1,o2) -&gt; Integer.compare(o1,o2);
  
 int compare2 = c2.compare(28,35);
 System.out.println(compare2);
  
 System.out.println(&quot;+++++++++++++++++++++++++++&quot;);
 //方法引用
 Comparator&lt;Integer&gt; c3 = Integer :: compare;
  
 int compare3 = c3.compare(28,35);
 System.out.println(compare3);
</code></pre>
 }<br>   }</li>
</ul>
<p> 4.2、Lambda表达式语法的使用1<br> import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.function.Consumer;</p>
<p>/**</p>
<ul>
<li><p>Lambda表达式的使用</p>
</li>
<li></li>
<li><p>1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p>
</li>
<li><p>2.格式：</p>
</li>
<li><pre><code> -&gt; :lambda操作符 或 箭头操作符
</code></pre>
</li>
<li><pre><code> -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）
</code></pre>
</li>
<li><pre><code> -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）
</code></pre>
</li>
<li></li>
<li><p>3.Lambda表达式的使用：（分为6种情况介绍）</p>
</li>
<li><p>/<br>  public class LambdaTest1 {</p>
<p>  //语法格式一：无参，无返回值<br>  @Test<br>  public void test(){</p>
<pre><code>  Runnable r1 = new Runnable() &#123;
      @Override
      public void run() &#123;
          System.out.println(&quot;长安欢迎您&quot;);
      &#125;
  &#125;;
  r1.run();

  System.out.println(&quot;+++++++++++++++++++++++++|&quot;);
   
  Runnable r2 = () -&gt; System.out.println(&quot;长安欢迎您&quot;);
   
  r2.run();
</code></pre>
<p>  }</p>
<p>  //语法格式二：Lambda 需要一个参数，但是没有返回值。<br>  @Test<br>  public void test2(){</p>
<pre><code>  Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() &#123;
      @Override
      public void accept(String s) &#123;
          System.out.println(s);
      &#125;
  &#125;;
  con.accept(&quot;善与恶的区别是什么？&quot;);

  System.out.println(&quot;+++++++++++++++++++&quot;);
   
  Consumer&lt;String&gt; c1 = (String s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);
</code></pre>
<p>  }</p>
<p>  //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”<br>  @Test<br>  public void test3(){</p>
<pre><code>  Consumer&lt;String&gt; c1 = (String s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);

  System.out.println(&quot;---------------------&quot;);
   
  Consumer&lt;String&gt; c2 = (s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c2.accept(&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;);
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test4(){</p>
<pre><code>  ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//类型推断

  int[] arr = &#123;1,2,3&#125;;//类型推断
</code></pre>
<p>  }<br>  }</p>
</li>
</ul>
<p> 4.3、Lambda表达式语法的使用2<br> import org.junit.Test;</p>
<p>import java.util.Comparator;<br>import java.util.function.Consumer;</p>
<p>/**</p>
<ul>
<li><p>Lambda表达式的使用</p>
</li>
<li></li>
<li><p>1.举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p>
</li>
<li><p>2.格式：</p>
</li>
<li><p>-&gt; :lambda操作符 或 箭头操作符</p>
</li>
<li><p>-&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表）</p>
</li>
<li><p>-&gt;右边：lambda体 （其实就是重写的抽象方法的方法体）<br>  *</p>
</li>
<li><p>3.Lambda表达式的使用：（分为6种情况介绍）</p>
</li>
<li></li>
<li><p>总结：</p>
</li>
<li><p>-&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略</p>
</li>
<li><p>   -&gt;右边：lambda体应该使用一对{}包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对{}和return关键字</p>
</li>
<li><p>/<br>public class LambdaTest1 {</p>
<p>  //语法格式四：Lambda若只需要一个参数时，参数的小括号可以省略<br>  @Test<br>  public void test5(){</p>
<pre><code>  Consumer&lt;String&gt; c1 = (s) -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);

  System.out.println(&quot;---------------------&quot;);
  
  Consumer&lt;String&gt; c2 = s -&gt; &#123;
      System.out.println(s);
  &#125;;
  c2.accept(&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;);
</code></pre>
<p>  }</p>
<p>  //语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值<br>  @Test<br>  public void test6(){</p>
<pre><code>  Comparator&lt;Integer&gt; c1 = new Comparator&lt;Integer&gt;() &#123;
      @Override
      public int compare(Integer o1, Integer o2) &#123;
          System.out.println(o1);
          System.out.println(o2);
          return o1.compareTo(o2);
      &#125;
  &#125;;
  System.out.println(c1.compare(15,23));

  System.out.println(&quot;\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;);
  
  Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; &#123;
      System.out.println(o1);
      System.out.println(o2);
      return o1.compareTo(o2);
  &#125;;
  System.out.println(com2.compare(16,8));
</code></pre>
<p>  }</p>
<p>  //语法格式六：当Lambda体只有一条语句时，return与大括号若有，都可以省略<br>  @Test<br>  public void test7(){</p>
<pre><code>  Comparator&lt;Integer&gt; c1 = (o1,o2) -&gt; &#123;
      return o1.compareTo(o2);
  &#125;;

  System.out.println(c1.compare(16,8));
  
  System.out.println(&quot;\\\\\\\\\\\\\\\\\\\\\\\\\\&quot;);
  
  Comparator&lt;Integer&gt; c2 = (o1,o2) -&gt; o1.compareTo(o2);
  
  System.out.println(c2.compare(17,24));
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test8(){</p>
<pre><code>  Consumer&lt;String&gt; c1 = s -&gt; &#123;
      System.out.println(s);
  &#125;;
  c1.accept(&quot;先天人性无善恶,后天人性有善恶。&quot;);

  System.out.println(&quot;---------------------&quot;);
  
  Consumer&lt;String&gt; c2 = s -&gt; System.out.println(s);
  
  c2.accept(&quot;如果没有邪恶的话我们怎么会知道人世间的那些善良呢？&quot;);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<h2 id="05、函数式-Functional-接口"><a href="#05、函数式-Functional-接口" class="headerlink" title="05、函数式(Functional)接口"></a>05、函数式(Functional)接口</h2><p>5.1、函数式接口的介绍<br>/*</p>
<ul>
<li><p>4.Lambda表达式的本质：作为函数式接口的实例</p>
</li>
<li></li>
<li><ol start="5">
<li>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解，</li>
</ol>
</li>
<li><p>  这样做可以检查它是否是一个函数式接口。</p>
</li>
<li></li>
<li><p>/</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>自定义函数式接口</p>
</li>
<li><p>/<br>  public interface MyInterFace {</p>
<p>  void method();</p>
</li>
</ul>
<p>//    void method2();</p>
<p>}</p>
<p>在java.util.function包下定义了Java 8 的丰富的函数式接口<br>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程）<br>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。<br>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。<br>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。<br>5.2、Java内置的函数式接口介绍及使用举例<br>函数式接口    参数类型    返回类型    用途<br>Consumer 消费型接口    T    void    对类型为T的对象应用操作，包含方法：void accept(T t)<br>Supplier 供给型接口    无    T    返回类型为T的对象，包含方法：T get()<br>Function&lt;T, R&gt;函数型接口    T    R    对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)<br>Predicate断定型接口    T    boolean    确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t)<br>BiFunction&lt;T,U,R&gt;    T, U    R    对类型为T,U参数应用操作，返回R类型的结果。包含方法为：Rapply(T t,U u);<br>UnaryOperator(Function子接口)    T    T    对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：Tapply(T t);<br>BinaryOperator(BiFunction子接口)    T,T    T    对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为：Tapply(T t1,T t2);<br>BiConsumer&lt;T,U&gt;    T,U    void    对类型为T,U参数应用操作。包含方法为：voidaccept(Tt,Uu)<br>BiPredicate&lt;T,U&gt;    T,U    boolean    包含方法为：booleantest(Tt,Uu)<br>ToIntFunction    T    int    计算int值的函数<br>ToLongFunction    T    long    计算long值的函数<br>ToDoubleFunction    T    double    计算double值的函数<br>IntFunction    int    R    参数为int类型的函数<br>LongFunction    long    R    参数为long类型的函数<br>DoubleFunction    double    R    参数为double类型的函数<br>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br>import java.util.function.Consumer;<br>import java.util.function.Predicate;</p>
<p>/**</p>
<ul>
<li><p>java内置的4大核心函数式接口</p>
</li>
<li></li>
<li><p>消费型接口 Consumer<T>     void accept(T t)</p>
</li>
<li><p>供给型接口 Supplier<T>     T get()</p>
</li>
<li><p>函数型接口 Function&lt;T,R&gt;   R apply(T t)</p>
</li>
<li><p>断定型接口 Predicate<T>    boolean test(T t)</p>
</li>
<li><p>/<br>  public class LambdaTest2 {</p>
<p>  public void happyTime(double money, Consumer<Double> con) {</p>
<pre><code>  con.accept(money);
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test(){</p>
<pre><code>  happyTime(30, new Consumer&lt;Double&gt;() &#123;
      @Override
      public void accept(Double aDouble) &#123;
          System.out.println(&quot;熬夜太累了，点个外卖，价格为：&quot; + aDouble);
      &#125;
  &#125;);
  System.out.println(&quot;+++++++++++++++++++++++++&quot;);

  //Lambda表达式写法
  happyTime(20,money -&gt; System.out.println(&quot;熬夜太累了，吃口麻辣烫，价格为：&quot; + money));
</code></pre>
<p>  }</p>
<p>  //根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定<br>  public List<String> filterString(List<String> list, Predicate<String> pre){</p>
<pre><code>  ArrayList&lt;String&gt; filterList = new ArrayList&lt;&gt;();
  for(String s : list)&#123;
      if(pre.test(s))&#123;
          filterList.add(s);
      &#125;
  &#125;
  return filterList;
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test2(){</p>
<pre><code>  List&lt;String&gt; list = Arrays.asList(&quot;长安&quot;,&quot;上京&quot;,&quot;江南&quot;,&quot;渝州&quot;,&quot;凉州&quot;,&quot;兖州&quot;);

  List&lt;String&gt; filterStrs = filterString(list, new Predicate&lt;String&gt;() &#123;
      @Override
      public boolean test(String s) &#123;
          return s.contains(&quot;州&quot;);
      &#125;
  &#125;);
   
  System.out.println(filterStrs);
   
  List&lt;String&gt; filterStrs1 = filterString(list,s -&gt; s.contains(&quot;州&quot;));
  System.out.println(filterStrs1);
</code></pre>
<p>  }<br>  }</p>
</li>
</ul>
<h1 id="06、方法引用与构造器引用"><a href="#06、方法引用与构造器引用" class="headerlink" title="06、方法引用与构造器引用"></a>06、方法引用与构造器引用</h1><p> 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br> 方法引用可以看做是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。<br> 要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致！<br> 格式：使用操作符“::” 将类(或对象) 与方法名分隔开来。<br> 如下三种主要使用情况：<br> 对象::实例方法名<br> 类::静态方法名<br> 类::实例方法名<br> 6.1、方法引用的使用情况1<br> 1、Employee类</p>
<p>public class Employee {</p>
<pre><code>private int id;
private String name;
private int age;
private double salary;

public int getId() &#123;
    return id;
&#125;

public void setId(int id) &#123;
    this.id = id;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public int getAge() &#123;
    return age;
&#125;

public void setAge(int age) &#123;
    this.age = age;
&#125;

public double getSalary() &#123;
    return salary;
&#125;

public void setSalary(double salary) &#123;
    this.salary = salary;
&#125;

public Employee() &#123;
    System.out.println(&quot;Employee().....&quot;);
&#125;

public Employee(int id) &#123;
    this.id = id;
    System.out.println(&quot;Employee(int id).....&quot;);
&#125;

public Employee(int id, String name) &#123;
    this.id = id;
    this.name = name;
&#125;

public Employee(int id, String name, int age, double salary) &#123;

    this.id = id;
    this.name = name;
    this.age = age;
    this.salary = salary;
&#125;

@Override
public String toString() &#123;
    return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#39;&#125;&#39;;
&#125;

@Override
public boolean equals(Object o) &#123;
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;

    Employee employee = (Employee) o;

    if (id != employee.id)
        return false;
    if (age != employee.age)
        return false;
    if (Double.compare(employee.salary, salary) != 0)
        return false;
    return name != null ? name.equals(employee.name) : employee.name == null;
&#125;

@Override
public int hashCode() &#123;
    int result;
    long temp;
    result = id;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + age;
    temp = Double.doubleToLongBits(salary);
    result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
    return result;
&#125;
</code></pre>
<p>}</p>
<p>2、测试类</p>
<p>import org.junit.Test;</p>
<p>import java.io.PrintStream;<br>import java.util.Comparator;<br>import java.util.function.BiPredicate;<br>import java.util.function.Consumer;<br>import java.util.function.Function;<br>import java.util.function.Supplier;</p>
<p>/**</p>
<ul>
<li><p>方法引用的使用</p>
</li>
<li></li>
<li><p>1.使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</p>
</li>
<li></li>
<li><p>2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以</p>
</li>
<li><p>方法引用，也是函数式接口的实例。<br>*</p>
</li>
<li><ol start="3">
<li>使用格式：  类(或对象) :: 方法名</li>
</ol>
<p>*</p>
</li>
<li><ol start="4">
<li>具体分为如下的三种情况：</li>
</ol>
</li>
<li><p>情况1     对象 :: 非静态方法</p>
</li>
<li><p>情况2     类 :: 静态方法<br>*</p>
</li>
<li><p>情况3     类 :: 非静态方法<br>*</p>
</li>
<li><ol start="5">
<li>方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的</li>
</ol>
</li>
<li><p>   形参列表和返回值类型相同！（针对于情况1和情况2）</p>
</li>
<li><p>/<br>public class MethodRefTest {</p>
<p>  // 情况一：对象 :: 实例方法<br>  //Consumer中的void accept(T t)<br>  //PrintStream中的void println(T t)<br>  @Test<br>  public void test() {</p>
<pre><code>  Consumer&lt;String&gt; c1 = str -&gt; System.out.println(str);
  c1.accept(&quot;兖州&quot;);

  System.out.println(&quot;+++++++++++++&quot;);
  PrintStream ps = System.out;
  Consumer&lt;String&gt; c2 = ps::println;
  c2.accept(&quot;xian&quot;);
</code></pre>
<p>  }</p>
<p>  //Supplier中的T get()<br>  //Employee中的String getName()<br>  @Test<br>  public void test2() {</p>
<pre><code>  Employee emp = new Employee(004,&quot;Nice&quot;,19,4200);

  Supplier&lt;String&gt; sk1 = () -&gt; emp.getName();
  System.out.println(sk1.get());
  
  System.out.println(&quot;*******************&quot;);
  Supplier&lt;String&gt; sk2 = emp::getName;
  System.out.println(sk2.get());
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>6.2、方法引用的使用情况2<br>1、Employee类——同上</p>
<p>2、测试类</p>
<p>import org.junit.Test;<br>import java.util.Comparator;<br>import java.util.function.Function;</p>
<p>public class MethodRefTest {</p>
<pre><code>// 情况二：类 :: 静态方法
//Comparator中的int compare(T t1,T t2)
//Integer中的int compare(T t1,T t2)
@Test
public void test3() &#123;
    Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1,t2);
    System.out.println(com1.compare(21,20));

    System.out.println(&quot;+++++++++++++++&quot;);

    Comparator&lt;Integer&gt; com2 = Integer::compare;
    System.out.println(com2.compare(15,7));
&#125;

//Function中的R apply(T t)
//Math中的Long round(Double d)
@Test
public void test4() &#123;
    Function&lt;Double,Long&gt; func = new Function&lt;Double, Long&gt;() &#123;
        @Override
        public Long apply(Double d) &#123;
            return Math.round(d);
        &#125;
    &#125;;

    System.out.println(&quot;++++++++++++++++++&quot;);

    Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);
    System.out.println(func1.apply(14.1));

    System.out.println(&quot;++++++++++++++++++&quot;);

    Function&lt;Double,Long&gt; func2 = Math::round;
    System.out.println(func2.apply(17.4));
&#125;
</code></pre>
<p>}</p>
<p>6.2、方法引用的使用情况3<br>1、Employee类——同上</p>
<p>2、测试类</p>
<p>import org.junit.Test;</p>
<p>import java.util.Comparator;<br>import java.util.function.BiPredicate;<br>import java.util.function.Function;</p>
<p>public class MethodRefTest {</p>
<pre><code>// 情况三：类 :: 实例方法  (有难度)
// Comparator中的int comapre(T t1,T t2)
// String中的int t1.compareTo(t2)
@Test
public void test5() &#123;
    Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);
    System.out.println(com1.compare(&quot;abc&quot;,&quot;abd&quot;));

    System.out.println(&quot;++++++++++++++++&quot;);

    Comparator&lt;String&gt; com2 = String :: compareTo;
    System.out.println(com2.compare(&quot;abd&quot;,&quot;abm&quot;));
&#125;

//BiPredicate中的boolean test(T t1, T t2);
//String中的boolean t1.equals(t2)
@Test
public void test6() &#123;
    BiPredicate&lt;String,String&gt; pre1 = (s1, s2) -&gt; s1.equals(s2);
    System.out.println(pre1.test(&quot;MON&quot;,&quot;MON&quot;));

    System.out.println(&quot;++++++++++++++++++++&quot;);
    
    BiPredicate&lt;String,String&gt; pre2 = String :: equals;
    System.out.println(pre2.test(&quot;MON&quot;,&quot;MON&quot;));
&#125;

// Function中的R apply(T t)
// Employee中的String getName();
@Test
public void test7() &#123;
    Employee employee = new Employee(007, &quot;Ton&quot;, 21, 8000);

    Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();
    System.out.println(func1.apply(employee));

    System.out.println(&quot;++++++++++++++++++++++++&quot;);

    Function&lt;Employee,String&gt; f2 = Employee::getName;
    System.out.println(f2.apply(employee));
&#125;
</code></pre>
<p>}</p>
<p>6.4、构造器引用与数组引用的使用<br>格式：ClassName::new</p>
<p>与函数式接口相结合，自动与函数式接口中方法兼容。</p>
<p>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</p>
<p>1、Employee类——同上</p>
<p>2、测试类</p>
<p>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.function.BiFunction;<br>import java.util.function.Function;<br>import java.util.function.Supplier;</p>
<p>/**</p>
<ul>
<li><p>一、构造器引用</p>
</li>
<li><pre><code> 和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。
</code></pre>
</li>
<li><pre><code> 抽象方法的返回值类型即为构造器所属的类的类型
</code></pre>
</li>
<li></li>
<li><p>二、数组引用</p>
</li>
<li><pre><code>可以把数组看做是一个特殊的类，则写法与构造器引用一致。 
</code></pre>
</li>
<li><p>/<br>public class MethodRefTest {</p>
<p>  //构造器引用<br>  //Supplier中的T get()<br>  //Employee的空参构造器：Employee()<br>  @Test<br>  public void test() {</p>
<pre><code>  Supplier&lt;Employee&gt; sup = new Supplier&lt;Employee&gt;() &#123;
      @Override
      public Employee get() &#123;
          return new Employee();
      &#125;
  &#125;;
  System.out.println(&quot;+++++++++++++++++++&quot;);

  Supplier&lt;Employee&gt; sk1 = () -&gt; new Employee();
  System.out.println(sk1.get());
  
  System.out.println(&quot;+++++++++++++++++++&quot;);
  
  Supplier&lt;Employee&gt; sk2 = Employee::new;
  System.out.println(sk2.get());
</code></pre>
<p>  }</p>
<p>  //Function中的R apply(T t)<br>  @Test<br>  public void test2() {</p>
<pre><code>  Function&lt;Integer, Employee&gt; f1 = id -&gt; new Employee(id);
  Employee employee = f1.apply(7793);
  System.out.println(employee);

  System.out.println(&quot;+++++++++++++++++++&quot;);
  
  Function&lt;Integer, Employee&gt; f2 = Employee::new;
  Employee employee1 = f2.apply(4545);
  System.out.println(employee1);
</code></pre>
<p>  }</p>
<p>  //BiFunction中的R apply(T t,U u)<br>  @Test<br>  public void test3() {</p>
<pre><code>  BiFunction&lt;Integer, String, Employee&gt; f1 = (id, name) -&gt; new Employee(id, name);
  System.out.println(f1.apply(2513, &quot;Fruk&quot;));

  System.out.println(&quot;*******************&quot;);
  
  BiFunction&lt;Integer, String, Employee&gt; f2 = Employee::new;
  System.out.println(f2.apply(9526, &quot;Bon&quot;));
</code></pre>
<p>  }</p>
<p>  //数组引用<br>  //Function中的R apply(T t)<br>  @Test<br>  public void test4() {</p>
<pre><code>  Function&lt;Integer, String[]&gt; f1 = length -&gt; new String[length];
  String[] arr1 = f1.apply(7);
  System.out.println(Arrays.toString(arr1));

  System.out.println(&quot;+++++++++++++++++++&quot;);
  
  Function&lt;Integer, String[]&gt; f2 = String[]::new;
  String[] arr2 = f2.apply(9);
  System.out.println(Arrays.toString(arr2));
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<h2 id="07、强大的Stream-API"><a href="#07、强大的Stream-API" class="headerlink" title="07、强大的Stream API"></a>07、强大的Stream API</h2><p>7.1、Stream API的概述<br>Java8中有两大最为重要的改变。第一个是Lambda 表达式；另外一个则是Stream API。<br>Stream API ( java.util.stream)把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。<br>为什么要使用Stream API<br>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。<br>Stream 和Collection 集合的区别：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算。<br>/**</p>
<ul>
<li>1.Stream关注的是对数据的运算，与CPU打交道</li>
<li>  集合关注的是数据的存储，与内存打交道</li>
<li></li>
<li>2.</li>
<li>①Stream 自己不会存储元素。</li>
<li>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行</li>
<li></li>
<li>3.Stream 执行流程</li>
<li>① Stream的实例化</li>
<li>② 一系列的中间操作（过滤、映射、…)</li>
<li>③ 终止操作</li>
<li></li>
<li>4.说明：</li>
<li>4.1 一个中间操作链，对数据源的数据进行处理</li>
<li>4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li>
<li>/</li>
</ul>
<p>7.2、Stream的实例化<br>1、EmployeeData类</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>/**</p>
<ul>
<li>提供用于测试的数据</li>
<li>/<br>  public class EmployeeData {  public static List<Employee> getEmployees(){<pre><code>  List&lt;Employee&gt; list = new ArrayList&lt;&gt;();
  
  list.add(new Employee(1001, &quot;马化腾&quot;, 34, 6000.38));
  list.add(new Employee(1002, &quot;马云&quot;, 12, 9876.12));
  list.add(new Employee(1003, &quot;刘强东&quot;, 33, 3000.82));
  list.add(new Employee(1004, &quot;雷军&quot;, 26, 7657.37));
  list.add(new Employee(1005, &quot;李彦宏&quot;, 65, 5555.32));
  list.add(new Employee(1006, &quot;比尔盖茨&quot;, 42, 9500.43));
  list.add(new Employee(1007, &quot;任正非&quot;, 26, 4333.32));
  list.add(new Employee(1008, &quot;扎克伯格&quot;, 35, 2500.32));
  
  return list;
</code></pre>
  }<br>  }</li>
</ul>
<p> 2、Employee类</p>
<p>public class Employee {</p>
<pre><code>private int id;
private String name;
private int age;
private double salary;

public int getId() &#123;
    return id;
&#125;

public void setId(int id) &#123;
    this.id = id;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

public int getAge() &#123;
    return age;
&#125;

public void setAge(int age) &#123;
    this.age = age;
&#125;

public double getSalary() &#123;
    return salary;
&#125;

public void setSalary(double salary) &#123;
    this.salary = salary;
&#125;

public Employee() &#123;
    System.out.println(&quot;Employee().....&quot;);
&#125;

public Employee(int id) &#123;
    this.id = id;
    System.out.println(&quot;Employee(int id).....&quot;);
&#125;

public Employee(int id, String name) &#123;
    this.id = id;
    this.name = name;
&#125;

public Employee(int id, String name, int age, double salary) &#123;

    this.id = id;
    this.name = name;
    this.age = age;
    this.salary = salary;
&#125;

@Override
public String toString() &#123;
    return &quot;Employee&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#39;&#125;&#39;;
&#125;

@Override
public boolean equals(Object o) &#123;
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;

    Employee employee = (Employee) o;

    if (id != employee.id)
        return false;
    if (age != employee.age)
        return false;
    if (Double.compare(employee.salary, salary) != 0)
        return false;
    return name != null ? name.equals(employee.name) : employee.name == null;
&#125;

@Override
public int hashCode() &#123;
    int result;
    long temp;
    result = id;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + age;
    temp = Double.doubleToLongBits(salary);
    result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
    return result;
&#125;
</code></pre>
<p>}</p>
<p>3、测试类</p>
<p>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.IntStream;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的实例化</p>
</li>
<li><p>/<br>  public class StreamAPITest {</p>
<p>  //创建 Stream方式一：通过集合<br>  @Test<br>  public void test(){</p>
<pre><code>  List&lt;Employee&gt; employees = EmployeeData.getEmployees();
</code></pre>
</li>
</ul>
<p>//        default Stream<E> stream() : 返回一个顺序流<br>        Stream<Employee> stream = employees.stream();</p>
<p>//        default Stream<E> parallelStream() : 返回一个并行流<br>        Stream<Employee> parallelStream = employees.parallelStream();<br>    }</p>
<pre><code>//创建 Stream方式二：通过数组
@Test
public void test2()&#123;
    int[] arr = new int[]&#123;1,2,3,4,5,6&#125;;
    //调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流
    IntStream stream = Arrays.stream(arr);

    Employee e1 = new Employee(1001,&quot;Hom&quot;);
    Employee e2 = new Employee(1002,&quot;Nut&quot;);
    Employee[] arr1 = new Employee[]&#123;e1,e2&#125;;

    Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);
&#125;
//创建 Stream方式三：通过Stream的of()
@Test
public void test3()&#123;
    Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);
&#125;

//创建 Stream方式四：创建无限流
@Test
public void test4()&#123;
</code></pre>
<p>//      迭代<br>//      public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)<br>        //遍历前10个偶数<br>        Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println);</p>
<p>//      生成<br>//      public static<T> Stream<T> generate(Supplier<T> s)<br>        Stream.generate(Math::random).limit(10).forEach(System.out::println);<br>    }<br>}</p>
<p>7.3、Stream的中间操作：筛选与切片<br>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p>方法    描述<br>filter(Predicate p)    接收Lambda ，从流中排除某些元素<br>distinct()    筛选，通过流所生成元素的hashCode() 和equals() 去除重复元素<br>limit(long maxSize)    截断流，使其元素不超过给定数量<br>skip(long n)    跳过元素，返回一个扔掉了前n 个元素的流。若流中元素不足n 个，则返回一个空流。与limit(n)互补<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的中间操作</p>
</li>
<li><p>/<br>  public class StreamAPITest2 {</p>
<p>  //1-筛选与切片<br>  @Test<br>  public void test(){</p>
<pre><code>  List&lt;Employee&gt; list = EmployeeData.getEmployees();
</code></pre>
<p>  //        filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</p>
<pre><code>  Stream&lt;Employee&gt; stream = list.stream();
  //练习：查询员工表中薪资大于7000的员工信息
  stream.filter(e -&gt; e.getSalary() &gt; 7000).forEach(System.out::println);

  System.out.println(&quot;+++++++++++++++++++++++&quot;);
</code></pre>
<p>  //        limit(n)——截断流，使其元素不超过给定数量。</p>
<pre><code>  list.stream().limit(3).forEach(System.out::println);
  System.out.println(&quot;+++++++++++++++++++++++&quot;);
</code></pre>
</li>
</ul>
<p>//        skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补<br>        list.stream().skip(3).forEach(System.out::println);</p>
<pre><code>    System.out.println(&quot;+++++++++++++++++++++++&quot;);
</code></pre>
<p>//        distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</p>
<pre><code>    list.add(new Employee(1013,&quot;李飞&quot;,42,8500));
    list.add(new Employee(1013,&quot;李飞&quot;,41,8200));
    list.add(new Employee(1013,&quot;李飞&quot;,28,6000));
    list.add(new Employee(1013,&quot;李飞&quot;,39,7800));
    list.add(new Employee(1013,&quot;李飞&quot;,40,8000));
</code></pre>
<p>//        System.out.println(list);</p>
<pre><code>    list.stream().distinct().forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>7.4、Stream的中间操作：映射<br>方法    描述<br>map(Function f)    接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<br>mapToDouble(ToDoubleFunction f)    接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。<br>mapToInt(ToIntFunction f)    接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。<br>mapToLong(ToLongFunction f)    接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。<br>flatMap(Function f)    接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的中间操作</p>
</li>
<li><p>/<br>  public class StreamAPITest2 {</p>
<p>  //2-映射<br>  @Test<br>  public void test2(){<br>  //        map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
<pre><code>  List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);
  list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);
</code></pre>
</li>
</ul>
<p>//        练习1：获取员工姓名长度大于3的员工的姓名。<br>        List<Employee> employees = EmployeeData.getEmployees();<br>        Stream<String> namesStream = employees.stream().map(Employee::getName);<br>        namesStream.filter(name -&gt; name.length() &gt; 3).forEach(System.out::println);<br>        System.out.println();</p>
<pre><code>    //练习2：
    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest2::fromStringToStream);
    
    streamStream.forEach(s -&gt;&#123;
        s.forEach(System.out::println);
    &#125;);
    System.out.println(&quot;++++++++++++++++++++++&quot;);
</code></pre>
<p>//        flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。<br>        Stream<Character> characterStream = list.stream().flatMap(StreamAPITest2::fromStringToStream);</p>
<pre><code>    characterStream.forEach(System.out::println);
&#125;

//将字符串中的多个字符构成的集合转换为对应的Stream的实例
public static Stream&lt;Character&gt; fromStringToStream(String str)&#123;//aa
    ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();
    for(Character c : str.toCharArray())&#123;
        list.add(c);
    &#125;
    return list.stream();
&#125;

@Test
public void test3()&#123;
    ArrayList list1 = new ArrayList();
    list1.add(25);
    list1.add(33);
    list1.add(14);

    ArrayList list2 = new ArrayList();
    list2.add(51);
    list2.add(23);
    list2.add(61);
</code></pre>
<p>//        list1.add(list2);<br>        list1.addAll(list2);<br>        System.out.println(list1);<br>    }<br>}</p>
<p>7.5、Stream的中间操作：排序<br>方法    描述<br>sorted()    产生一个新流，其中按自然顺序排序<br>sorted(Comparator com)    产生一个新流，其中按比较器顺序排序<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.Stream;</p>
<p>/**</p>
<ul>
<li><p>测试Stream的中间操作</p>
</li>
<li><p>/<br>  public class StreamAPITest2 {</p>
<p>  //3-排序<br>  @Test<br>  public void test4(){<br>  //        sorted()——自然排序</p>
<pre><code>  List&lt;Integer&gt; list = Arrays.asList(25,45,36,12,85,64,72,-95,4);
  list.stream().sorted().forEach(System.out::println);
  //抛异常，原因:Employee没有实现Comparable接口
</code></pre>
<p>  //        List<Employee> employees = EmployeeData.getEmployees();<br>  //        employees.stream().sorted().forEach(System.out::println);</p>
</li>
</ul>
<p>//        sorted(Comparator com)——定制排序</p>
<pre><code>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();
    employees.stream().sorted( (e1,e2) -&gt; &#123;

        int ageValue = Integer.compare(e1.getAge(),e2.getAge());
        if(ageValue != 0)&#123;
            return ageValue;
        &#125;else&#123;
            return -Double.compare(e1.getSalary(),e2.getSalary());
        &#125;

    &#125;).forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>7.6、Stream的终止操作：匹配与查找<br>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是void 。<br>流进行了终止操作后，不能再次使用。<br>方法    描述<br>allMatch(Predicate p)    检查是否匹配所有元素<br>anyMatch(Predicate p)    检查是否至少匹配一个元素<br>noneMatch(Predicate p)    检查是否没有匹配所有元素<br>findFirst()    返回第一个元素<br>findAny()    返回当前流中的任意元素<br>count()    返回流中元素总数<br>max(Comparator c)    返回流中最大值<br>min(Comparator c)    返回流中最小值<br>forEach(Consumer c)    内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.List;<br>import java.util.Optional;<br>import java.util.stream.Stream;</p>
<p>public class StreamAPITest3 {<br>    //1-匹配与查找<br>    @Test<br>    public void test(){<br>        List<Employee> employees = EmployeeData.getEmployees();</p>
<p>//        allMatch(Predicate p)——检查是否匹配所有元素。<br>//          练习：是否所有的员工的年龄都大于18<br>        boolean allMatch = employees.stream().allMatch(e -&gt; e.getAge() &gt; 23);<br>        System.out.println(allMatch);</p>
<p>//        anyMatch(Predicate p)——检查是否至少匹配一个元素。<br>//         练习：是否存在员工的工资大于 10000<br>        boolean anyMatch = employees.stream().anyMatch(e -&gt; e.getSalary() &gt; 9000);<br>        System.out.println(anyMatch);</p>
<p>//        noneMatch(Predicate p)——检查是否没有匹配的元素。<br>//          练习：是否存在员工姓“马”<br>        boolean noneMatch = employees.stream().noneMatch(e -&gt; e.getName().startsWith(“马”));<br>        System.out.println(noneMatch);</p>
<p>//        findFirst——返回第一个元素<br>        Optional<Employee> employee = employees.stream().findFirst();<br>        System.out.println(employee);</p>
<p>//        findAny——返回当前流中的任意元素<br>        Optional<Employee> employee1 = employees.parallelStream().findAny();<br>        System.out.println(employee1);<br>    }</p>
<pre><code>@Test
public void test2()&#123;
    List&lt;Employee&gt; employees = EmployeeData.getEmployees();
    
    // count——返回流中元素的总个数
    long count = employees.stream().filter(e -&gt; e.getSalary() &gt; 4500).count();
    System.out.println(count);
</code></pre>
<p>//        max(Comparator c)——返回流中最大值<br>//        练习：返回最高的工资：<br>        Stream<Double> salaryStream = employees.stream().map(e -&gt; e.getSalary());<br>        Optional<Double> maxSalary = salaryStream.max(Double::compare);<br>        System.out.println(maxSalary);</p>
<p>//        min(Comparator c)——返回流中最小值<br>//        练习：返回最低工资的员工<br>        Optional<Employee> employee = employees.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));<br>        System.out.println(employee);<br>        System.out.println();</p>
<p>//        forEach(Consumer c)——内部迭代<br>        employees.stream().forEach(System.out::println);</p>
<pre><code>    //使用集合的遍历操作
    employees.forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>7.7、Stream的终止操作：归约<br>方法    描述<br>reduce(T iden, BinaryOperator b)    可以将流中元素反复结合起来，得到一个值。返回T<br>reduce(BinaryOperator b)    可以将流中元素反复结合起来，得到一个值。返回Optional<br>备注：map 和reduce 的连接通常称为map-reduce 模式，因Google 用它来进行网络搜索而出名。</p>
<p>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.Optional;<br>import java.util.stream.Stream;</p>
<p>public class StreamAPITest3 {</p>
<pre><code>//2-归约
@Test
public void test3()&#123;
</code></pre>
<p>//        reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T<br>//        练习1：计算1-10的自然数的和<br>        List<Integer> list = Arrays.asList(72,25,32,34,43,56,81,15,29,71);<br>        Integer sum = list.stream().reduce(0, Integer::sum);<br>        System.out.println(sum);</p>
<p>//        reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional<T><br>//        练习2：计算公司所有员工工资的总和<br>        List<Employee> employees = EmployeeData.getEmployees();<br>        Stream<Double> salaryStream = employees.stream().map(Employee::getSalary);<br>//        Optional<Double> sumMoney = salaryStream.reduce(Double::sum);<br>        Optional<Double> sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);<br>        System.out.println(sumMoney.get());<br>    }<br>}</p>
<p>7.8、Stream的终止操作：收集<br>方法    描述<br>collect(Collector c)    将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法<br>import github2.Employee;<br>import github2.EmployeeData;<br>import org.junit.Test;</p>
<p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.Optional;<br>import java.util.Set;<br>import java.util.stream.Collectors;<br>import java.util.stream.Stream;</p>
<p>public class StreamAPITest3 {</p>
<pre><code>//3-收集
@Test
public void test4() &#123;
</code></pre>
<p>//        collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法<br>//        练习1：查找工资大于6000的员工，结果返回为一个List或Set</p>
<pre><code>    List&lt;Employee&gt; employees = EmployeeData.getEmployees();
    List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toList());

    employeeList.forEach(System.out::println);
    
    System.out.println(&quot;++++++++++++++++++&quot;);
    
    Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; 6000).collect(Collectors.toSet());

    employeeSet.forEach(System.out::println);
&#125;
</code></pre>
<p>}</p>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。</p>
<p>Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<h2 id="08、Optional类"><a href="#08、Optional类" class="headerlink" title="08、Optional类"></a>08、Optional类</h2><p>8.1、Optional类的介绍<br>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
<p>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。<br>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>创建Optional类对象的方法：<br>Optional.of(T t): 创建一个Optional 实例，t必须非空；<br>Optional.empty() : 创建一个空的Optional 实例<br>Optional.ofNullable(T t)：t可以为null<br>判断Optional容器中是否包含对象：<br>boolean isPresent() : 判断是否包含对象<br>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。<br>获取Optional容器的对象：<br>T get(): 如果调用对象包含值，返回该值，否则抛异常<br>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。<br>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。<br>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。<br>1、Boy类</p>
<p>public class Boy {<br>    private Girl girl;</p>
<pre><code>public Boy() &#123;
&#125;

public Boy(Girl girl) &#123;
    this.girl = girl;
&#125;

public Girl getGirl() &#123;
    return girl;
&#125;

public void setGirl(Girl girl) &#123;
    this.girl = girl;
&#125;

@Override
public String toString() &#123;
    return &quot;Boy&#123;&quot; +
            &quot;girl=&quot; + girl +
            &#39;&#125;&#39;;
&#125;
</code></pre>
<p>}</p>
<p>2、Girl类</p>
<p>public class Girl {<br>    private String name;</p>
<pre><code>public Girl() &#123;
&#125;

public Girl(String name) &#123;
    this.name = name;
&#125;

public String getName() &#123;
    return name;
&#125;

public void setName(String name) &#123;
    this.name = name;
&#125;

@Override
public String toString() &#123;
    return &quot;Girl&#123;&quot; +
            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
            &#39;&#125;&#39;;
&#125;
</code></pre>
<p>}</p>
<p>3、测试类</p>
<p>import org.junit.Test;<br>import java.util.Optional;</p>
<p>/**</p>
<ul>
<li><p>Optional类：为了在程序中避免出现空指针异常而创建的。</p>
</li>
<li></li>
<li><p>常用的方法：ofNullable(T t)</p>
</li>
<li><pre><code>      orElse(T t)
</code></pre>
</li>
<li><p>/<br>public class OptionalTest {<br>  /**</p>
<ul>
<li>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</li>
<li>Optional.empty() : 创建一个空的 Optional 实例</li>
<li>Optional.ofNullable(T t)：t可以为null</li>
<li>/<br>  @Test<br>  public void test(){<br>  Girl girl = new Girl();<br>//        girl = null;<br>  //of(T t):保证t是非空的<br>  Optional<Girl> optionalGirl = Optional.of(girl);<br>  }</li>
</ul>
<p>  @Test<br>  public void test2(){</p>
<pre><code>  Girl girl = new Girl();
</code></pre>
<p>//        girl = null;</p>
<pre><code>  //ofNullable(T t)：t可以为null
  Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);
  System.out.println(optionalGirl);
  //orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.
  //如果内部的t是空的，则返回orElse()方法中的参数t1.
  Girl girl1 = optionalGirl.orElse(new Girl(&quot;&quot;));
  System.out.println(girl1);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
<p>8.2、Optional类的使用举例<br>1、测试类</p>
<p>import org.junit.Test;<br>import java.util.Optional;</p>
<p>/**</p>
<ul>
<li><p>Optional类：为了在程序中避免出现空指针异常而创建的。</p>
</li>
<li></li>
<li><p>常用的方法：ofNullable(T t)</p>
</li>
<li><pre><code>      orElse(T t)
</code></pre>
</li>
<li><p>/<br>public class OptionalTest {</p>
<p>  @Test<br>  public void test3(){</p>
<pre><code>  Boy boy = new Boy();
  boy = null;
  String girlName = getGirlName(boy);
  System.out.println(girlName);
</code></pre>
<p>  }</p>
<p>  private String getGirlName(Boy boy) {</p>
<pre><code>  return boy.getGirl().getName();
</code></pre>
<p>  }</p>
<p>  //优化以后的getGirlName():<br>  public String getGirlName1(Boy boy){</p>
<pre><code>  if(boy != null)&#123;
      Girl girl = boy.getGirl();
      if(girl != null)&#123;
          return girl.getName();
      &#125;
  &#125;
  return null;
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test4(){</p>
<pre><code>  Boy boy = new Boy();
  boy = null;
  String girlName = getGirlName1(boy);
  System.out.println(girlName);
</code></pre>
<p>  }</p>
<p>  //使用Optional类的getGirlName():<br>  public String getGirlName2(Boy boy){</p>
<pre><code>  Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);
  //此时的boy1一定非空
  Boy boy1 = boyOptional.orElse(new Boy(new Girl(&quot;朱淑贞&quot;)));
  
  Girl girl = boy1.getGirl();
  
  Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);
  //girl1一定非空
  Girl girl1 = girlOptional.orElse(new Girl(&quot;阿青&quot;));
  
  return girl1.getName();
</code></pre>
<p>  }</p>
<p>  @Test<br>  public void test5(){</p>
<pre><code>  Boy boy = null;
  boy = new Boy();
  boy = new Boy(new Girl(&quot;李清照&quot;));
  String girlName = getGirlName2(boy);
  System.out.println(girlName);
</code></pre>
<p>  }<br>}</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis框架</title>
    <url>/2021/06/12/Mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul>
<li>   MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li>
<li>   iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）<span id="more"></span>
<h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2></li>
</ul>
<ol>
<li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li>
<li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li>
</ol>
<h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul>
<li><a href="https://github.com/mybatis/mybatis-3">MyBatis下载地址</a></li>
<li><img src="Resources/MyBatis%E4%B8%8B%E8%BD%BD.png"></li>
</ul>
<h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><ul>
<li>JDBC  </li>
<li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  <ul>
<li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  </li>
<li>代码冗长，开发效率低</li>
</ul>
</li>
<li>Hibernate 和 JPA</li>
<li>操作简便，开发效率高  <ul>
<li>程序中的长难复杂 SQL 需要绕过框架  </li>
<li>内部自动生产的 SQL，不容易做特殊优化  </li>
<li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  </li>
<li>反射操作太多，导致数据库性能下降</li>
</ul>
</li>
<li>MyBatis</li>
<li>轻量级，性能出色  <ul>
<li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  </li>
<li>开发效率稍逊于HIbernate，但是完全能够接受</li>
</ul>
</li>
</ul>
<h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>IDE：idea 2019.2  </li>
<li>构建工具：maven 3.5.4  </li>
<li>MySQL版本：MySQL 5.7  </li>
<li>MyBatis版本：MyBatis 3.5.7</li>
</ul>
<h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul>
<li><p>打包方式：jar</p>
</li>
<li><p>引入依赖</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><blockquote>
<p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是src/main/resources目录下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--设置连接数据库的环境--&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">				<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--引入映射文件--&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><blockquote>
<p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;  </span><br><span class="line">	<span class="comment">/**  </span></span><br><span class="line"><span class="comment">	* 添加用户信息  </span></span><br><span class="line"><span class="comment">	*/</span>  </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul>
<li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  </li>
<li>对象：Java的实体类对象  <ul>
<li>关系：关系型数据库  </li>
<li>映射：二者之间的对应关系</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Java概念</th>
<th>数据库概念</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>属性</td>
<td>字段/列</td>
</tr>
<tr>
<td>对象</td>
<td>记录/行</td>
</tr>
</tbody></table>
<ul>
<li>映射文件的命名规则</li>
<li>表所对应的实体类的类名+Mapper.xml<ul>
<li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li>
<li>因此一个映射文件对应一个实体类，对应一张表的操作</li>
<li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li>
<li>MyBatis映射文件存放的位置是src/main/resources/mappers目录下</li>
</ul>
</li>
<li>MyBatis中可以面向接口操作数据，要保证两个一致</li>
<li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致<ul>
<li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--int insertUser();--&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span>  </span><br><span class="line">		insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul>
<li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li>
<li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li>
<li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line">	    <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="keyword">int</span> result = userMapper.insertUser();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交</li>
</ul>
<h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ol>
<li><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>加入log4j的配置文件</p>
<ul>
<li>log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下</li>
<li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">log4j</span>:configuration <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><blockquote>
<p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">	    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">	        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">	            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">	            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">	            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">	            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">	            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">	            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">	            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">			2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><img src="Resources/mapper%E6%8E%A5%E5%8F%A3%E5%92%8Cmapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8C%85%E4%B8%8B.png"></li>
</ul>
<h1 id="默认的类型别名"><a href="#默认的类型别名" class="headerlink" title="默认的类型别名"></a>默认的类型别名</h1><p><img src="Resources/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D1.png"><br><img src="Resources/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D2.png"></p>
<h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ol>
<li><p>添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">	insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">     delete from t_user where id = 6</span><br><span class="line"> <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">     update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>查询一个实体类对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>查询集合</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>注意：</p>
<ol>
<li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul>
<li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li>
<li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况  </li>
</ul>
</li>
<li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li>
</ol>
</li>
</ul>
<h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul>
<li>MyBatis获取参数值的两种方式：${}和#{}  </li>
<li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li>
<li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li>
</ul>
<h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul>
<li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul>
<li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p>
<ol>
<li>以arg0,arg1…为键，以参数为值；</li>
<li>以param1,param2…为键，以参数为值；</li>
</ol>
</li>
<li><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</p>
</li>
<li><p>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul>
<li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLoginByMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">	Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">	map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">	User user = mapper.checkLoginByMap(map);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul>
<li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">	insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">	User user = <span class="keyword">new</span> User(<span class="keyword">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">	mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul>
<li><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 </p>
<ol>
<li>以@Param注解的value属性值为键，以参数为值；</li>
<li>以param1,param2…为键，以参数为值；</li>
</ol>
</li>
<li><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLoginByParam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">	mapper.CheckLoginByParam(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>建议分成两种情况进行处理</p>
<ol>
<li>实体类类型的参数</li>
<li>使用@Param标识参数</li>
</ol>
</li>
</ul>
<h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><ol>
<li>如果查询出的数据只有一条，可以通过<ol>
<li>实体类对象接收</li>
<li>List集合接收</li>
<li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li>
</ol>
</li>
<li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol>
<li>实体类类型的LIst集合接收</li>
<li>Map类型的LIst集合接收</li>
<li>在mapper接口的方法上添加@MapKey注解</li>
</ol>
</li>
</ol>
<h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">User <span class="title">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="查询一个List集合"><a href="#查询一个List集合" class="headerlink" title="查询一个List集合"></a>查询一个List集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询用户的总记录数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span></span><br><span class="line"><span class="comment"> * 例如：java.lang.Integer--&gt;int|integer  </span></span><br><span class="line"><span class="comment"> * 例如：int--&gt;_int|_integer  </span></span><br><span class="line"><span class="comment"> * 例如：Map--&gt;map,List--&gt;list  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">	select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getUserToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="查询多条数据为map集合"><a href="#查询多条数据为map集合" class="headerlink" title="查询多条数据为map集合"></a>查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  </span><br><span class="line">	select * from t_user  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	结果：</span></span><br><span class="line"><span class="comment">	[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">	&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">	&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">getAllUserToMap</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">	select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	结果：</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">	2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">	3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名进行模糊查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line">	<span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">	select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的</li>
</ul>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><ul>
<li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">	delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);</span><br><span class="line">	<span class="keyword">int</span> result = mapper.deleteMore(<span class="string">&quot;1,2,3,8&quot;</span>);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><ul>
<li>只能使用${}，因为表名不能加单引号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定表中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">	select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul>
<li><p>使用场景</p>
</li>
<li><p>t_clazz(clazz_id,clazz_name)  </p>
<ul>
<li>t_student(student_id,student_name,clazz_id)  </li>
</ul>
<ol>
<li>添加班级信息  </li>
<li>获取新添加的班级的id  </li>
<li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li>
</ol>
</li>
<li><p>在mapper.xml中设置两个属性</p>
</li>
<li><p>useGeneratedKeys：设置使用自增的主键  </p>
<ul>
<li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">	insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	SQLMapper mapper = sqlSession.getMapper(SQLMapper.class);</span><br><span class="line">	User user = <span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">&quot;ton&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">	mapper.insertUser(user);</span><br><span class="line">	System.out.println(user);</span><br><span class="line">	<span class="comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关联映射"><a href="#关联映射" class="headerlink" title="关联映射"></a><strong>关联映射</strong></h1><h2 id="一对一关联"><a href="#一对一关联" class="headerlink" title="一对一关联"></a>一对一关联</h2><p>在任意一方引入对方主键作为外键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据班级ID查询所有学生</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from tb_student where clazz_id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">selectByClazzId</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByClazzIdTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    sqlSession=MybatisUtils.getSession();</span><br><span class="line">    StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">    List&lt;Student&gt; students = mapper.selectByClazzId(<span class="number">11</span>);</span><br><span class="line">    students.forEach(student -&gt; System.out.println(student));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一（多）对一的关联操作"><a href="#一（多）对一的关联操作" class="headerlink" title="一（多）对一的关联操作"></a>一（多）对一的关联操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StudentMapper.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据学生ID查询学生以及学生所在班级，一对一查询使用急加载Eager 即同时（关联）查询</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from tb_student where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(id=true,column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;loginname&quot;,property = &quot;loginname&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;password&quot;,property=&quot;password&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;clazz_id&quot;,property=&quot;clazz&quot;,</span></span><br><span class="line"><span class="meta">        one=@One(select = &quot;com.zyc.mapper.ClazzMapper.selectClazzById&quot;,fetchType = FetchType.EAGER))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">Student <span class="title">selectStudentById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClazzMapper.java</span><br><span class="line"><span class="comment">//根据ID查询记录</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from tb_clazz where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="comment">//tb_clazz与Clazz属性映射</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(id=true,column = &quot;id&quot;, property = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column = &quot;cname&quot;,property = &quot;cname&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">Clazz <span class="title">selectClazzById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//测试根据ID查询某一个学生，并查询学生所在班级，这是一对一的关联查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectStudentByIdTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SqlSession sqlSession= MybatisUtils.getSession();</span><br><span class="line">        StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">        Student student=studentMapper.selectStudentById(<span class="number">275</span>);</span><br><span class="line">        String cname=student.getClazz().getCname();</span><br><span class="line"><span class="comment">//        assertEquals(cname,&quot;软件嵌入171&quot;);</span></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClazzMapper.java</span><br><span class="line"><span class="comment">//根据ID查询班级以及所有学生记录，一对多的关联  使用懒加载LAZY所以第二步的查询为查询相关学生信息 分布查询</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from tb_clazz where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="comment">//tb_clazz表中字段与Clazz类中的属性映射</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(id=true,column = &quot;id&quot;,property = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">        ,@Result(column = &quot;cname&quot;, property = &quot;cname&quot;)</span></span><br><span class="line"><span class="meta">        ,@Result(column = &quot;id&quot;,property = &quot;students&quot;,</span></span><br><span class="line"><span class="meta">        many=@Many(select = &quot;com.zyc.mapper.StudentMapper.selectByClazzId&quot;,fetchType = FetchType.LAZY))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">Clazz <span class="title">selectClazzAndStudentsById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据班级ID查询所有学生</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from tb_student where clazz_id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">selectByClazzId</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试根据班级ID查询班级以及所有学生信息，一对多关联</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectClazzAndStudentByIdTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    sqlSession = MybatisUtils.getSession();</span><br><span class="line">    ClazzMapper mapper = sqlSession.getMapper(ClazzMapper.class);</span><br><span class="line">    Clazz clazz = mapper.selectClazzAndStudentsById(<span class="number">11</span>);</span><br><span class="line">    List&lt;Student&gt; students = clazz.getStudents();</span><br><span class="line">    assertNotNull(students);</span><br><span class="line">    students.forEach(stu-&gt;System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多对多关联"><a href="#多对多关联" class="headerlink" title="多对多关联"></a>多对多关联</h2><p>创建第三张表，另外两张表的主键作为第三张表的外键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from tb_course where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">        @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column=&quot;cname&quot;,property=&quot;cname&quot;),</span></span><br><span class="line"><span class="meta">        @Result(column=&quot;id&quot;,property=&quot;students&quot;,</span></span><br><span class="line"><span class="meta">                many=@Many(select=&quot;com.zyc.mapper.StudentMapper.selectStudentByCourseId&quot;,</span></span><br><span class="line"><span class="meta">                        fetchType= FetchType.LAZY))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">//根据课程ID查询Course对象，Course对象中的students属性包含了所有学生对象,这是一对多查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Course <span class="title">selectCourseById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StudentMapper.class</span><br><span class="line"><span class="comment">//根据课程ID查询学生信息，此处用IN语句，嵌入式查询</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from tb_student where id&quot;</span></span><br><span class="line"><span class="meta">        + &quot; in (select student_id from student_course where course_id=#&#123;id&#125;)&quot;)</span></span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectStudentByCourseId</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询选课学生信息和班级信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectCourseByIdTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSession();</span><br><span class="line">    CourseMapper mapper = sqlSession.getMapper(CourseMapper.class);</span><br><span class="line">    Course course = mapper.selectCourseById(<span class="number">11</span>);</span><br><span class="line">    List&lt;Student&gt; students = course.getStudents();</span><br><span class="line">    <span class="keyword">int</span> n =students.size();</span><br><span class="line">    students.forEach(student -&gt; System.out.println(student));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul>
<li>resultMap：设置自定义映射  </li>
<li>属性：  <ul>
<li>id：表示自定义映射的唯一标识，不能重复</li>
<li>type：查询的数据要映射的实体类的类型  </li>
<li>子标签：  </li>
<li>id：设置主键的映射关系  <ul>
<li>result：设置普通字段的映射关系  </li>
<li>子标签属性：  </li>
<li>property：设置映射关系中实体类中的属性名  <ul>
<li>column：设置映射关系中表中的字段名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  </p>
<ol>
<li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select eid,emp_name empName,age,sex,email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><blockquote>
<p>查询员工信息以及员工所对应的部门信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">private</span> Integer eid;  </span><br><span class="line">	<span class="keyword">private</span> String empName;  </span><br><span class="line">	<span class="keyword">private</span> Integer age;  </span><br><span class="line">	<span class="keyword">private</span> String sex;  </span><br><span class="line">	<span class="keyword">private</span> String email;  </span><br><span class="line">	<span class="keyword">private</span> Dept dept;</span><br><span class="line">	<span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><ul>
<li>association：处理多对一的映射关系</li>
<li>property：需要处理多对的映射关系的属性名</li>
<li>javaType：该属性的类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4><ul>
<li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li>
<li>column：设置分步查询的条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EmpMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Emp <span class="title">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DeptMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Dept <span class="title">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer did;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line">	<span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul>
<li>collection：用来处理一对多的映射关系</li>
<li>ofType：表示该属性对饮的集合中存储的数据的类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Dept <span class="title">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">	select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Emp&gt; <span class="title">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul>
<li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：</li>
<li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  <ul>
<li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载  </li>
</ul>
</li>
<li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=”lazy(延迟加载)|eager(立即加载)”</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpAndDeptByStepOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	Emp emp = mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">	System.out.println(emp.getEmpName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭延迟加载，两条SQL语句都运行了<img src="Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%951.png"></li>
<li>开启延迟加载，只运行获取emp的SQL语句<br><img src="Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%952.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpAndDeptByStepOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	Emp emp = mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">	System.out.println(emp.getEmpName());</span><br><span class="line">	System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">	System.out.println(emp.getDept());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>开启后，需要用到查询dept的时候才会调用相应的SQL语句<img src="Resources/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%953.png"></p>
</li>
<li><p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=”lazy(延迟加载)|eager(立即加载)”</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">column</span>=<span class="string">&quot;did&quot;</span></span></span><br><span class="line"><span class="tag">				 <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul>
<li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</li>
</ul>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul>
<li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li>
<li>在where后面添加一个恒成立条件<code>1=1</code></li>
<li>这个恒成立条件并不会影响查询的结果<ul>
<li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时</li>
<li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错<ul>
<li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp where 1=1</span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and emp_name = #&#123;empName&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and age = #&#123;age&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and sex = #&#123;sex&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">		and email = #&#123;email&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul>
<li>where和if一般结合使用：</li>
<li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  <ul>
<li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉  </li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			emp_name = #&#123;empName&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and age = #&#123;age&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and sex = #&#123;sex&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			and email = #&#123;email&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：where标签不能去掉条件后多余的and/or</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">	age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul>
<li>trim用于去掉或添加标签中的内容  </li>
<li>常用属性</li>
<li>prefix：在trim标签中的内容的前面添加某些内容  <ul>
<li>suffix：在trim标签中的内容的后面添加某些内容 </li>
<li>prefixOverrides：在trim标签中的内容的前面去掉某些内容  </li>
<li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li>
</ul>
</li>
<li>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			emp_name = #&#123;empName&#125; and</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			age = #&#123;age&#125; and</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			sex = #&#123;sex&#125; or</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">			email = #&#123;email&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpByCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="keyword">new</span> Emp(<span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">	System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="Resources/trim%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul>
<li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li>
<li>when至少要有一个，otherwise至多只有一个</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select * from t_emp</span><br><span class="line">	<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				emp_name = #&#123;empName&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				age = #&#123;age&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				sex = #&#123;sex&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">				email = #&#123;email&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">				did = 1</span><br><span class="line">			<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpByChoose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="keyword">new</span> Emp(<span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">	System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="Resources/choose%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<ul>
<li>相当于<code>if a else if b else if c else d</code>，只会执行其中一个</li>
</ul>
<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul>
<li><p>属性：  </p>
</li>
<li><p>collection：设置要循环的数组或集合  </p>
<ul>
<li>item：表示集合或数组中的每一个数据  </li>
<li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li>
<li>open：设置foreach标签中的内容的开始符  </li>
<li>close：设置foreach标签中的内容的结束符</li>
</ul>
</li>
<li><p>批量删除</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">	delete from t_emp where eid in</span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">		#&#123;eid&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMoreByArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	<span class="keyword">int</span> result = mapper.deleteMoreByArray(<span class="keyword">new</span> Integer[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="Resources/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png"></p>
</li>
<li><p>批量添加</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">	insert into t_emp values</span><br><span class="line">	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">		(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertMoreByList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">	DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">	Emp emp1 = <span class="keyword">new</span> Emp(<span class="keyword">null</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">	Emp emp2 = <span class="keyword">new</span> Emp(<span class="keyword">null</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">	Emp emp3 = <span class="keyword">new</span> Emp(<span class="keyword">null</span>,<span class="string">&quot;c&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line">	<span class="keyword">int</span> result = mapper.insertMoreByList(emps);</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="Resources/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></p>
</li>
</ul>
<h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul>
<li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li>
<li>声明sql片段：<code>&lt;sql&gt;</code>标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用sql片段：<code>&lt;include&gt;</code>标签</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">	select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul>
<li><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </p>
</li>
<li><p>使一级缓存失效的四种情况：  </p>
<ol>
<li>不同的SqlSession对应不同的一级缓存  </li>
<li>同一个SqlSession但是查询条件不同</li>
<li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li>
<li>同一个SqlSession两次查询期间手动清空了缓存</li>
</ol>
</li>
</ul>
<h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul>
<li><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </p>
</li>
<li><p>二级缓存开启的条件</p>
<ol>
<li>在核心配置文件中，设置全局配置属性cacheEnabled=”true”，默认为true，不需要设置</li>
<li>在映射文件中设置标签<cache /></li>
<li>二级缓存必须在SqlSession关闭或提交之后有效</li>
<li>查询的数据所转换的实体类类型必须实现序列化的接口</li>
</ol>
</li>
<li><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p>
</li>
</ul>
<h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul>
<li>在mapper配置文件中添加的cache标签可以设置一些属性</li>
<li>eviction属性：缓存回收策略  </li>
<li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  <ul>
<li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  </li>
<li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  </li>
<li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
<li>默认的是 LRU</li>
</ul>
</li>
<li>flushInterval属性：刷新间隔，单位毫秒</li>
<li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li>
<li>size属性：引用数目，正整数</li>
<li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li>
<li>readOnly属性：只读，true/false</li>
<li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  <ul>
<li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</li>
</ul>
</li>
</ul>
<h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul>
<li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li>
<li>如果二级缓存没有命中，再查询一级缓存  </li>
<li>如果一级缓存也没有命中，则查询数据库  </li>
<li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li>
</ul>
<h2 id="整合第三方缓存EHCache（了解）"><a href="#整合第三方缓存EHCache（了解）" class="headerlink" title="整合第三方缓存EHCache（了解）"></a>整合第三方缓存EHCache（了解）</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="各个jar包的功能"><a href="#各个jar包的功能" class="headerlink" title="各个jar包的功能"></a>各个jar包的功能</h3><table>
<thead>
<tr>
<th>jar包名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mybatis-ehcache</td>
<td>Mybatis和EHCache的整合包</td>
</tr>
<tr>
<td>ehcache</td>
<td>EHCache核心包</td>
</tr>
<tr>
<td>slf4j-api</td>
<td>SLF4J日志门面包</td>
</tr>
<tr>
<td>logback-classic</td>
<td>支持SLF4J门面接口的一个具体实现</td>
</tr>
</tbody></table>
<h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><ul>
<li>名字必须叫<code>ehcache.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><ul>
<li>在xxxMapper.xml文件中设置二级缓存类型</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul>
<li>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件<code>logback.xml</code>，名字固定，不可改变</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table>
<thead>
<tr>
<th>属性名</th>
<th>是否必须</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>maxElementsInMemory</td>
<td>是</td>
<td>在内存中缓存的element的最大数目</td>
</tr>
<tr>
<td>maxElementsOnDisk</td>
<td>是</td>
<td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td>
</tr>
<tr>
<td>eternal</td>
<td>是</td>
<td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td>
</tr>
<tr>
<td>overflowToDisk</td>
<td>是</td>
<td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td>
</tr>
<tr>
<td>timeToIdleSeconds</td>
<td>否</td>
<td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td>
</tr>
<tr>
<td>timeToLiveSeconds</td>
<td>否</td>
<td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td>
</tr>
<tr>
<td>diskSpoolBufferSizeMB</td>
<td>否</td>
<td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td>
</tr>
<tr>
<td>diskPersistent</td>
<td>否</td>
<td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td>
</tr>
<tr>
<td>diskExpiryThreadIntervalSeconds</td>
<td>否</td>
<td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td>
</tr>
<tr>
<td>memoryStoreEvictionPolicy</td>
<td>否</td>
<td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出</td>
</tr>
</tbody></table>
<h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul>
<li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li>
<li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  </li>
<li>Java实体类  <ul>
<li>Mapper接口  </li>
<li>Mapper映射文件</li>
</ul>
</li>
</ul>
<h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MyBatis核心依赖包 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul>
<li>文件名必须是：<code>generatorConfig.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><ul>
<li><img src="Resources/%E6%89%A7%E8%A1%8CMBG%E6%8F%92%E4%BB%B6%E7%9A%84generate%E7%9B%AE%E6%A0%87.png"></li>
<li>如果出现报错：<code>Exception getting JDBC Driver</code>，可能是pom.xml中，数据库驱动配置错误</li>
<li>dependency中的驱动<img src="Resources/dependency%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png"><ul>
<li>mybatis-generator-maven-plugin插件中的驱动<img src="Resources/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png"></li>
<li>两者的驱动版本应该相同</li>
</ul>
</li>
<li>执行结果<img src="Resources/%E9%80%86%E5%90%91%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></li>
</ul>
<h2 id="QBC"><a href="#QBC" class="headerlink" title="QBC"></a>QBC</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li>
<li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li>
<li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件<br><img src="Resources/example%E7%9A%84%E6%96%B9%E6%B3%95.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	EmpExample example = <span class="keyword">new</span> EmpExample();</span><br><span class="line">	<span class="comment">//名字为张三，且年龄大于等于20</span></span><br><span class="line">	example.createCriteria().andEmpNameEqualTo(<span class="string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//或者did不为空</span></span><br><span class="line">	example.or().andDidIsNotNull();</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(example);</span><br><span class="line">	emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="Resources/example%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<h3 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h3><ul>
<li><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null</li>
<li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code><ul>
<li><img src="Resources/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png"></li>
</ul>
</li>
<li><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段</li>
<li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code><ul>
<li><img src="Resources/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></li>
</ul>
</li>
</ul>
<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件使用步骤"><a href="#分页插件使用步骤" class="headerlink" title="分页插件使用步骤"></a>分页插件使用步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul>
<li>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</li>
<li><img src="Resources/%E9%85%8D%E7%BD%AE%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6.png"></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><h3 id="开启分页功能"><a href="#开启分页功能" class="headerlink" title="开启分页功能"></a>开启分页功能</h3><ul>
<li>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能</li>
<li>pageNum：当前页的页码  <ul>
<li>pageSize：每页显示的条数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	<span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">	PageHelper.startPage(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="Resources/%E5%88%86%E9%A1%B5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p>
<h3 id="分页相关数据"><a href="#分页相关数据" class="headerlink" title="分页相关数据"></a>分页相关数据</h3><h4 id="方法一：直接输出"><a href="#方法一：直接输出" class="headerlink" title="方法一：直接输出"></a>方法一：直接输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	<span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">	Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//在查询到List集合后，打印分页数据</span></span><br><span class="line">	System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分页相关数据：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="方法二使用PageInfo"><a href="#方法二使用PageInfo" class="headerlink" title="方法二使用PageInfo"></a>方法二使用PageInfo</h4><ul>
<li>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据</li>
<li>list：分页之后的数据  <ul>
<li>navigatePages：导航分页的页码数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	InputStream is = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">	PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">	List&lt;Emp&gt; emps = mapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">	PageInfo&lt;Emp&gt; page = <span class="keyword">new</span> PageInfo&lt;&gt;(emps,<span class="number">5</span>);</span><br><span class="line">	System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分页相关数据：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, </span><br><span class="line">list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;], </span><br><span class="line">prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其中list中的数据等同于方法一中直接输出的page数据</p>
</li>
</ul>
<h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4><ul>
<li>pageNum：当前页的页码  </li>
<li>pageSize：每页显示的条数  </li>
<li>size：当前页显示的真实条数  </li>
<li>total：总记录数  </li>
<li>pages：总页数  </li>
<li>prePage：上一页的页码  </li>
<li>nextPage：下一页的页码</li>
<li>isFirstPage/isLastPage：是否为第一页/最后一页  </li>
<li>hasPreviousPage/hasNextPage：是否存在上一页/下一页  </li>
<li>navigatePages：导航分页的页码数  </li>
<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式学习</title>
    <url>/2022/08/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>整理来源于 </p>
<p><strong>【作者：刘伟</strong> <a href="http://blog.csdn.net/lovelion"><strong>http://blog.csdn.net/lovelion</strong></a><strong>】</strong></p>
<p>单例√、工厂方法√、建造者√、适配器√、装饰器√、代理√、策略、责任链、观察者、迭代器模式</p>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>*<em>单一职责原则*</em>(Single Responsibility Principle, SRP)*<em>：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</em>*</p>
<p>Sunny软件公司开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：</p>
<p>图1  初始设计方案结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336147233_3529.jpg" alt="1336147233_3529"></p>
<p>在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p>
<p>现使用单一职责原则对其进行重构。</p>
<pre><code>  在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：

  (1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；

  (2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；

  (3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。

  使用单一职责原则重构后的结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336147240_4896.jpg" alt="1336147240_4896"></p>
<h3 id="开闭封闭原则"><a href="#开闭封闭原则" class="headerlink" title="开闭封闭原则"></a>开闭封闭原则</h3><p>*<em>开闭原则*</em>(Open-Closed Principle, OCP)*<em>：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</em>*</p>
<p> 在开闭原则的定义中，<strong>软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类</strong>。</p>
<p><strong>抽象化是开闭原则的关键</strong>。</p>
<p>Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336201566_1496.jpg" alt="1336201566_1496"></p>
<p>  在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p>
<pre><code>  现对该系统进行重构，使之符合开闭原则。

   在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：

  (1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；

  (2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。

  重构后结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336201573_6059.jpg" alt="1336201573_6059"></p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
<pre><code>  里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
</code></pre>
<p>   里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<pre><code>  在使用里氏代换原则时需要注意如下几个问题：

  (1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。

  (2)  我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。

  (3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。
</code></pre>
<p> 在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图1所示：</p>
<p>图1原始结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336312710_1412.jpg" alt="1336312710_1412"></p>
<pre><code>  在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。

  在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图2所示：
</code></pre>
<p>图2  重构后的结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336312720_2300.jpg" alt="1336312720_2300"></p>
<pre><code>  里氏代换原则是实现开闭原则的重要方式之一。在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。
</code></pre>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p><em><strong>*依赖倒转原则**(Dependency Inversion Principle, DIP)**：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。*</strong></em></p>
<p>​         依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p>
<p>​        在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过<strong>依赖注入(DependencyInjection, DI)<strong>的方式注入到其他对象中，</strong>依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</strong>常用的注入方式有三种，分别是：<strong>构造注入，设值注入（Setter注入）和接口注入</strong>。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p>
<p> 下面通过一个简单实例来加深对依赖倒转原则的理解：</p>
<pre><code>  Sunny软件公司开发人员在开发某CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图1所示：
</code></pre>
<p>图1 初始设计方案结构图</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336909329_9009.jpg" alt="1336909329_9009"></p>
<pre><code>  在编码实现图1所示结构时，Sunny软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。

  在本实例中，由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图2所示：
</code></pre>
<p>图2重构后的结构图</p>
<p>​     <img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1336909334_4352.jpg" alt="1336909334_4352"></p>
<p>  在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，<strong>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，</strong>它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>**接口隔离原则(Interface Segregation Principle, ISP)**：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong></p>
<p>一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“<strong>角色隔离原则</strong>”。</p>
<p><strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口</strong>。</p>
<p>Sunny软件公司开发人员针对某CRM系统的客户数据显示模块设计了如图1所示接口，其中方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/11.jpg" alt="11"></p>
<p>图1 初始设计方案结构图</p>
<pre><code>  在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。

  现使用接口隔离原则对其进行重构。
</code></pre>
<p>  在图1中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。</p>
<pre><code>  通过使用接口隔离原则，本实例重构后的结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/111.jpg" alt="111"></p>
<p>图2 重构后的结构图</p>
<p>  <strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>**合成复用原则(Composite Reuse Principle, CRP)**：尽量使用对象组合，而不是继承来达到复用的目的。</p>
<p>*<em>复用时要尽量使用组合*</em>/**聚合关系（关联关系），少用继承**。</p>
<p>即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，<strong>组合/聚合可以使系统更加灵活，降低类与类之间的耦合度</strong>，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，<strong>而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</strong></p>
<p>  Sunny软件公司开发人员在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图1所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/22.jpg" alt="22"></p>
<p>图1  初始设计方案结构图</p>
<p>  随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。【当然也可以修改DBUtil类的源代码，同样会违反开闭原则。】</p>
<p>  现使用合成复用原则对其进行重构。</p>
<p>  根据合成复用原则，我们在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如图2所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/222.jpg" alt="222"></p>
<p> 在图2中，<strong>CustomerDAO和DBUtil之间的关系由继承关系变为关联关系</strong>，<strong>采用依赖注入的方式将DBUtil对象注入到CustomerDAO中</strong>，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><strong>迪米特法则(Law of Demeter, LoD)：</strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
<p>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>
<p>迪米特法则中，对于一个对象，其朋友包括以下几类：</p>
<pre><code>  (1) 当前对象本身(this)；

  (2) 以参数形式传入到当前对象方法中的对象；

  (3) 当前对象的成员对象；

  (4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；

  (5) 当前对象所创建的对象。
</code></pre>
<p>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</strong></p>
<p>  在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</strong></p>
<p>下面通过一个简单实例来加深对迪米特法则的理解：</p>
<p>  Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图1所示结构：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/333.jpg" alt="333"></p>
<p>图1 初始设计方案结构图</p>
<p>  在图1中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p>
<p>  现使用迪米特对其进行重构。</p>
<p>  在本实例中，<strong>可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码</strong>，重构后结构如图2所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/33.jpg" alt="33"></p>
<p>图2  重构后的结构图</p>
<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<h2 id="一、创建模式"><a href="#一、创建模式" class="headerlink" title="一、创建模式"></a>一、创建模式</h2><h3 id="1、工厂模式"><a href="#1、工厂模式" class="headerlink" title="1、工厂模式"></a>1、工厂模式</h3><h4 id="1-1简单工厂模式"><a href="#1-1简单工厂模式" class="headerlink" title="1.1简单工厂模式"></a>1.1简单工厂模式</h4><p><strong>具体产品类</strong>实现<strong>抽象产品类</strong>，<strong>工厂类</strong>进行类型判断执行<strong>具体产品类</strong>的方法</p>
<p>简单工厂模式(Simple Factory Pattern)：<strong>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</strong>因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<p><strong>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</strong></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/123.jpg" alt="123"></p>
<p>为了将Chart类的职责分离，同时将Chart对象的创建和使用分离，Sunny软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图2所示：</p>
<p><img src="https://img-blog.csdn.net/20130711144554265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>图2图表库结构图</p>
<p>总结<br>      简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<pre><code>     1. 主要优点

   简单工厂模式的主要优点如下：

   (1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

   (2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

   (3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。













     2. 主要缺点

   简单工厂模式的主要缺点如下：

   (1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

   (2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。

   (3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

   (4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。













    3. 适用场景

   在以下情况下可以考虑使用简单工厂模式：

   (1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。

   (2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。
</code></pre>
<h4 id="1-2工厂方法模式"><a href="#1-2工厂方法模式" class="headerlink" title="1.2工厂方法模式"></a>1.2工厂方法模式</h4><p><strong>具体产品类</strong>实现<strong>抽象产品类</strong>，<strong>具体工厂类</strong>实现<strong>抽象产品类</strong></p>
<p>通过<strong>具体工厂类</strong>来调用构造<strong>具体产品类</strong></p>
<p>当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？</p>
<p>在工厂方法模式中，我们<strong>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构</strong>。工厂方法模式定义如下：</p>
<pre><code>   工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。
</code></pre>
<p>   工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图2所示：<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.2.jpg" alt="1.1.2"></p>
<pre><code>   在工厂方法模式结构图中包含如下几个角色：

   ● Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。

   ● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。

   ● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。

   ● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。
</code></pre>
<p>完整解决方案</p>
<p>​     Sunny公司开发人员决定使用工厂方法模式来设计日志记录器，其基本结构如图3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.2.1.jpg" alt="1.1.2.1"></p>
<p>工厂方法模式总结<br>      工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p>
<pre><code>1. 主要优点
</code></pre>
<p>   工厂方法模式的主要优点如下：</p>
<p>   (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>   (2) 基于工厂角色和产品角色的<strong>多态性设计</strong>是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有<strong>同一抽象父类</strong>。</p>
<p>   (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，<strong>无须修改抽象工厂和抽象产品提供的接口</strong>，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，<strong>完全符合“开闭原则</strong>”。</p>
<ol start="2">
<li>主要缺点</li>
</ol>
<p> 工厂方法模式的主要缺点如下：</p>
<p>  (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，<strong>在一定程度上增加了系统的复杂度</strong>，<strong>有更多的类需要编译和运行，会给系统带来一些额外的开销。</strong></p>
<p>  (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<ol start="3">
<li>适用场景</li>
</ol>
<p>   在以下情况下可以考虑使用工厂方法模式：</p>
<p>   (1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p>   (2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
<h4 id="1-3抽象工厂模式"><a href="#1-3抽象工厂模式" class="headerlink" title="1.3抽象工厂模式"></a>1.3抽象工厂模式</h4><p>​    <strong>具体产品类</strong>实现<strong>抽象产品</strong>接口，<strong>具体工厂类</strong>实现<strong>抽象工厂接口</strong></p>
<p>​    具体工厂类构造一系列产品族，每个具体工厂对应一个产品等级。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.3.jpg" alt="1.1.3.3"></p>
<h5 id="1-为什么引入抽象工厂模式"><a href="#1-为什么引入抽象工厂模式" class="headerlink" title="1.为什么引入抽象工厂模式"></a>1.为什么引入抽象工厂模式</h5><pre><code> 界面皮肤库的初始设计
   Sunny软件公司欲开发一套界面皮肤库，可以对Java桌面软件进行界面美化。为了保护版权，该皮肤库源代码不打算公开，而只向用户提供已打包为jar文件的class字节码文件。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，其结构示意图如图1所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.jpg" alt="1.1.3"></p>
<p>图1 界面皮肤库结构示意图</p>
<pre><code>   该皮肤库需要具备良好的灵活性和可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。

   Sunny软件公司的开发人员针对上述要求，决定使用工厂方法模式进行系统的设计，为了保证系统的灵活性和可扩展性，提供一系列具体工厂来创建按钮、文本框、组合框等界面元素，客户端针对抽象工厂编程，初始结构如图2所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.1.jpg" alt="1.1.3.1"></p>
<p>图2 基于工厂方法模式的界面皮肤库初始结构图</p>
<p>   在图2中，提供了大量工厂来创建具体的界面组件，可以通过配置文件更换具体界面组件从而改变界面风格。但是，此设计方案存在如下问题：</p>
<p>   (1) 当需要增加新的皮肤时，虽然不要修改现有代码，但是需要增加大量类，针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加，这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销；</p>
<p>   (2) 由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。</p>
<p>   如何减少系统中类的个数并保证客户端每次始终只使用某一种风格的具体界面组件？这是Sunny公司开发人员所面临的两个问题，显然，工厂方法模式无法解决这两个问题，别着急，本文所介绍的抽象工厂模式可以让这些问题迎刃而</p>
<h5 id="2-产品等级结构与产品族"><a href="#2-产品等级结构与产品族" class="headerlink" title="2 产品等级结构与产品族"></a>2 产品等级结构与产品族</h5><p>​       在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解抽象工厂模式，我们先引入两个概念：</p>
<pre><code>   (1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。

   (2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。
</code></pre>
<p> 产品等级结构与产品族示意图如图3所示：<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.2.jpg" alt="1.1.3.2"></p>
<p>当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.3.jpg" alt="1.1.3.3"></p>
<p>图4 抽象工厂模式示意图</p>
<pre><code>   在图4中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图4所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数。
</code></pre>
<h5 id="3-抽象工厂模式概述"><a href="#3-抽象工厂模式概述" class="headerlink" title="3 抽象工厂模式概述"></a>3 抽象工厂模式概述</h5><p>​       抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。抽象工厂模式定义如下：</p>
<p>   <strong>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。</strong></p>
<p>   在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图5所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.1.3.4.jpg" alt="1.1.3.4"></p>
<p>图5  抽象工厂模式结构图</p>
<pre><code>   在抽象工厂模式结构图中包含如下几个角色：

   ● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。

   ● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。

   ● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。

   ● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

   在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：
</code></pre>
<h5 id="4-完整解决方案"><a href="#4-完整解决方案" class="headerlink" title="4 完整解决方案"></a>4 完整解决方案</h5><p>​    Sunny公司开发人员使用抽象工厂模式来重构界面皮肤库的设计，其基本结构如图6所示：</p>
<p><img src="https://img-blog.csdn.net/20130713164620203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p>图6界面皮肤库结构图</p>
<h5 id="5-“开闭原则”的倾斜性"><a href="#5-“开闭原则”的倾斜性" class="headerlink" title="5 “开闭原则”的倾斜性"></a>5 “开闭原则”的倾斜性</h5><p>​       Sunny公司使用抽象工厂模式设计了界面皮肤库，该皮肤库可以较为方便地增加新的皮肤，但是现在遇到一个非常严重的问题：由于设计时考虑不全面，忘记为单选按钮(RadioButton)提供不同皮肤的风格化显示，导致无论选择哪种皮肤，单选按钮都显得那么“格格不入”。Sunny公司的设计人员决定向系统中增加单选按钮，但是发现原有系统居然不能够在符合“开闭原则”的前提下增加新的组件，原因是抽象工厂SkinFactory中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先需要修改抽象工厂接口SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。</p>
<p>   怎么办？答案是抽象工厂模式无法解决该问题，这也是抽象工厂模式最大的缺点。<strong>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。</strong>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<p>   <strong>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</strong></p>
<p>   <strong>(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</strong></p>
<p>   正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p>
<h5 id="6-抽象工厂模式总结"><a href="#6-抽象工厂模式总结" class="headerlink" title="6 抽象工厂模式总结"></a>6 抽象工厂模式总结</h5><p>​       抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p>
<pre><code>   1. 主要优点

   抽象工厂模式的主要优点如下：

   (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。

   (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。

   (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。



   2. 主要缺点

   抽象工厂模式的主要缺点如下：

   增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。













   3. 适用场景

   在以下情况下可以考虑使用抽象工厂模式：

   (1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。

   (2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。

   (3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。

   (4) 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。
</code></pre>
<h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p><strong>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</strong></p>
<p> 单例模式有三个要点：</p>
<p><strong>一是某个类只能有一个实例</strong></p>
<p><strong>二是它必须自行创建这个实例</strong></p>
<p><strong>三是它必须自行向整个系统提供这个实例。</strong></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.2.jpg" alt="1.2"></p>
<h4 id="2-1饿汉式单例类"><a href="#2-1饿汉式单例类" class="headerlink" title="2.1饿汉式单例类"></a>2.1饿汉式单例类</h4><pre><code>  饿汉式单例类是实现起来最简单的单例类，饿汉式单例类结构图如图3-4所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.2.1.jpg" alt="1.2.1"></p>
<pre><code>    从图3-4中可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象，代码如下所示：
</code></pre>
<p>class EagerSingleton {<br>    private static final EagerSingleton instance = new EagerSingleton();<br>    private EagerSingleton() { } </p>
<pre><code>public static EagerSingleton getInstance() &#123;
    return instance; 
&#125;   
</code></pre>
<p>}<br>      <strong>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</strong></p>
<h4 id="2-2懒汉式单例类与线程锁定"><a href="#2-2懒汉式单例类与线程锁定" class="headerlink" title="2.2懒汉式单例类与线程锁定"></a>2.2懒汉式单例类与线程锁定</h4><pre><code>  除了饿汉式单例，还有一种经典的懒汉式单例，也就是前面的负载均衡器LoadBalancer类的实现方式。懒汉式单例类结构图如图3-5所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.2.2.jpg" alt="1.2.2"></p>
<p>  从图3-5中可以看出，懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LazySingleton &#123; </span><br><span class="line">    private static LazySingleton instance = null;]() </span><br><span class="line"></span><br><span class="line">private LazySingleton() &#123; &#125; </span><br><span class="line"></span><br><span class="line">synchronized public static LazySingleton getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        instance = new LazySingleton(); </span><br><span class="line">    &#125;</span><br><span class="line">    return instance; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​      但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码“instance = new LazySingleton();”进行锁定即可。<strong>即通过synchronized代码块来实现同步</strong>，因此getInstance()方法可以进行如下改进：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static LazySingleton getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        synchronized (LazySingleton.class) &#123;</span><br><span class="line">            instance = new LazySingleton(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​       问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一。原因如下：<br>​      </p>
<p>​         假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。</p>
<p>​        <strong>但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象</strong>，违背单例模式的设计思想，因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，</p>
<p>​        这种方式称为**双重检查锁定(Double-Check Locking)**。使用双重检查锁定实现的懒汉式单例类完整代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LazySingleton &#123; </span><br><span class="line">    private volatile static LazySingleton instance = null; </span><br><span class="line"></span><br><span class="line">private LazySingleton() &#123; &#125; </span><br><span class="line"></span><br><span class="line">public static LazySingleton getInstance() &#123; </span><br><span class="line">    //第一重判断</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        //锁定代码块</span><br><span class="line">        synchronized (LazySingleton.class) &#123;</span><br><span class="line">            //第二重判断</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new LazySingleton(); //创建单例实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​       需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p>
<h5 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h5><p>双检锁：单例模式中用volatile和synchronized来满足双重检查锁机制；<br>在实现单例模式的时候往往会忽略掉多线程的情况而volatile（java5）：可以保证多线程下的可见性;<br>双重检查锁：</p>
<p>双重锁进行了两次判空：第一层判断为了避免不必要的同步，第二层判断则是为了在null的情况下创建实例代码会检查两次单例类是否有已存在的实例，一次加锁一次不加锁，一次确保不会有多个实例被创建。单例模式中用volatile和synchronized来满足双重检查锁机制</p>
<p>读volatile：每当子线程某一语句要用到volatile变量时，都会从主线程重新拷贝一份，这样就保证子线程的会跟主线程的一致。<br>写volatile: 每当子线程某一语句要写volatile变量时，都会在读完后同步到主线程去，这样就保证主线程的变量及时更新。<br>正确的双重检查锁定模式需要需要使用 volatile。volatile主要包含两个功能。<br>1：使用 volatile定义的变量，将会保证对所有线程的可见性。2：禁止指令重排序优化。<br>由于 volatile禁止对象创建时指令之间重排序，所以其他线程不会访问到一个未初始化的对象，从而保证安全性。<br>对象的创建可能发生指令的重排序，使用 volatile可以禁止指令的重排序，保证多线程环境内的系统安全。</p>
<h4 id="2-3单例模式总结"><a href="#2-3单例模式总结" class="headerlink" title="2.3单例模式总结"></a>2.3单例模式总结</h4><p>​       单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p>
<p>1.主要优点</p>
<p>   单例模式的主要优点如下：</p>
<p>   (1) 单例模式提供了对<strong>唯一实例的受控访问</strong>。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</p>
<p>   (2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，<strong>对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</strong></p>
<p>   (3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。 </p>
<p>2.主要缺点</p>
<p>   单例模式的主要缺点如下：</p>
<p>   (1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</p>
<p>   (2) <strong>单例类的职责过重，在一定程度上违背了“单一职责原则”。</strong>因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</p>
<p>   (3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，<strong>因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</strong></p>
<p>3.适用场景</p>
<p>   在以下情况下可以考虑使用单例模式：</p>
<p>   (1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>
<p>   (2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>
<h3 id="3、建造者模式"><a href="#3、建造者模式" class="headerlink" title="3、建造者模式"></a>3、建造者模式</h3><p><strong>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</strong></p>
<p> 建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图8-2所示：<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.jpg" alt="1.3"></p>
<p>图8-2 建造者模式结构图</p>
<p>  在建造者模式结构图中包含如下几个角色：</p>
<p>● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p>
<p>●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p>
<p>●Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p>
<p>● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p>
<h4 id="案例–解决方案"><a href="#案例–解决方案" class="headerlink" title="案例–解决方案"></a>案例–解决方案</h4><p>   Sunny公司开发人员决定使用建造者模式来实现游戏角色的创建，其基本结构如图8-3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.1.jpg" alt="1.3.1"></p>
<p><strong>图*<em>8-3*</em> 游戏角色创建结构图</strong></p>
<p>在建造者模式中，<strong>客户端只需实例化指挥者类，指挥者类针对抽象建造者编程</strong>，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品（逐步调用具体建造者的buildX()方法），相同的构造过程可以创建完全不同的产品。在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。</p>
<p>在建造者模式中，客户端只需实例化指挥者类，指挥者类针对抽象建造者编程，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品（逐步调用具体建造者的buildX()方法），相同的构造过程可以创建完全不同的产品。在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。</p>
<p> **<em>*1.*<em>省略*<em>Director*</em></em></em></p>
<p>   在有些情况下，为了简化系统结构，可以将Director和抽象建造者Builder进行合并，在Builder中提供逐步构建复杂产品对象的construct()方法。由于Builder类通常为抽象类，因此可以将construct()方法定义为静态(static)方法</p>
<p>**<em>*2.*<em>钩子方法的引入</em></em></p>
<p>​    建造者模式除了逐步构建一个复杂产品对象外，还可以通过Director类来更加精细地控制产品的创建过程，例如增加一类称之为钩子方法(HookMethod)的特殊方法来控制是否对某个buildPartX()的调用。</p>
<h4 id="建造者模式总结"><a href="#建造者模式总结" class="headerlink" title="建造者模式总结"></a>建造者模式总结</h4><p>​      建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。</p>
<p>1.主要优点</p>
<p>  建造者模式的主要优点如下：</p>
<p>(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，<strong>使得相同的创建过程可以创建不同的产品对象。</strong></p>
<p>(2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很<strong>方便地替换具体建造者或增加新的具体建造者</strong>，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，<strong>系统扩展方便</strong>，<strong>符合“开闭原则”</strong></p>
<p>(3) <strong>可以更加精细地控制产品的创建过程。</strong>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p>
<p>2.主要缺点</p>
<p>  建造者模式的主要缺点如下：</p>
<p>(1) <strong>建造者模式所创建的产品一般具有较多的共同点</strong>，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其<strong>使用范围受到一定的限制</strong>。</p>
<p>(2) <strong>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</strong></p>
<p>3.适用场景</p>
<pre><code>  在以下情况下可以考虑使用建造者模式：
</code></pre>
<p>(1) 需要生成的产品对象有<strong>复杂的内部结构，这些产品对象通常包含多个成员属性。</strong></p>
<p>(2) 需要<strong>生成的产品对象的属性相互依赖</strong>，需要<strong>指定其生成顺序</strong>。</p>
<p>(3) 对象的创建过程<strong>独立于</strong>创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</p>
<p>(4) <strong>隔离复杂对象的创建和使用</strong>，并使得相同的创建过程可以创建不同的产品。</p>
<h3 id="1-4原型模式"><a href="#1-4原型模式" class="headerlink" title="1.4原型模式"></a>1.4原型模式</h3><p><strong>原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</strong></p>
<p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p>
<p>  需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.2.jpg" alt="1.3.2"></p>
<p>7-2 原型模式结构图</p>
<pre><code>  在原型模式结构图中包含如下几个角色：

  ●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。

  ● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

  ● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。
</code></pre>
<p>1.浅克隆</p>
<pre><code>  在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制，如图7-4所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.3.jpg" alt="1.3.3"></p>
<p>图7-4 浅克隆示意图</p>
<pre><code>  在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。为了让大家更好地理解浅克隆和深克隆的区别，我们首先使用浅克隆来实现工作周报和附件类的复制，其结构如图7-5所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.4.jpg" alt="1.3.4"></p>
<p>2.深克隆</p>
<pre><code>  在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制，如图7-6所示：
</code></pre>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.6.jpg" alt="1.3.6"></p>
<p>图7-6 深克隆示意图</p>
<pre><code>  在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。下面我们使用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写入流中，因此两个类均需要实现Serializable接口，其结构如图7-7所示：
</code></pre>
<p>图7-7 带附件的周报结构图（深克隆）<br><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.5.jpg" alt="1.3.5"></p>
<h2 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h2><h3 id="1、适配器模式"><a href="#1、适配器模式" class="headerlink" title="1、适配器模式"></a>1、适配器模式</h3><p>​    <strong>抽象接口定义请求方法，适配器实现具体请求调用创建过程，适配者实现请求具体方法</strong></p>
<p>​    <strong>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</strong></p>
<p><strong>【注：在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。】</strong></p>
<p>   在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，<strong>适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</strong>在实际开发中，对象适配器的使用频率更高，对象适配器模式结构如图9-3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.1.jpg" alt="2.1"></p>
<p>图 9-3 对象适配器模式结构图</p>
<p>   在对象适配器模式结构图中包含如下几个角色：</p>
<p>   ● Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p>
<p>   ● Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p>
<p>   ● Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p>
<h4 id="对象适配器案例"><a href="#对象适配器案例" class="headerlink" title="对象适配器案例"></a>对象适配器案例</h4><p>Sunny软件公司开发人员决定使用适配器模式来重用算法库中的算法，其基本结构如图9-4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.1.1.jpg" alt="2.1.1"></p>
<p>图9-4  算法库重用结构图</p>
<p>   在图9-4中，ScoreOperation接口充当抽象目标，QuickSort和BinarySearch类充当适配者，OperationAdapter充当适配器。完整代码如下所示：</p>
<p>//抽象成绩操作类：目标接口</p>
<p>interface ScoreOperation {</p>
<p>​    public int[] sort(int array[]); //成绩排序</p>
<p>​    public int search(int array[],int key); //成绩查找</p>
<p>}</p>
<p>//快速排序类：适配者</p>
<p>class QuickSort {</p>
<p>​    public int[] quickSort(int array[]) {</p>
<p>​        sort(array,0,array.length-1);</p>
<p>​        return array;</p>
<p>​    }</p>
<p>​    public void sort(int array[],int p, int r) {</p>
<p>​        int q=0;</p>
<p>​        if(p&lt;r) {</p>
<p>​            q=partition(array,p,r);</p>
<p>​            sort(array,p,q-1);</p>
<p>​            sort(array,q+1,r);</p>
<p>​        }</p>
<p>​    }</p>
<p>​    public int partition(int[] a, int p, int r) {</p>
<p>​        int x=a[r];</p>
<p>​        int j=p-1;</p>
<p>​        for (int i=p;i&lt;=r-1;i++) {</p>
<p>​            if (a[i]&lt;=x) {</p>
<p>​                j++;</p>
<p>​                swap(a,j,i);</p>
<p>​            }</p>
<p>​        }</p>
<p>​        swap(a,j+1,r);</p>
<p>​        return j+1;<br>​    }</p>
<p>​    public void swap(int[] a, int i, int j) {   </p>
<p>​        int t = a[i];   </p>
<p>​        a[i] = a[j];   </p>
<p>​        a[j] = t;   </p>
<p>​    }</p>
<p>}</p>
<p>//二分查找类：适配者</p>
<p>class BinarySearch {</p>
<p>​    public int binarySearch(int array[],int key) {</p>
<p>​        int low = 0;</p>
<p>​        int high = array.length -1;</p>
<p>​        while(low &lt;= high) {</p>
<p>​            int mid = (low + high) / 2;</p>
<p>​            int midVal = array[mid];</p>
<p>​            if(midVal &lt; key) {  </p>
<p>low = mid +1;  </p>
<p>}</p>
<p>​            else if (midVal &gt; key) {  </p>
<p>high = mid -1;  </p>
<p>}</p>
<p>​            else {  </p>
<p>return 1; //找到元素返回1  </p>
<p>}</p>
<p>​        }</p>
<p>​        return -1;  //未找到元素返回-1</p>
<p>​    }</p>
<p>}</p>
<p>//操作适配器：适配器</p>
<p>class OperationAdapter implements ScoreOperation {</p>
<p>​    private QuickSort sortObj; //定义适配者QuickSort对象</p>
<p>​    private BinarySearch searchObj; //定义适配者BinarySearch对象</p>
<p>​    public OperationAdapter() {</p>
<p>​        sortObj = new QuickSort();</p>
<p>​        searchObj = new BinarySearch();</p>
<p>​    }</p>
<p>​    public int[] sort(int array[]) {  </p>
<p>return sortObj.quickSort(array); //调用适配者类QuickSort的排序方法</p>
<p>}</p>
<p>​    public int search(int array[],int key) {  </p>
<p>return searchObj.binarySearch(array,key); //调用适配者类BinarySearch的查找方法</p>
<p>}</p>
<p>}</p>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>，****类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系****，类适配器模式结构如图9-5所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.1.2.jpg" alt="2.1.2"></p>
<p>图 9-5 类适配器模式结构图</p>
<p>   根据类适配器模式结构图，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，实现了适配。</p>
<p>   典型的类适配器代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Adapter extends Adaptee implements Target &#123;</span><br><span class="line">	public void request() &#123;</span><br><span class="line">		specificRequest();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Java、C#等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器；此外，如果适配者Adaptee为最终(Final)类，也无法使用类适配器。在Java等面向对象编程语言中，大部分情况下我们使用的是对象适配器，类适配器较少使用。</p>
<h4 id="缺省适配器"><a href="#缺省适配器" class="headerlink" title="缺省适配器"></a>缺省适配器</h4><p>  缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。缺省适配器模式的定义如下：<br><strong>缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</strong></p>
<p>   缺省适配器模式结构如图9-7所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/1.3.7.jpg" alt="1.3.7"></p>
<p>● ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。</p>
<p>  ● AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。</p>
<p>  ● ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。</p>
<h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><p>​      适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p>
<ol>
<li>主要优点</li>
</ol>
<p>   无论是对象适配器模式还是类适配器模式都具有如下优点：</p>
<p>   (1) <strong>将目标类和适配者类解耦</strong>，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p>
<p>   (2) <strong>增加了类的透明性和复用性</strong>，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p>
<p>   (3) <strong>灵活性和扩展性都非常好</strong>，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p>
<p>  具体来说，类适配器模式还有如下优点：</p>
<p>  由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p>
<p>  对象适配器模式还有如下优点：</p>
<p>  (1) <strong>一个对象适配器可以把多个不同的适配者适配到同一个目标</strong>；</p>
<p>  (2) <strong>可以适配一个适配者的子类</strong>，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</p>
<p>2.主要缺点</p>
<p> 类适配器模式的缺点如下：</p>
<p>  (1) 对于Java、C#等不支持多重类继承的语言，<strong>一次最多只能适配一个适配者类，不能同时适配多个适配者；</strong></p>
<p>  (2) 适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</p>
<p>  (3) 在Java、C#等语言中，<strong>类适配器模式中的目标抽象类只能为接口</strong>，不能为类，其使用有一定的局限性。</p>
<p>  对象适配器模式的缺点如下：</p>
<p>  与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<p>3.适用场景</p>
<p>  在以下情况下可以考虑使用适配器模式：</p>
<p>   (1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p>
<p>   (2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>
<h3 id="2、桥接模式"><a href="#2、桥接模式" class="headerlink" title="2、桥接模式"></a>2、桥接模式</h3><p> Bridge Pattern</p>
<p>​    <strong>抽象类</strong>定义<strong>实现类接口</strong>，<strong>具体实现类</strong>实现<strong>实现类接口</strong>的方法</p>
<p>​    <strong>扩充抽象类</strong>继承<strong>抽象类</strong>，实现抽象类的方法</p>
<p>​    毛笔和蜡笔。假如我们需要大中小3种型号的画笔，能够绘制12种不同的颜色，如果使用蜡笔，需要准备3×12 = 36支，但如果使用毛笔的话，只需要提供3种型号的毛笔，外加12个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与36支蜡笔同样的功能。</p>
<p>​    桥接模式是一种很实用的结构型设计模式，如果软件系统中<strong>某个类存在两个独立变化的维度</strong>，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。</p>
<p>*<em>桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体*</em>(Handle and Body)模式或接口(Interface)*<em>模式。</em>*</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.jpg" alt="2.2"></p>
<p>●Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</p>
<p>●RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。</p>
<p>●Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。</p>
<p>●ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。</p>
<p>​    桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。</p>
<p><strong>型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分</strong>，结构示意图如图10-4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.1.jpg" alt="2.2.1"></p>
<h4 id="跨平台图像浏览系统"><a href="#跨平台图像浏览系统" class="headerlink" title="跨平台图像浏览系统"></a>跨平台图像浏览系统</h4><p>跨平台图像浏览系统的桥接模式解决方案</p>
<p> 为了减少所需生成的子类数目，实现将操作系统和图像文件格式两个维度分离，使它们可以独立改变，Sunny公司开发人员使用桥接模式来重构跨平台图像浏览系统的设计，其基本结构如图10-5所示：</p>
<img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.2.jpg" alt="2.2.2" style="zoom:150%;" />

<p>​     在图10-5中，Image充当抽象类，其子类JPGImage、PNGImage、BMPImage和GIFImage充当扩充抽象类；ImageImp充当实现类接口，其子类WindowsImp、LinuxImp和UnixImp充当具体实现类。</p>
<p>​    若需要更换图像文件格式或者更换操作系统，只需修改配置文件即可，在实际使用时，<strong>可以通过分析图像文件格式后缀名来确定具体的文件格式，在程序运行时获取操作系统信息来确定操作系统类型</strong>，无须使用配置文件。<strong>系统具有较好的可扩展性，完全符合“开闭原则”。</strong></p>
<h4 id="适配器与桥接的联用"><a href="#适配器与桥接的联用" class="headerlink" title="适配器与桥接的联用"></a>适配器与桥接的联用</h4><p>​        适配器模式可以解决两个已有接口间不兼容问题，在这种情况下被适配的类往往是一个黑盒子，有时候我们不想也不能改变这个被适配的类，也不能控制其扩展。。桥接模式则不同，用户可以通过接口继承或类继承的方式来对系统进行扩展。</p>
<p>​    <strong>桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色</strong>，使它们可以分别进行变化；而在初步设计完成之后，<strong>当发现系统与已有类无法协同工作时，可以采用适配器模式。</strong></p>
<p>​        在设计过程中，由于存在报表显示和数据采集两个独立变化的维度，因此可以使用桥接模式进行初步设计；为了使用Excel相关的API来进行数据采集则需要使用适配器模式。系统的完整设计中需要将两个模式联用，如图10-6所示</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.2.3.jpg" alt="2.2.3"></p>
<h4 id="桥接模式总结"><a href="#桥接模式总结" class="headerlink" title="桥接模式总结"></a>桥接模式总结</h4><p>​        桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛。<strong>在软件开发中如果一个类或一个系统有多个变化维度时</strong>，都可以尝试使用<strong>桥接模式</strong>对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。</p>
<p>1.主要优点</p>
<p>​    桥接模式的主要优点如下：</p>
<p>​    (1)<strong>分离抽象接口及其实现部分</strong>。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</p>
<p>​    (2)<strong>在很多情况下，桥接模式可以取代多层继承方案</strong>，<strong>多层继承方案违背了“单一职责原则”</strong>，<strong>复用性较差</strong>，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</p>
<p>​    (3)<strong>桥接模式提高了系统的可扩展性</strong>，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</p>
<p>2.主要缺点</p>
<p>​    桥接模式的主要缺点如下：</p>
<p>​    (1)<strong>桥接模式的使用会增加系统的理解与设计难度</strong>，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</p>
<p>​    (2)<strong>桥接模式要求正确识别出系统中两个独立变化的维度</strong>，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</p>
<p>3.适用场景</p>
<p>​    在以下情况下可以考虑使用桥接模式：</p>
<p>​    (1)如果一个系统需要在<strong>抽象化和具体化之间增加更多的灵活性</strong>，<strong>避免在两个层次之间建立静态的继承关系</strong>，通过桥接模式可以使它们在抽象层建立一个关联关系。</p>
<p>​    (2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</p>
<p>​    (3)<strong>一个类存在两个（或多个）独立变化的维度</strong>，且这两个（或多个）维度都需要独立进行扩展。</p>
<p>​    (4)对于那些<strong>不希望使用继承或因为多层继承</strong>导致系统类的个数急剧增加的系统，桥接模式尤为适用。</p>
<h3 id="3、装饰模式"><a href="#3、装饰模式" class="headerlink" title="3、装饰模式"></a>3、装饰模式</h3><p>​       装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p>
<p>  装饰模式定义如下：</p>
<p><strong>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</strong></p>
<p>  在装饰模式中，为了让系统具有更好的灵活性和可扩展性，我们通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类，装饰模式结构如图12-3所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.jpg" alt="2.3"></p>
<p>● Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，<strong>声明了在具体构件中实现的业务方法</strong>，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>● ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</p>
<p>● Decorator（抽象装饰类）：它也是抽象构件类的子类，<strong>用于给具体构件增加职责</strong>，<strong>但是具体职责在其子类中实现</strong>。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>● ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，<strong>负责向构件添加新的职责</strong>。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</p>
<h4 id="装饰模式案例"><a href="#装饰模式案例" class="headerlink" title="装饰模式案例"></a>装饰模式案例</h4><p> 如何提高图形界面构件库性的可扩展性并降低其维护成本是Sunny公司开发人员必须面对的一个问题。</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.2.jpg" alt="2.3.2"></p>
<p>   为了让系统具有更好的灵活性和可扩展性，克服继承复用所带来的问题，Sunny公司开发人员使用装饰模式来重构图形界面构件库的设计，其中部分类的基本结构如图12-4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.1.jpg" alt="2.3.1"></p>
<p>图12-4 图形界面构件库结构图</p>
<pre><code>  在图12-4中，Component充当抽象构件类，其子类Window、TextBox、ListBox充当具体构件类，Component类的另一个子类ComponentDecorator充当抽象装饰类，ComponentDecorator的子类ScrollBarDecorator和BlackBorderDecorator充当具体装饰类。
</code></pre>
<h4 id="装饰模式注意事项"><a href="#装饰模式注意事项" class="headerlink" title="装饰模式注意事项"></a>装饰模式注意事项</h4><p>​      在使用装饰模式时，通常我们需要注意以下几个问题：</p>
<p>(1) 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。</p>
<p>(2) 尽量保持具体构件类ConcreteComponent是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。</p>
<p>(3) 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。如图12-6所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.3.3.jpg" alt="2.3.3"></p>
<p>图12-6 没有抽象构件类的装饰模式</p>
<h4 id="装饰模式总结"><a href="#装饰模式总结" class="headerlink" title="装饰模式总结"></a>装饰模式总结</h4><p>​      装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在JavaIO中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p>
<p>1.主要优点</p>
<p>  装饰模式的主要优点如下：</p>
<p>(1) 对于扩展一个对象的功能，<strong>装饰模式比继承更加灵活性</strong>，不会导致类的个数急剧增加。</p>
<p>(2) 可以通过一种<strong>动态的方式来扩展一个对象的功能</strong>，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</p>
<p>(3) <strong>可以对一个对象进行多次装饰</strong>，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到<strong>功能更为强大的对象</strong>。</p>
<p>(4) <strong>具体构件类与具体装饰类可以独立变化</strong>，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，<strong>符合“开闭原则”。</strong></p>
<p>2.主要缺点</p>
<p>  装饰模式的主要缺点如下：</p>
<p>(1) 使用装饰模式进行系统设计时将<strong>产生很多小对象</strong>，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，<strong>大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</strong></p>
<p>(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，<strong>排错也很困难</strong>，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</p>
<p>3.适用场景</p>
<p>  在以下情况下可以考虑使用装饰模式：</p>
<p>(1) 在<strong>不影响其他对象</strong>的情况下，以<strong>动态、透明的方式给单个对象添加职责。</strong></p>
<p>(2) 当不能采用继承的方式对系统进行扩展或者<strong>采用继承不利于系统扩展和维护时可以使用装饰模式</strong>。不能采用继承的情况主要有两类：第一类是<strong>系统中存在大量独立的扩展</strong>，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是<strong>因为类已定义为不能被继承</strong>（如Java语言中的final类）。</p>
<h3 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h3><p>  在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p>
<p>**<em>*代理模式：*<em>给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</em></em></p>
<h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p>   代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层，代理模式结构如图15-2所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/2.4.jpg" alt="2.4"></p>
<p>图15-2 代理模式结构图</p>
<p>   由图15-2可知，代理模式包含如下三个角色：</p>
<p>   (1) Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</p>
<p>   (2) Proxy（代理主题角色）：代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。</p>
<p>   (3) RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理有以下特点:</p>
<p>1.代理对象,不需要实现接口</p>
<p>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</p>
<p>代理类不用再实现接口了。但是，要求被代理对象必须有接口。</p>
<p>Java.lang.reflect.Proxy类可以直接生成一个代理对象</p>
<p>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)生成一个代理对象</p>
<p>参数1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器</p>
<p>参数2:Class&lt;?&gt;[] interfaces 代理对象的要实现的接口 一般使用的被代理对象实现的接口</p>
<p>参数3:InvocationHandler h (接口)执行处理类</p>
<p>InvocationHandler中的invoke(Object proxy, Method method, Object[] args)方法：调用代理类的任何方法，此方法都会执行</p>
<p>参数3.1:代理对象(慎用)</p>
<p>参数3.2:当前执行的方法</p>
<p>参数3.3:当前执行的方法运行时传递过来的参数</p>
<p>在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p>
<p>   (1) <strong>远程代理</strong>(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。</p>
<p>   (2) <strong>虚拟代理</strong>(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</p>
<p>   (3) <strong>保护代理</strong>(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
<p>   (4) <strong>缓冲代理</strong>(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</p>
<p>   (5) <strong>智能引用代理</strong>(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</p>
<h5 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h5><p> 远程代理(Remote Proxy)是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，<strong>远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。</strong>远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而<strong>远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。</strong></p>
<h5 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h5><p>​    **<em>*虚拟代理**(****Virtual Proxy)**</em>***也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</p>
<h5 id="缓冲代理"><a href="#缓冲代理" class="headerlink" title="缓冲代理"></a>缓冲代理</h5><p>​    **<em>*缓冲代理**(Cache Proxy)**</em>***也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。</p>
<p>15.7.1 模式优点<br>       代理模式的共同优点如下：</p>
<p>   (1) 能够协调调用者和被调用者，在一定程度上<strong>降低了系统的耦合度</strong>。</p>
<p>   (2) 客户端可以<strong>针对抽象主题角色进行编程，增加和更换代理类无须修改源代码</strong>，符合<strong>开闭原则</strong>，系统具有较好的<strong>灵活性和可扩展性。</strong></p>
<p>   此外，不同类型的代理模式也具有独特的优点，例如：</p>
<p>   (1) <strong>远程代理</strong>为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</p>
<p>   (2) 虚拟代理通过<strong>一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</strong></p>
<p>   (3) 缓冲代理为某一个操作的结果<strong>提供临时的缓存存储空间，</strong>以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</p>
<p>   (4) 保护代理可以<strong>控制对一个对象的访问权限</strong>，为不同用户提供不同级别的使用权限。</p>
<p>15.7.2 模式缺点<br>       代理模式的主要缺点如下：</p>
<p>   (1) 由于在客户端和真实主题之间增加了代理对象，<strong>因此有些类型的代理模式可能会造成请求的处理速度变慢</strong>，例如保护代理。</p>
<p>   (2) 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</p>
<p>15.7.3 模式适用场景<br>       代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：</p>
<p>   (1) 当客户端对象需要<strong>访问远程主机</strong>中的对象时可以使用远程代理。</p>
<p>   (2) 当需要<strong>用一个消耗资源较少的对象来代表一个消耗资源较多的对象</strong>，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</p>
<p>   (3) 当<strong>需要为某一个被频繁访问的操作结果提供一个临时存储空间</strong>，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</p>
<p>   (4) 当需要<strong>控制对一个对象的访</strong>问，为不同用户提供不同级别的访问权限时可以使用保护代理。</p>
<p>   (5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</p>
<h2 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h2><p><strong>类或对象之间如何交互、如何划分职责，从而更好地完成任务</strong></p>
<h4 id="1、迭代器模式"><a href="#1、迭代器模式" class="headerlink" title="1、迭代器模式"></a>1、迭代器模式</h4><p><strong>迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</strong></p>
<p>   在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.1.jpg" alt="3.1"></p>
<pre><code> ● Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。

   ● ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。

   ● Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。

   ● ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。
</code></pre>
<p><strong>使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现</strong>。**<em>*如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反“开闭原则”，因此在设计时要考虑全面，避免之后修改接口*<em>。</em></em></p>
<h5 id="迭代器案例"><a href="#迭代器案例" class="headerlink" title="迭代器案例"></a>迭代器案例</h5><p>  为了简化AbstractObjectList类的结构，并给不同的具体数据集合类提供不同的遍历方式，Sunny软件公司开发人员使用迭代器模式来重构AbstractObjectList类的设计，重构之后的销售管理系统数据遍历结构如图4所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.1.2.jpg" alt="3.1.2"></p>
<p>，AbstractObjectList充当抽象聚合类，ProductList充当具体聚合类，AbstractIterator充当抽象迭代器，ProductIterator充当具体迭代器。</p>
<h5 id="迭代器模式总结"><a href="#迭代器模式总结" class="headerlink" title="迭代器模式总结"></a>迭代器模式总结</h5><p>​       迭代器模式是一种使用频率非常高的设计模式，<strong>通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来</strong>，<strong>聚合对象只负责存储数据，而遍历数据由迭代器来完成。</strong>由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，我们只需要直接使用Java、C#等语言已定义好的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。</p>
<p>1.主要优点</p>
<p>   迭代器模式的主要优点如下：</p>
<p>   (1) 它<strong>支持以不同的方式遍历一个聚合对</strong>象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</p>
<p>   (2) <strong>迭代器简化了聚合类</strong>。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</p>
<p>   (3) 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，<strong>满足“开闭原则”的要求。</strong></p>
<p>2.主要缺点</p>
<p>   迭代器模式的主要缺点如下：</p>
<p>   (1) 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上<strong>增加了系统的复杂性。</strong></p>
<p>   (2) 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</p>
<p>3.适用场景</p>
<p>   在以下情况下可以考虑使用迭代器模式：</p>
<p>   (1) 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</p>
<p>   (2) 需要为一个聚合对象提供多种遍历方式。</p>
<p>   (3) 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</p>
<h4 id="2、策略模式"><a href="#2、策略模式" class="headerlink" title="2、策略模式"></a>2、策略模式</h4><p> 在软件开发中，我们也常常会遇到类似的情况，<strong>实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径</strong>。</p>
<h5 id="策略模式概述"><a href="#策略模式概述" class="headerlink" title="策略模式概述"></a>策略模式概述</h5><p>  策略模式的主要目的是<strong>将算法的定义与使用分开</strong>，也就是将算法的行为和环境分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。策略模式定义如下：</p>
<p><em><strong>*策略模式**(Strategy Pattern)**：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式**(Policy)**。策略模式是一种对象行为型模式。*</strong></em></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.2.1.jpg" alt="3.2.1"></p>
<p>  ● Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</p>
<p>  ● Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</p>
<p>  ● ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</p>
<h5 id="策略案例"><a href="#策略案例" class="headerlink" title="策略案例"></a>策略案例</h5><p> 为了实现打折算法的复用，并能够灵活地向系统中增加新的打折方式，Sunny软件公司开发人员使用策略模式对电影院打折方案进行重构，重构后基本结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.2.2.jpg" alt="3.2.2"></p>
<p>MovieTicket充当环境类角色，Discount充当抽象策略角色，StudentDiscount、 ChildrenDiscount 和VIPDiscount充当具体策略角色。</p>
<h5 id="策略模式总结"><a href="#策略模式总结" class="headerlink" title="策略模式总结"></a>策略模式总结</h5><p>​      策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式。</p>
<p>1.主要优点</p>
<p>  策略模式的主要优点如下：</p>
<p>  (1) 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p>
<p>  (2) 策略模式提供了管理相关的算法族的办法。<strong>策略类的等级结构定义了一个算法或行为族</strong>，<strong>恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。</strong></p>
<p>  (3) 策略模式提供了一种可以<strong>替换继承关系</strong>的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。</p>
<p>  (4) 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</p>
<p>  (5) 策略模式提供了一种<strong>算法的复用机制</strong>，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p>
<p>3.主要缺点</p>
<p>  策略模式的主要缺点如下：</p>
<p>  (1) 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，<strong>策略模式只适用于客户端知道所有的算法或行为的情况。</strong></p>
<p>  (2) 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p>
<p>  (3) <strong>无法同时在客户端使用多个策略类</strong>，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。</p>
<p>3.适用场景</p>
<p>  在以下情况下可以考虑使用策略模式：</p>
<p>  (1) 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。</p>
<p>  (2) 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。</p>
<p>  (3) 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。</p>
<h4 id="3、责任链模式"><a href="#3、责任链模式" class="headerlink" title="3、责任链模式"></a>3、责任链模式</h4><p><em><strong>*职责链模式**(Chain of Responsibility Pattern)**：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。*</strong></em></p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.3.1.jpg" alt="3.3.1"></p>
<p>● Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。</p>
<p>  ● <strong>ConcreteHandler（具体处理者）</strong>：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p>
<p>  在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在<strong>不影响客户端的情况下动态地重新组织链和分配责任。</strong></p>
<p> 具体处理者是抽象处理者的子类，它具有两大作用：<strong>第一是处理请求</strong>，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；<strong>第二是转发请求</strong>，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</p>
<p>****职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链****。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 </p>
<p> 为了让采购单的审批流程更加灵活，并实现采购单的链式传递和处理，Sunny公司开发人员使用职责链模式来实现采购单的分级审批，其基本结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/3.3.2.jpg" alt="3.3.2"></p>
<p> 抽象类Approver充当抽象处理者（抽象传递者），Director、VicePresident、President和Congress充当具体处理者（具体传递者），PurchaseRequest充当请求类。</p>
<h5 id="纯与不纯的职责链模式"><a href="#纯与不纯的职责链模式" class="headerlink" title="纯与不纯的职责链模式"></a>纯与不纯的职责链模式</h5><p>   职责链模式可分为纯的职责链模式和不纯的职责链模式两种</p>
<p> (1)纯的职责链模式</p>
<p> 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：<strong>要么承担全部责任，要么将责任推给下家</strong>，要求一个请求必须被某一个处理者对象所接收</p>
<p> (2)不纯的职责链模式</p>
<p>   在一个不纯的职责链模式中****允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收****。</p>
<h5 id="职责链模式总结"><a href="#职责链模式总结" class="headerlink" title="职责链模式总结"></a>职责链模式总结</h5><p>​      职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。</p>
<p>在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用职责链模式可以较好地解决此类问题。</p>
<p>   1.主要优点</p>
<p>  职责链模式的主要优点如下：</p>
<p>   (1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，<strong>降低了系统的耦合度</strong>。</p>
<p>   (2) 请求处理对象<strong>仅需维持一个指向其后继者的引用</strong>，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</p>
<p>   (3) 在给<strong>对象分派职责时，职责链可以给我们更多的灵活性</strong>，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</p>
<p>   (4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是<strong>符合“开闭原则”的。</strong></p>
<p>​      </p>
<p>   2.主要缺点</p>
<p>  职责链模式的主要缺点如下：</p>
<p>   (1) 由于一个请求<strong>没有明确的接收者</strong>，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；<strong>一个请求也可能因职责链没有被正确配置而得不到处理</strong>。</p>
<p>   (2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，<strong>系统性能将受到一定影响</strong>，而且在进行代码调试时不太方便。</p>
<p>   (3) <strong>如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</strong></p>
<p>   3.适用场景</p>
<p>  在以下情况下可以考虑使用职责链模式：</p>
<p>   (1) 有<strong>多个对象可以处理同一个请求</strong>，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</p>
<p>   (2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p>
<p>​    (3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 </p>
<h4 id="4、观察者模式"><a href="#4、观察者模式" class="headerlink" title="4、观察者模式"></a>4、观察者模式</h4><p>观察者模式是使用频率最高的设计模式之一，它用于<strong>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。</strong>在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</p>
<p><strong>观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。</strong></p>
<p> 观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.1.jpg" alt="4.1"></p>
<p>● Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中<strong>定义了一个观察者集合</strong>，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。</p>
<p>  ● ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</p>
<p>  ● Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。</p>
<p>  ● ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。</p>
<p>  观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。</p>
<h5 id="观察者方案"><a href="#观察者方案" class="headerlink" title="观察者方案"></a>观察者方案</h5><p>   为了实现对象之间的联动，Sunny软件公司开发人员决定使用观察者模式来进行多人联机对战游戏的设计，其基本结构如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.4.2.jpg" alt="4.4.2"></p>
<p>AllyControlCenter充当目标类，ConcreteAllyControlCenter充当具体目标类，Observer充当抽象观察者，Player充当具体观察者。</p>
<h5 id="观察者模式与MVC"><a href="#观察者模式与MVC" class="headerlink" title="观察者模式与MVC"></a>观察者模式与MVC</h5><p>​      在当前流行的MVC(Model-View-Controller)架构中也应用了观察者模式，MVC是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。其中<strong>模型可对应于观察者模式中的观察目标</strong>，而<strong>视图对应于观察者</strong>，<strong>控制器可充当两者之间的中介者</strong>。当模型层的数据发生改变时，视图层将自动改变其显示内容。如图所示：</p>
<p><img src="https://zyc-oss.oss-cn-hangzhou.aliyuncs.com/markdown/4.4.3.jpg" alt="4.4.3"></p>
<p>​                                        MVC结构示意图</p>
<pre><code>     模型层提供的数据是视图层所观察的对象，在视图层中包含两个用于显示数据的图表对象，一个是柱状图，一个是饼状图，相同的数据拥有不同的图表显示方式，如果模型层的数据发生改变，两个图表对象将随之发生变化，这意味着图表对象依赖模型层提供的数据对象，因此数据对象的任何状态改变都应立即通知它们。同时，这两个图表之间相互独立，不存在任何联系，而且图表对象的个数没有任何限制，用户可以根据需要再增加新的图表对象，如折线图。在增加新的图表对象时，无须修改原有类库，满足“开闭原则”。
</code></pre>
<h5 id="观察者模式总结"><a href="#观察者模式总结" class="headerlink" title="观察者模式总结"></a>观察者模式总结</h5><p>​      观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用或者桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p>
<p>  1.主要优点</p>
<p>  观察者模式的主要优点如下：</p>
<p>  (1) 观察者模式可以<strong>实现表示层和数据逻辑层的分离</strong>，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。</p>
<p>  (2) 观察者模式在<strong>观察目标和观察者</strong>之间<strong>建立一个抽象的耦合</strong>。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。</p>
<p>  (3) 观察者模式<strong>支持广播通信</strong>，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。</p>
<p>  (4) 观察者模式<strong>满足“开闭原则”的要求</strong>，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</p>
<p>  2.主要缺点</p>
<p>  观察者模式的主要缺点如下：</p>
<p>  (1) 如果<strong>一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。</strong></p>
<p>  (2) 如果在<strong>观察者和观察目标之间存在循环依赖</strong>，<strong>观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</strong></p>
<p>  (3) <strong>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</strong></p>
<p>  3.适用场景</p>
<p>  在以下情况下可以考虑使用观察者模式：</p>
<p>  (1) 一个抽象模型有两个方面，<strong>其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。</strong></p>
<p>  (2) 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。</p>
<p>  (3**) 需要在系统中创建一个触发链**，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
